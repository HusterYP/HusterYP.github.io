---
layout:     post
title:      "Java并发[一]"
subtitle:   "Java并发编程实战第一部分总结
date:       2018-10-31
author:     "袁平"
header-img: "img/tag-bg.jpg"
tags:
    - Java
---

# 前言

> Java并发编程实战第一部分总结

--------------

# 正文

-----------------

## 一. 基本概念

1. **先检查后执行**: 首先观察到某个条件为真(例如文件X不存在), 然后根据这个观察结果采用相应的动作(创建文件X), 但事实上, 在你观察到这个结果以及开始穿件文件之间, 观察结果可能变得无效(另一个线程创建了文件X), 从而导致各种问题(未预期异常, 数据被覆盖, 文件被破坏等)

2. 每个`Java`对象都可以用作一个实现同步的锁, 这些锁被称为内置锁或监视锁(`synchronized`)

3. 不要在构造过程中使`this`引用逸出: 当且仅当对象的构造函数返回时, 对象才处于可预测的和一致的状态, 因此, 当从对象的构造函数中发布对象时, 只是发布了一个尚未构造完成的对象, 如果`this`引用在构造过程中逸出, 那么这种对象就被认为是不正确的构造; 常见场景是:

> 1. 在构造函数中创建线程: 在构造函数中创建线程并没有错, 但是最好不要立即启动它
> 2. 在构造函数中注册事件监听: 依据是非静态内部类会持有外部类的引用

考虑下列程序

```
class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() { // this逸出
            public void onEvent(Event e) { 
                doSomething(); 
            }
        });
    }
}
```

使用静态工厂方法来防止`this`引用在构造过程中逸出

```
class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething();
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener listener = new SafeListener();
        source.registerListener(listener.listener);
        return listener;
    }
}
```

4. 一个正确构造的对象可以通过以下方式来安全的发布:
> 1. 在静态初始化函数中初始化一个对象引用
> 2. 将对象的引用保存到`volatile`类型的域或者`AtomicReferance`对象中
> 3. 将对象的引用保存到某个正确构造对象的`final`类型域中
> 4. 将对象的引用保存到一个由锁保护的域中

要安全的发布一个静态构造的对象, 最简单和安全的方式是使用静态的初始化器: 静态初始化器由`JVM`在类的初始化阶段执行, 由于在`JVM`内部存在着同步机制, 因此通过这种方式初始化的任何对象都可以被安全的发布

```
public static Holder holder = new Holder();
```

---------------------------

## 二. synchronized

1. `synchronized`使用的是对象锁, 修饰方法, 代码块或局部执行代码时, 使用的是当前锁对象; 修饰静态方法时, 使用的`XX.class`锁对象

2. 内置锁(`synchronized`)可重入; 可重入: 如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功, 而不会造成死锁
考虑如下代码, 子类改写了父类的`synchronized`方法, 然后调用父类中的方法, 此时如果没有可重入的锁, 那么这段代码将产生死锁

```
class Widget {
    public synchronized void doSomething() {
        System.out.println("Widget");
    }
}

class LoggingWidget extends Widget {
    @Override
    public synchronized void doSomething() {
        System.out.println("LoggingWidget");
        super.doSomething();
    }
}
```

3. 关键字`synchronized`不能被继承: 
> 1、子类继承父类时, 如果没有重写父类中的同步方法, 子类同一对象, 在不同线程并发调用该方法时, 具有同步效果
> 2.  子类继承父类, 并且重写父类中的同步方法,但没有添加关键字`synchronized`, 子类同一对象, 在不同线程并发调用该方法时, 不再具有同步效果

```
public class Widget {
    public synchronized void doSomething() {
        System.out.println(Thread.currentThread() + " Widget");
    }
}

class LoggingWidget extends Widget {
    @Override
    public void doSomething() { // 这里没有加synchronized
        System.out.println(Thread.currentThread() + " LoggingWidget"); // 由于子类的doSomething()没有加synchronized方法, 所以子类的doSomething()不可同步
        super.doSomething(); // 但是父类的doSomething()仍可同步
    }
}
```

------------------

## 三. volatile

1. `volatile`变量用来确保将变量的更新操作通知到其他线程; 当把变量声明为`volatile`类型后, 不会将该变量上的操作与其他内存操作一起重排序, `volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方, 因此在读取`volatile`类型的变量总会返回最新写入的值

2. 在当前大多数处理器架构上, 读取`volatile`变量的开销只比读取非`volatile`变量的开销略高一些

3. 对于非`volatile`类型的`long`和`double`变量(`64`位), `JVM`允许将`64`位的读操作或写操作分解为两个`32`位的操作; 当读取一个非`volatile`类型的`long`变量时, 如果对该变量的读操作和写操作在不同线程中执行, 那么很可能会读取到某个值的高`32`位和另一个值的低`32`位; 因此, 即使不考虑失效数据问题, 在多线程中使用共享且可变的`long`和`double`等类型的变量也是不安全的, 除非用`volatile`来声明他们, 或者用锁保护起来

--------------------

## 四. 同步工具类

> 同步工具类可以根据其自身的状态来协调线程的控制流; 可以用作同步工具类的如: 阻塞队列, 信号量(Semaphore), 栅栏(Barrier), 闭锁(Latch)




---------------------


Vector, Hashtable, CopyOnWriteArrayList(写入时复制: Copy-On-Write), CopyOnWriteArraySet, BlockingQueue, ConcurrentLinkedQueue, PriorityQueue
Deque: ArrayDeque, LinkedBlockingDeque


三个interrupt()理解
