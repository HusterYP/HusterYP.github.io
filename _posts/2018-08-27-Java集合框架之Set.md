---
layout:     post
title:      "Java集合框架之Set"
subtitle:   "讲解Set实现类"
date:       2018-08-27
author:     "袁平"
header-img: "img/tag-bg.jpg"
tags:
    - Java
---

# 前言

> [前面](https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/)我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是`Set`的实现类, 即常用的`HashSet`, `TreeSet`和`LinkedHashSet`

文章源码基于`JDK8`

----

# 正文

----

## 一. HashSet

`HashSet`内部是基于`HashMap`实现的, 所以在讲解`HashSet`之前, 需要先看一下`HashMap`的实现, 可以参照[Java集合框架之HashMap](https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/), 该篇文章中详细介绍了`HashMap`的实现原理和特点, 推荐对`HashMap`有了一个大致的了解之后再开始往下读 ~

总体而言, `HashSet`的代码比较简单, 其实现`Set`元素不重复性其实是利用`HashMap`键值的唯一性; 当我们存放一个`Value`的时候, 其实是将该`Value`当做`HashMap`中的键值的,  而实现的各种常规操作, 比如: `add()`, `remove()`, `contains()`等, 其实都是间接调用了`HashMap`中的相应操作

所以, 这里不会去细讲`HashSet`代码, 了解`HashMap`之后, 其实是很简单的

这里只是贴一下`HashSet`的特点:

1. 没有重复元素, 允许`null`

2. 不保证`Set`的遍历顺序, 不保证元素的存储数据(具体原因可以见上面博客对`HashMap`的分析)

3. 对`add()`, `remove()`, `contains()`, `size()`方法提供常量时间

4. 非同步, 可以使用`Collections.synchronizedSet(new HashSet(...));`

5. `Iterator`遍历的时候, 多线程抛出异常`ConcurrentModificationException`(遍历过程中修改数据, 但是可以使用`Iterator`自己提供的`remove()`方法, 该方法不会造成异常)(原因参见[Java集合框架之List](https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/)中分析)


