---
layout:     post
title:      "Java集合框架"
subtitle:   "Java集合框架讲解与总结"
date:       2018-08-25
author:     "袁平"
header-img: "img/tag-bg.jpg"
tags:
    - Java 
---

# 前言
> Java集合框架讲解与总结

# 正文

## 参考链接
[官方文档--集合框架指南](https://docs.oracle.com/javase/9/docs/api/java/util/package-summary.html#CollectionsFramework)
[集合框架的分类](https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-reference.html)
[集合框架设计理念答疑文档](https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-designfaq.html)


集合框架概述
> 包括接口, 实现和算法(当然还包括一些保证兼容性的API, 如Hashtable, Vector等(在Java 2之前，Java是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如Vector，Stack，Hashtable等))
> 一组对象的集合
> 独立于实现细节, 重用
> 加强无关API之间的互通信

集合框架总接口分为两个部分: 一个从Collection出发, 一个从Map出发(实际上从Map出发的并不是真正的集合, 只是其包含集合视图操作, 所以也将其归入集合框架中)


Collection: 作用? 提供功能
> 不提供直接实现类, 而是提供更具限制性的接口, 如List, Set等
> 公共对象的抽取, 数据的集合, 允许子接口实现个性化扩展(比如: 是否允许同步, 是否允许元素有序, 是否允许元素重复
> 加强了无关API之间的互通性, 减少新API的学习


List, Set, Queue: 区别, 实现原理, 提供功能, 适用场景

----------------

理解: `Collections that are not immutable are mutable`: [参见StackOverFloaw回答](https://stackoverflow.com/questions/8892350/immutable-vs-unmodifiable-collection)
理解: [原文](https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-overview.html)
```
Collections that do not support modification operations (such as add, remove and clear) are referred to as unmodifiable. Collections that are not unmodifiable are modifiable.
Collections that additionally guarantee that no change in the Collection object will be visible are referred to as immutable. Collections that are not immutable are mutable.
```
可以结合`emptySet, emptyList and emptyMap - Return an immutable empty set, list, or map.`来理解

------------

RandomAccess: 标识能够在常量时间内定位元素(叫random access lists)

Iterator: Iterable, ListIterator, Iterable
能够双向遍历线性表的新列表迭代器ListIterator
可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序, 此处应该和Collections的算法相联系

直接实现Collection: List, Set, Queue

AbstractCollection是提供Collection部分实现的抽象类; 集合框架中的Abstract的部分是集合接口的部分实现, 作用是有助于提供自定义实现(这些有: AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList and AbstractMap)

接口Deque，是一个扩展自Queue的双端队列
PriorityQueue类实现了一个优先队列

在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

Collections: 其不仅提供了一系列针对集合的算法, 还提供了一系列对集合的包装类(Wrapper; 包括三大类: `Collections.unmodifiableInterface`, `Collections.synchronizedInterface `, `Collections.checkedInterface `), 比如:`synchronizedCollection()`(支持同步), `unmodifiableList()`

----
并发(Concurrent Collections): [参见文档]()https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html

包括的接口: 
BlockingQueue
TransferQueue
BlockingDeque
ConcurrentMap
ConcurrentNavigableMap

实现类
LinkedBlockingQueue
ArrayBlockingQueue
PriorityBlockingQueue
DelayQueue
SynchronousQueue
LinkedBlockingDeque
LinkedTransferQueue
CopyOnWriteArrayList
CopyOnWriteArraySet
ConcurrentSkipListSet
ConcurrentHashMap
ConcurrentSkipListMap

---

Arrays
