---
layout:     post
title:      "View之绘制流程"
subtitle:   "Android源码分析之View绘制流程"
date:       2018-09-24
author:     "袁平"
header-img: "img/tag-bg.jpg"
tags:
    - Android
    - View
---

# 前言

`Android`源码分析之`View`系列之绘制流程

---------------------

# 正文

---------------


## 一. 概述

`View`的绘制流程分为三大步: `measure`, `layout`, `draw`; `measure`即测量, 测量`View`的大小; `layout`即布局, 按照一定的规则排布`View`; `draw`即绘制, 绘制`View`的外形; 这三步是和我们自定义`View`息息相关的, 熟悉和掌握这三大流程, 我们才能随心所欲的定制`View`; 本文也将从这三个方面入手, 结合源码讲解

在开始之前, 需要先了解一下`View`绘制的整体流程, 如下图; 

![View绘制流程](/img/post/View/View绘制流程.png)

**注**: 图片来自: https://www.jianshu.com/p/dc0b039e7c4f

可以看出, 与`View`三大流程直接相关的是从`performTraversals()`开始的; 大致流程如下

```
private void performTraversals() {
    ...
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
    performLayout(lp, mWidth, mHeight);
    ...
    performDraw();
    ...
}
```


--------------

## 二. measure过程

### 2.1 MeasureSpec

`MeasureSpec`是一个`32`位`int`类型的值, 是`SpecMode`和`SpecSize`的位组合; 高`2`位表示`SpecMode`, 低`30`位表示`SpecSize`, 这样设计其实是为了节约空间; 关于二者如何组合, 可以参见以下代码; 可以看出, 其实就是通过`MODE_MASK`掩码以及位操作实现将两个`int`类型整合为一个`32``int`类型的`MeasureSpec`; 当然, 要分别提取这两个值的话, 也可以很简单的用位操作实现, 代码比较简单, 就不贴啦~

```
        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 << MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size & ~MODE_MASK) | (mode & MODE_MASK); // MODE_MASK  = 0x3 << 30; 
            }
        }
```

`SpecMode`即测量模式, 一共有三类:

1. **UNSPECIFIED**: 父容器不对`View`有任何限制, 要多大给多大, 这种情况一般用于系统内部

2. **EXACTLY**: 对应于`LayoutParams`中的`match_parent`和具体数值这两种模式

3. **AT_MOST**: 父容器指定了一个可用大小即`SpecSize`, `View`的大小不能大于该值, 对应于`LayoutParams`中的`wrap_content`

从`SpecMode`的类型区别可以看出, `MeasureSpec`的确定受`LayoutParams`的影响, 但是也要分情况: 对于`RootView`即`DecorView`来说, 由于其没有父`View`, 所以`DecorView`的`MeasureSpec`由窗口尺寸和自身的`LayoutParams`共同决定; 对于普通`View`来说, 其`MeasureSpec`由父容器的`MeasureSpec`和自身的`LayoutParams`共同决定


### 2.1 DecorView的measure过程

我们知道, `DecorView`是整个`View`树的`root`, 是一个`FrameLayout`, 我们首先来看`DecorView`的测量过程; 在`performTraversals()`中, 首先通过`getRootMeasureSpec()`来获取`MeasureSpec`, 如下; 

```
private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
}
```
