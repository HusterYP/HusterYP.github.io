---
layout:     post
title:      "iOS读书笔记"
subtitle:   "iOS读书笔记"
date:       2019-02-15
author:     "袁平"
header-img: "img/tag-bg.jpg"
tags:
    - iOS
---

# 前言

iOS 各类书籍读书笔记

摘要各本书中重难点

-----------


# 正文

------------

## Objective-C 编程之道：iOS 设计模式

1. 中介者模式是至用一个对象来封装一组对象之间的交互逻辑，中介者通过避免对象间显示的相互引用来增进不同对象间的松耦合

2. 备忘录模式允许对象按其想要的任何（或者任意复杂的）方式将自己的壮状态保存为一个对象，根据此模式这个对象被称为备忘录对象，然后某个其他对象，比如看管人对象，将备忘录对象保管在某处，通常是文件系统或内存中；看管人对象不知道有关备忘录对象的任何细节的格式，一段时间之后，接收到请求时，看管人对象将备忘录对象传回给原来的对象，让他根据在备忘录对象中保存的信息恢复其状态

3. 代理模式的一个特点是同归虚拟代理，在接到请求时实现重型资源的懒加载

4. 软件设计的黄金法则：变动需要抽象

5. 桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更；抽象层定义了供客户端使用的上层抽象接口；可以[参见博客](https://www.jianshu.com/p/e986af029490)

6. 外观模式为子系统中一组不同的接口提供统一的接口呢，外观模式定义了上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用（其实就是对一系列复杂操作再次进行封装，隐藏调用或者实现细节）

7. 中介者模式用于定义一个集中的场所，对象间的交互可以在一个中介者对象中处理；其他对象不必彼此交互，因此减少了它们之间的依存关系

8. 观察者模式：iOS 中观察者模式可以通过通知和键值观察(KVO)来实现

9. 迭代器模式：迭代器（Iterator）提供了一种顺序访问聚合对象(集合)中元素的方法，而无需暴露结构的底层表示和细节

10. 装饰模式：即动态的为一个对象添加额外的指责，是继承的替代方案，属于结构型模式（继承是编译时静态绑定，装饰模式是可以在运行是动态绑定，即定义一个接口，然后动态的注入不同的实现类）

11. 责任链模式：即如果一个对象不知道如何处理一个请求，则将该请求传递给另一个对象，这样继续传递下去

12. 策略模式：提取公共接口，不同实现

13. 命令模式：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作

14. 享元模式：实现享元模式需要两个关键组件，通常是可共享的享元对象和保存他们的池

15. 代理模式：代理是一种替代或占位，它控制对另一些对象的访问，而这些对象可能是远程对象，创建的开销较大的对象，或者是对安全性有要求的对象（NSProxy）


--------------


## UICollectionView解析

1. UICollectionViewCell 的层级结构见下图；UICollectionViewCell 有三个子 View ，下图中黑色矩形是 CollectioView Cell 自身，绿色矩形是 contentView，我们应该在contentView上面添加子 View，中间的两层 selectedBackgroundView 和 backgroundView 是可选的，并且可以在任何时候进行设置（当 backgroundView 被设置的时候，将会永远显示；selectedBackgroundView 在 Cell 被选中的时候设置，在 Cell 取消选中的时候移除，并且还可以为其设置动画）

![](/img/post/iOS_Read_Note/UICollectionViewCell_Hierarchy.png) 


---------------

## iOS Drawing: Practical UIKit Solution

1. Context：包含了绘图的上下文环境；主要使用的有两种：
> 1. Bitmap Context：使用像素数据来绘制
> 2. PDF Contexta：矢量数据，以矢量的形式来绘制
> 3. Core Image Context：帮助进行图像处理，如数字图像处理和计算机视觉等，通过GPU加速

2. iOS绘图程序主要基于UIKit和QuartzCore框架(QuertzCore框架通常被称作Quartz或者Quartz 2D)，它由新的Objective-C界面（UIKit提供）和老旧一些的C语言方法和核心基础类（QuartzCore）组成

3. 在绘制图像的时候，有一个很重要的概念是上下文（Context），其实类似于一个大的状态机，每次改变都会改变其当前状态，可以通过 CGContextSaveGState 来暂存当前状态，之后通过 CGContextRestoreCState 来恢复状态；可以改变 Context 的属性如下图：

![](/img/post/iOS_Read_Note/Context_State.png)

4. 需要注意的是 UIKit 中坐标系原点为屏幕坐上点，在Quartz中，原点位于左下点，如下图；

![](/img/post/iOS_Read_Note/坐标系.png)

5. Quartz 和 UIKit 绘图方法都是线程安全的

6. 以CG开头Ref结尾的类型是指，指向对象的指针

7. 坐标系转换，即把一个点从视图坐标系转换到它的父视图的坐标系中：CGPoint convertedPoint = [fahterView convertPoint:samplePoint fromView:childView]; 如果要反向转换，可以使用：转换回来，使用convertRect：toView：；前提是这些视图必须在同一个 UIWindow 中

8. CGAffineTransform 可以用于进行旋转，缩放，位移变换（其实也是一个变换矩阵，如下图）；一般都不使用 CGAffineTransformMake 方法来构建，通常使用 CGAffineTransformMakeScale（），CGAffineTransformMakeRotate（）或是CGAffineTransformMakeTranslation（）来分别构造缩放，旋转，位移矩阵；可以通过 UIKit 的 NSStringFromCGAffineTransform 方法打印处转换后的矩阵值；

![](/img/post/iOS_Read_Note/CGAffineTransform.png)

9. CGPoint，CGRect，CGSize，CGAffineTransform等几何元素并不是对象，如果要存储或者更加直观的打印这些几何元素，OC 也提供了对应的方法，如：
> 1. 转换为 strings

![](/img/post/iOS_Read_Note/To_Strings.png)

> 2. 转换为字典

![](/img/post/iOS_Read_Note/To_Dictionary.png)

> 3. 转换为值类型

![](/img/post/iOS_Read_Note/To_Value.png)

10. 几何测试方法

![](/img/post/iOS_Read_Note/Graph_Test.png)

