<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 24 Jan 2019 19:40:20 +0800</pubDate>
    <lastBuildDate>Thu, 24 Jan 2019 19:40:20 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Objective-C入门要点</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;近日开始入坑iOS，正所谓工欲善其事，必先利其器；iOS的两大基础利器莫过于OC和Swift这两门语言了；笔者先接触的是OC，时至今日也近一月，以此总结，记录OC的一些要点和难点&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-面向对象&quot;&gt;一. 面向对象&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;OC是C的一个扩展集，在C的基础上添加了面向对象和消息传递等机制；作为一门面向对象的语言，自然需要探讨面向对象三大特性在OC上的体现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;11-封装&quot;&gt;1.1 封装&lt;/h3&gt;

&lt;p&gt;笔者认为，封装更多的是体现在类或者说类的设计上面，有点带设计模式那个层次，如果真要从语法层面去讲解的话，更契合的还是类，方法，成员变量的访问修饰符&lt;/p&gt;

&lt;p&gt;OC中类没有访问修饰符，OC中也没有package的概念&lt;/p&gt;

&lt;p&gt;OC中方法也没有权限修饰符一说，在头文件中声明的方法都相当于是public的，如果要定义私有方法，则只需在.m文件中实现，但不需要在.h文件声明&lt;/p&gt;

&lt;p&gt;成员变量权限访问修饰方法主要有如下三种；除了以下三种外，还有一个是@package，它修饰属性的时候，只能在当前框架中才能呗访问，用的比较少&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;修饰符&lt;/th&gt;
      &lt;th&gt;类内部&lt;/th&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;任何地方&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;private&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;protected（默认）&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;public&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;12-继承&quot;&gt;1.2 继承&lt;/h3&gt;

&lt;p&gt;OC只支持单继承，如果要实现多继承，可以采用如下三种方式：&lt;/p&gt;

&lt;h4 id=&quot;121-通过组合实现&quot;&gt;1.2.1 通过组合实现&lt;/h4&gt;

&lt;p&gt;组合实际上就是说如果一个类无法实现某个功能，那么就将该需求转接到另一个类实现，比较简单，就是将能实现该功能的类作为自己的一个成员变量&lt;/p&gt;

&lt;h4 id=&quot;122-通过协议实现&quot;&gt;1.2.2 通过协议实现&lt;/h4&gt;

&lt;p&gt;协议类似于Java中的接口，但是也有所不同，参见下面对协议的讲解；OC中只能继承一个类，但是可以实现多个协议&lt;/p&gt;

&lt;h4 id=&quot;123-通过category实现&quot;&gt;1.2.3 通过Category实现&lt;/h4&gt;

&lt;p&gt;Category可以实现在不继承类的基础上实现对类的扩展；这里使用Category实现多继承举例如下：Child已经继承了Father，想要再对Child扩展方法，可以使用Category扩展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 文件：Child.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Father&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;showChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 文件：Child+Hello.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 文件：Child+Hello.m
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-多态&quot;&gt;1.3 多态&lt;/h3&gt;

&lt;p&gt;Java中多态的实现依赖于重写，重载和向上转型（动态链接）；但是OC中方法不能重载，可以重写，其余的和普通Java多态的概念和用法基本相同；另外，Java中多态还有一个重要的点就是接口，依赖于接口达到的运行时动态绑定，与之对应的，在OC中可以使用协议实现&lt;/p&gt;

&lt;p&gt;这里还需要注意的是，重新认识OC中的方法签名，OC的语法比较冗余，举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 函数原型如下，方法签名为：addNumber1:andNumber2:
- (NSInteger)addNumber1:(NSInteger)number1 andNumber2:(NSInteger)number2;

// 函数原型如下，方法签名为：add::
- (NSInteger)add:(NSInteger)number1 :(NSInteger)number2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-协议&quot;&gt;二. 协议&lt;/h2&gt;

&lt;p&gt;OC中的协议相当于Java中的接口，很多设计模式都依赖于协议；但是OC中的协议于Java中的接口也有一些细微的差别；&lt;/p&gt;

&lt;p&gt;一般而言，协议应该与对应的类声明在同一个头文件中，与Java中接口不同的是，协议的中的方法不是必须都实现的，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@optional&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@required&lt;/code&gt;来声明方法，但是使用@required修饰的协议方法也不是必须实现的，如果没有实现，编译会报警告；但是如果调用了一个没有实现的协议方法的话，运行时会崩溃&lt;/p&gt;

&lt;p&gt;协议中不能有默认方法实现，这点与Java中的接口相同，但是OC的协议中不能定义变量；协议可以被class，struct，enum实现&lt;/p&gt;

&lt;p&gt;协议的使用场景：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;需要由别的类实现的方法&lt;/li&gt;
    &lt;li&gt;声明未知类的接口&lt;/li&gt;
    &lt;li&gt;两个类之间的通信&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-define宏定义&quot;&gt;三. define：宏定义&lt;/h2&gt;

&lt;p&gt;OC中的宏定义是非常强大的，合理使用可以极大的简化和优雅代码&lt;/p&gt;

&lt;h3 id=&quot;31-defineconstenum定义常量&quot;&gt;3.1 define，const，enum定义常量&lt;/h3&gt;

&lt;p&gt;define宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大&lt;/p&gt;

&lt;p&gt;const常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查&lt;/p&gt;

&lt;p&gt;enum枚举：只能定义int类型&lt;/p&gt;

&lt;p&gt;推荐使用const常量&lt;/p&gt;

&lt;p&gt;部分摘自&lt;a href=&quot;https://www.jianshu.com/p/f83335e036b5&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-宏定义&quot;&gt;3.2 宏定义&lt;/h3&gt;

&lt;p&gt;使用宏定义可以将一些冗杂的语句简化，使得调用简明；常用宏可以参见&lt;a href=&quot;https://my.oschina.net/leejan97/blog/354904&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-property修饰符&quot;&gt;四. @property修饰符&lt;/h2&gt;

&lt;p&gt;本来@property是和@synthesize共用来实现自动生成set和get方法的，但是Xcode4.4之后，@property得到了增强，只使用@property即可生成set和get方法，同时还会自动生成一个带下划线的同名私有变量（需要注意的是，当我们自己写了对应的set和get方法时，该带下划线的同名变量将不可用，解决办法参见&lt;a href=&quot;https://www.jianshu.com/p/baef6d5a41d3&quot;&gt;博客&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;但是@property的使用难点在于理解其修饰符，常见的几组如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;atomic, nonatomic：是否线程安全；默认为atomic，线程安全，但是会影响性能，一般使用nonatomic&lt;/li&gt;
    &lt;li&gt;retain, copy, assign：默认为assign，该修饰符对属性只是简单的赋值，不更改引用计数，常用于基本数据类型，如：int，short等；retain一般用于修饰指针，会持有对象，增加引用计数
readonly, readwrite
strong, getter=method, setter=method, unsafe_unretained&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;weak和assign的区别：weak和assign的区别主要是体现在两者修饰OC对象时的差异。上面也介绍过，assign通常用来修饰基本数据类型，如int、float、BOOL等，weak用来修饰OC对象，如UIButton、UIView等；weak不能修饰基本数据类型&lt;/p&gt;

&lt;p&gt;推荐博客：
https://hk.saowen.com/a/1bdf81decab39874080a44833b2fc47eb8a59355e9ae2b997565552d63991f4d
https://hk.saowen.com/a/7b29e511436f99243478a22570615137266de714cbcda782e798ab04a4611d5e  及其后文链接
https://hk.saowen.com/a/e7b69dbe7dfea4e5a00ebd4ef4a73a61403c8351d319eb901a05388d38513dbf  及其后文链接&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-xcode与模拟器快捷键&quot;&gt;五. Xcode与模拟器快捷键&lt;/h2&gt;

&lt;p&gt;说实话，刚从Android Studio转到Xcode实际上是很不习惯的，很明显的一个就是IDE写代码不顺手，AS各种快捷键与插件写起代码来简直上天～&lt;/p&gt;

&lt;p&gt;但既已入坑，还是自己去适应呗&lt;/p&gt;

&lt;p&gt;Xcode常用快捷键：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd + shift + o      快速打开文件
cmd + 1              切换成 Project Navigator (cmd + 2~7 也可以做相应切换，不过不常用）
cmd + ctrl + 上     在 .h 和 .m 文件之间切换
cmd + enter          切换成 standard editor
cmd + opt + enter    切换成 assistant editor
cmd + shift + y      切换 Console View 的显示或隐藏
cmd + 0              隐藏左边的导航 (Navigator) 区
cmd + opt + 0        隐藏右边的工具 (Utility) 区
ctrl  + 6            列出当前文件中所有的方法，可以输入关键词来过滤。这个相当赞，可以快速定位到想编辑的方法。
                     我直接把这个快键盘改成了 ctrl+o，这样按起来更顺手。
cmd + ctrl + 左 / 右   到上 / 下一次编辑的位置，在 2 个编辑位置跳转的时候很方便。
cmd + opt + j        跳转到文件过滤区
cmd + shift + f      在工程中查找
cmd + r              运行，如果选上直接 kill 掉上次进程的话，每次直接一按就可以重新运行了
cmd + b              编译工程
cmd + shift + k      清空编译好的文件
cmd + .              结束本次调试
ESC                  调出代码补全
cmd + 单击           查看该方法的实现
opt + 单击           查看该方法的文档
cmd + t              新建一个 tab 栏
cmd + shift + [      在 tab 栏之间切换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模拟器常用快捷键：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHIFT+CMD+H	回到桌面
CMD+Q		退出模拟器
CMD+S		模拟器截屏(所截图片都在桌面上)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-内存管理&quot;&gt;六. 内存管理&lt;/h2&gt;

&lt;p&gt;内存管理是一个比较难的点，东西也很多，并非三言两语就能阐述清楚，后面有机会再另起新篇&lt;/p&gt;
</description>
        <pubDate>Wed, 23 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/23/Objective-C%E5%85%A5%E9%97%A8%E8%A6%81%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/23/Objective-C%E5%85%A5%E9%97%A8%E8%A6%81%E7%82%B9/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>大三上总结</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;大三上总结&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h2 id=&quot;技术&quot;&gt;技术&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;看书：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;«深入理解计算机系统»&lt;/li&gt;
        &lt;li&gt;«现代操作系统»&lt;/li&gt;
        &lt;li&gt;«Java并发编程实战»&lt;/li&gt;
        &lt;li&gt;«深入理解Java虚拟机»回滚&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博客，总结：https://husteryp.github.io/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;iOS：Swift，OC&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;思想转变
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;技术方向 –&amp;gt; 生活&lt;/li&gt;
        &lt;li&gt;年轻真好~&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;外院：如何去弥补这个非班科的差距；决定方向后可以去实习&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/01/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/01/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%80%BB%E7%BB%93/</guid>
        
        <category>Hust</category>
        
        
      </item>
    
      <item>
        <title>ListView[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将从&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的基本使用入手, 介绍常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;性能优化问题&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;采用适配器模式, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的优化主要体现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;上; 本文也主要从&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;入手, 分析常见的优化问题&lt;/p&gt;

&lt;p&gt;文章代码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-最差版本&quot;&gt;一. 最差版本&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的性能问题主要是其通常用于展示大量数据造成的; 我们手指上下滑动的时候伴随着&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter.getView()&lt;/code&gt;方法的不断调用, &lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的主要作用是去解析&lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图, 但是这一过程是一个耗时操作, 如果每次滑动都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;的话, 势必会造成界面的卡顿, 如下即是这种情况: 每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 然后再&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;再进行设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 最差版本
class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view = mInflater.inflate(R.layout.item_main, parent, false)
        view.setOnClickListener{
            Toast.makeText(context,data[position],Toast.LENGTH_SHORT).show()
        }
        view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-优化一&quot;&gt;二. 优化一&lt;/h2&gt;

&lt;p&gt;为了避免每次滑动的时候都要&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;官方提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的缓存机制, 即将滑动出屏幕外面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;缓存下来, 因为通常情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;要展示的数据类型都是相同的, 所以可以复用同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;界面, 只是展示数据不同; 我们注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的参数中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;, 这个便是被缓存下来的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以我们第一次优化可以如下: 主要就是判断&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;是否为空, 如果为空, 说明没有缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 此时就需要去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 否则, 直接更改展示数据即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
            return view
        }
        convertView.apply {
            findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        }
        return convertView
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-优化二&quot;&gt;三. 优化二&lt;/h2&gt;

&lt;p&gt;到这里, 其实最耗时的部分已经被优化了, 那么我们是否还能够进行优化呢? 我们注意到每次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getView&lt;/code&gt;的时候, 虽然避免了每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 但是我们仍然每次都调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 那么这部分我们是否也可以避免掉呢, 当然是可以的, 此时我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;就派上用场啦~&lt;/p&gt;

&lt;p&gt;这里我们使用了一个内部类, 将每次&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById&lt;/code&gt;找到的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;保存下来, 因为我们前面说过了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;展示的时候, 通常数据类型都是相同的, 即界面相同, 只是每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示的数据不同而已, 因此也就没有必要每次都去执行一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;所做的主要的优化&lt;/p&gt;

&lt;p&gt;另外, 还需要提一下的是这里保存&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;, 其实我们还可以用这个&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存许多我们需要的值, 而不用局限与&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        var holder: MyViewHolder
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            holder = MyViewHolder(view)
            holder.textView.text = data[position]
            view.tag = holder
            return view
        }
        holder = convertView.tag as MyViewHolder
        holder.textView.text = data[position]
        return convertView
    }
    
    // 其他方法按照常规写, 故此省略
    ...

    class MyViewHolder(val view: View){
        val textView: TextView by lazy {
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-优化三&quot;&gt;四. 优化三&lt;/h2&gt;

&lt;p&gt;将异步操作放在子线程中执行; 其实这个也不算&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;自身特殊的优化, 而是由&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;自身特性所决定的&lt;/p&gt;

&lt;p&gt;如下; 当加载大图时, 使用异步的&lt;code class=&quot;highlighter-rouge&quot;&gt;AsyncTask&lt;/code&gt;去网络下载好后再展示到界面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(private val context: Context) : BaseAdapter() {

    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view: View = convertView ?: mInflater.inflate(R.layout.item_main, parent, false)
        val holder: ViewHolder = view.tag as ViewHolder? ?: ViewHolder(view)
        ImageLoader(holder).execute(ImageUrl.url[position])
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...

    class ImageLoader(private var holder: ViewHolder) : AsyncTask&amp;lt;String, Void, Bitmap&amp;gt;() {

        private val cache: LruCache&amp;lt;String, Bitmap&amp;gt; by lazy {
            val maxMemory = Runtime.getRuntime().maxMemory()
            val cacheSize = maxMemory / 8
            object: LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize.toInt()) {
                override fun sizeOf(key: String?, value: Bitmap?): Int {
                    return value?.allocationByteCount ?: 0
                }
            }
        }

        override fun doInBackground(vararg params: String?): Bitmap? {
            val urlStr = params[0]
            var bitmap = cache.get(urlStr)
            if (bitmap != null)
                return bitmap
            val url = URL(urlStr)
            var connection: HttpURLConnection? = null
            try {
                connection = url.openConnection() as HttpURLConnection
                connection.connectTimeout = 5000
                connection.readTimeout = 5000
                bitmap = BitmapFactory.decodeStream(connection.inputStream)
                cache.put(urlStr, bitmap)
            } catch (e: Exception) {
                Log.d(&quot;@HusterYP&quot;,&quot;error&quot;, e)
            } finally {
                connection?.disconnect()
            }
            return bitmap
        }

        override fun onPostExecute(result: Bitmap?) {
            holder.imageView.setImageBitmap(result)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码其实还有问题; 只是解决了异步加载, 但是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图的缓存复用, 当滑动的时候会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示图片不断改变的现象; 关于此问题的解决可以参见&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/45586553&quot;&gt;博客&lt;/a&gt; (&lt;strong&gt;注:&lt;/strong&gt; 上述代码图片&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;也来自该博客)&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>ListView</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;ListView笔记&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;问题: 展示大量数据, 处理内存开销和性能&lt;/p&gt;

&lt;p&gt;复用: 重新填写内容而已&lt;/p&gt;

&lt;p&gt;stable ID&lt;/p&gt;

&lt;p&gt;ListView相关内容:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView相关.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;getView():&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;错误的使用方式: 如下; 每次都会创建一个新的View视图(会去解析XML, 这是非常耗时的); 特别是当用户滑动的时候, 这种写法将产生大量的View视图&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Slow_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;正确的使用方式: 如下; 复用convertView; 但是下面这种写法也存在待优化的地方, 因为它每次都需要去findViewById(), 这点其实还可以改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Right_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最快的方式: 如下; 使用ViewHolder, 节省findViewById的时间; 还可以通过setTag()和getTag()来存储更多的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Fast_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;数据集更新的方式:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;notifyDataSetChanged()&lt;/li&gt;
    &lt;li&gt;notifiyDataSetInvalidated(): 表示数据集无效了&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;getViewType()和getViewTypeCount()&lt;/p&gt;

&lt;p&gt;可以通过设置Item的属性, enable或者disable, enable时Item可以被点击和选择, disable时不可被点击和选择; disable属性可以用于比如单纯的展示header展示等&lt;/p&gt;

&lt;p&gt;HeaderView和FooterView:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;listView.addHeaderView()&lt;/li&gt;
    &lt;li&gt;listView.addFooterView()&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;List Selector: 高亮选中Item&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;可以在xml中指定属性&lt;code class=&quot;highlighter-rouge&quot;&gt;android:drawSelectorOnTop = &quot;true&quot;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;创建一个XML的selector选择器&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;自定义ListView的背景的时候会出现问题貌似; 好像会出现在滑动的时候出现全是黑色的情况; 解决办法:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;xml中指定: &lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;#00000000&quot;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;@color/myBackgroundColor&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在ScrollView中嵌套ListView&lt;/p&gt;

&lt;p&gt;ListView中的Filter是什么?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;场景: 当我们要展示的条目很多时, 我们可以设置选项让用户选择查看哪些分类的选项, 而不是全部展示&lt;/li&gt;
    &lt;li&gt;将Adapter实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;接口即可(当Adapter继承的是BaseAdapter时, SimpleAdapter默认实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;对ListView设置Item的点击监听:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listView.setOnItemClickListener(new OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view,
        int position, long id) {
        Toast.makeText(getApplicationContext(),
            &quot;Click ListItem Number &quot; + position, Toast.LENGTH_LONG)
            .show();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取LayoutInflator可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以设置ListView没有数据时的占位View, 指定id为&lt;code class=&quot;highlighter-rouge&quot;&gt;@android:id/empty&lt;/code&gt;的View即可&lt;/p&gt;

&lt;h2 id=&quot;scrollview嵌套listview&quot;&gt;ScrollView嵌套ListView&lt;/h2&gt;

&lt;p&gt;问题: 只能显示一个Item(ListView不能全部展示)&lt;/p&gt;

&lt;h2 id=&quot;listview的item是scrollview&quot;&gt;ListView的Item是ScrollView&lt;/h2&gt;

&lt;p&gt;ListView性能优化官方文档: https://developer.android.com/training/improving-layouts/smooth-scrolling
性能优化官方推荐博客: https://android-developers.googleblog.com/2009/01/why-is-my-list-black-android.html&lt;/p&gt;

&lt;p&gt;ListView和大多数Android组件一样有透明背景, 也就意味这你可以看到Window的背景色; 但是当使用自定义ListView背景或者改变Window背景的话, 会出现问题;&lt;/p&gt;

&lt;p&gt;当ListView滑动时会依照不同的滑动方向来填充ListView; 比如从上往下填充或者从下往上填充;&lt;/p&gt;

&lt;p&gt;优化: 除了Demo中写的几个常见的优化外; ListView的性能优化其实就是使getView()方法更快而已&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;异步加载: 对于耗时资源在getView中去异步加载; 但是有一个问题是当快速滑动时, 此时需要去处理滑动时不加载的情况&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ListView  height设置wrap_content 导致getView()重复调用问题&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/08/ListView/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/08/ListView/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
      <item>
        <title>红黑树</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;红黑树&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;实现&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;红黑树是一颗平衡二叉树, 是为了避免二叉查找树在极端情况下形成单链表而表现出线性级别的时间复杂度; 红黑树的前身是&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树, 为了便于理解红黑树的各种旋转操作, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树&lt;/p&gt;

&lt;p&gt;平衡二叉树始终要保证的是所有空链接(指向一棵空树的链接)到根节点的距离相等&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-2-3查找树&quot;&gt;二. 2-3查找树&lt;/h2&gt;

&lt;h3 id=&quot;21-基本概念&quot;&gt;2.1 基本概念&lt;/h3&gt;

&lt;p&gt;为了保证树的平衡性, &lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树允许树中的一个节点保存多个键; 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/RedBlackTree/2-3树.png&quot; alt=&quot;2-3查找树&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2-结点: 含有一个键(及其对应的值)和两条链接, 左链接指向的2-3树中的键都小于该结点, 右链接指向的2-3树中的键都大于该结点
3-结点: 含有两个键(及其对应的值)和三条链接, 左链接指向的2-3树中的键都小于该结点, 右链接指向的2-3树中的键都大于该结点, 中链接指向的2-3树中的键介于该结点之间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一棵完美平衡的&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树中的所有空链接到根结点的距离都是相同的&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;22-2-3树的插入&quot;&gt;2.2 2-3树的插入&lt;/h3&gt;

&lt;h4 id=&quot;221-向2-结点中插入新键&quot;&gt;2.2.1 向2-结点中插入新键&lt;/h4&gt;

&lt;p&gt;这种情况比较简单, 直接将2-结点替换为3-结点即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/RedBlackTree/2-结点插入新键.png&quot; alt=&quot;2-结点插入新键&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>AwesomeAndroid</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录一些有趣的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;知识, 内容不限~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;子线程更新ui&quot;&gt;子线程更新UI&lt;/h2&gt;

&lt;p&gt;考虑如下代码:&lt;/p&gt;

&lt;p&gt;注: &lt;code class=&quot;highlighter-rouge&quot;&gt;MainActivity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Layout&lt;/code&gt;布局只有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;main_text&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initView()
    }

    private fun initView() {
//        Thread { main_text.text = &quot;World&quot; }.start() // 更新UI成功
        Thread {
            sleep(200)
            main_text.text = &quot;World&quot; // 更新UI失败(崩溃0)
        }.start()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如上代码中, 在第二个子线程中跟新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;的时候失败了, 报错: &lt;code class=&quot;highlighter-rouge&quot;&gt;Only the original thread that created a view hierarchy can touch its views&lt;/code&gt;; 即常见的不能在子线程中更新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;; 但是在第一个子线程中跟新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;成功了, 原因是: 线程的检查是在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;checkThread()&lt;/code&gt;中, 但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;中, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;还没有创建, 所以此时无法&lt;code class=&quot;highlighter-rouge&quot;&gt;checkThread()&lt;/code&gt;, 实际上, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;的创建是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;方法回调之后, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;WindowManagerGlobal&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;addView&lt;/code&gt;中创建的; 所以如果这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;initView&lt;/code&gt;即使是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;中调用也是同样的现象&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/24/AwesomeAndroid/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/24/AwesomeAndroid/</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>Note</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录各类笔记, 包括各类优秀文章收集, 资料收集等!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-git&quot;&gt;一. Git&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d4d5e07ea0cd&quot;&gt;超赞的Git操作讲解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二-android&quot;&gt;二. Android&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://qq634421026.github.io/2017/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/&quot;&gt;Android面试&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/18/Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/18/Note/</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>FFmpeg交叉编译与接入Android工程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要讲解如何在&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;上编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;, 以及将编译出来的动态库(&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;)接入已有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-ffmpeg交叉编译&quot;&gt;一. FFmpeg交叉编译&lt;/h2&gt;

&lt;p&gt;本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg 4.0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android-ndk-r15c&lt;/code&gt;, 注意在编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;时, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本有要求, 另外, 笔者最开始选用最新版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 总是编译不过, 去查证了一下, 发现从&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk-r16&lt;/code&gt;开始, 其用于交叉编译都有问题了, 所以选用较低版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk&lt;/code&gt;; 本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本和&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本亲测可编译通过; 先提供下载地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ffmpeg.org/releases/ffmpeg-4.0.tar.bz2&quot;&gt;FFmpeg 4.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dl.google.com/android/repository/android-ndk-r15c-linux-x86_64.zip&quot;&gt;Android-ndk-r15c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;笔者选用的编译环境是&lt;code class=&quot;highlighter-rouge&quot;&gt;ArchLinux&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;上的编译的话, 大体流程不变, 环境配置需要自己弄啦~&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下相关知识:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;JNI和NDK&lt;/li&gt;
    &lt;li&gt;CPU架构&lt;/li&gt;
    &lt;li&gt;交叉编译&lt;/li&gt;
    &lt;li&gt;FFmpeg简介&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里推荐&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/&quot;&gt;官方文档&lt;/a&gt;, 对以上方面讲解比较详细; 下面简要介绍重点地方&lt;/p&gt;

&lt;h3 id=&quot;11-基础知识&quot;&gt;1.1 基础知识&lt;/h3&gt;

&lt;h4 id=&quot;111-jni和ndk&quot;&gt;1.1.1 JNI和NDK&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Native Interface&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层通信的接口; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;可以实现和其他语言之间的互相调用(注意其他语言不仅仅只限于&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;, 虽然大多时候是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是跨平台的, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;不是跨平台的, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;也使得&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;需要考虑和特定平台相关的特性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native Development Kit&lt;/code&gt;, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;平台提供的一个工具集, 提供与本地代码之间的交互&lt;/p&gt;

&lt;p&gt;详细可参见&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/73250163&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;112-cpu架构&quot;&gt;1.1.2 CPU架构&lt;/h4&gt;

&lt;p&gt;不同的手机使用不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;有不同的指令集, 每种&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;及其指令集有其自己的应用程序二进制接口(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application Binary Interface&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;定义了机器代码与系统运行时的交互方式; &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;与指令集的对应关系如下表(摘自官方文档)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/ABI与指令集对应关系.png&quot; alt=&quot;ABI与指令集对应关系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构有&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;等(&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;也是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的), 其中, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;主要是针对&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;端, &lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;主要针对移动端; &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;系统目前支持&lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv7&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv8&lt;/code&gt;, ` x86&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;x86_64&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;MIPS&lt;code class=&quot;highlighter-rouge&quot;&gt;以及&lt;/code&gt;MIPS64&lt;code class=&quot;highlighter-rouge&quot;&gt;共七种&lt;/code&gt;CPU`架构&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中应用安装时, &lt;code class=&quot;highlighter-rouge&quot;&gt;Package Manager Service&lt;/code&gt;会去扫描&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;, 只有该设备&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构支持的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件才会被安装, 另外还可以定义&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件的对应安装优先级&lt;/p&gt;

&lt;h4 id=&quot;113-交叉编译&quot;&gt;1.1.3 交叉编译&lt;/h4&gt;

&lt;p&gt;在某个平台上编译该平台上的可执行文件叫本地编译; 如果在一个平台上编译在其他平台上的可执行程序则叫交叉编译; 交叉编译是随着嵌入式系统的发展而发展的, 因为嵌入式系统的处理能力, 内存等均有限, 所以有时候需要在其他平台上编译好后导入嵌入式系统中, 此时就需要交叉编译&lt;/p&gt;

&lt;p&gt;交叉编译最主要的是环境, 即交叉编译链; 对本文来说, 编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;需要准备&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;中提供了交叉编译链; 即&lt;code class=&quot;highlighter-rouge&quot;&gt;android-ndk-r15c/toolchains/&lt;/code&gt;下提供的各种平台相关的编译工具链&lt;/p&gt;

&lt;p&gt;本文使用的示例是在&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;下编译&lt;code class=&quot;highlighter-rouge&quot;&gt;arm-v7a&lt;/code&gt;架构的动态库&lt;/p&gt;

&lt;h4 id=&quot;114-ffmpeg&quot;&gt;1.1.4 FFmpeg&lt;/h4&gt;

&lt;p&gt;推荐&lt;a href=&quot;https://ffmpeg.org/ffmpeg-formats.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://javapyer.iteye.com/blog/1989274&quot;&gt;基本用法&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;12-ffmpeg交叉编译&quot;&gt;1.2 FFmpeg交叉编译&lt;/h3&gt;

&lt;p&gt;在开始之前需要先配置一下&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;的环境变量, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/profile&lt;/code&gt;文件中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;编译生成的动态库默认格式为&lt;code class=&quot;highlighter-rouge&quot;&gt;xx.so.版本号&lt;/code&gt;, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程中只支持以&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;结尾的动态库, 所以需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;的配置文件, 修改其生成库文件名的格式; 编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt;文件, 修改如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将configure文件中的：
SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'
SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'

#替换为：
SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'
SLIB_INSTALL_LINKS='$(SLIBNAME)'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了减小&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;大小, 我们只将需要的功能开启即可; 配置参数较多, 我们写一个脚本如下(名为&lt;code class=&quot;highlighter-rouge&quot;&gt;build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 下面的注释在运行脚本时需删除~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;NDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/yuanping/Software/NDK/android-ndk-r15c  &lt;span class=&quot;c&quot;&gt;# NDK所在路径, 注意替换为你的&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SYSROOT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/platforms/android-19/arch-arm/
&lt;span class=&quot;nv&quot;&gt;TOOLCHAIN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 &lt;span class=&quot;c&quot;&gt;# 交叉编译链, 这里使用的是arm, 如果需要编译其他平台的, 更换即可&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;build_one
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
./configure &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PREFIX&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--enable-shared &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库&lt;/span&gt;
--disable-static &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# 禁止生成静态库&lt;/span&gt;
--disable-doc &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关闭不需要的功能, 下同&lt;/span&gt;
--disable-ffplay &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--disable-ffprobe &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--disable-doc &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--disable-symver &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--disable-ffmpeg &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--enable-small &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--cross-prefix&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TOOLCHAIN&lt;/span&gt;/bin/arm-linux-androideabi- &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--target-os&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--arch&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
--enable-cross-compile &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--sysroot&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$SYSROOT&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--extra-cflags&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-Os -fpic &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
--extra-ldflags&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_LDFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ADDITIONAL_CONFIGURE_FLAG&lt;/span&gt;
make clean all
make -j3
make install
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-a &lt;span class=&quot;c&quot;&gt;# CPU架构&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/android/&lt;span class=&quot;nv&quot;&gt;$CPU&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库所在路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-marm&quot;&lt;/span&gt;
build_one
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之后运行该脚本即可, 注意添加可执行权限(&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod a+x build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;等待一会应该就好啦, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;android&lt;/code&gt;目录, 生成的动态库就在其中啦~; 笔者生成的如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/armv7-a.png&quot; alt=&quot;Armv7-a&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-动态库接入android工程&quot;&gt;二. 动态库接入Android工程&lt;/h2&gt;

&lt;p&gt;在开始接入之前, 需要先配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;的环境; 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;SDK Manager&lt;/code&gt;中下载&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LLDB&lt;/code&gt;; 这里可以不用下载&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 最好使用与编译版本一致的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 以免出现兼容性问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/SDKManager.png&quot; alt=&quot;SDKManager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;路径, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/NDKPath.png&quot; alt=&quot;NDK路径&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;项目接入&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;有两种方法, 一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;配置文件来指定; 另一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ndk-build&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Application.mk&lt;/code&gt;配置文件来指定; 官方推荐使用第一种; 关于第二种接入方式, 可以参见&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot;&gt;官方文档&lt;/a&gt;配置&lt;/p&gt;

&lt;p&gt;这里主要讲解第一种方式, 参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是创建的新项目的话, 可以直接在创建项目的时候选择&lt;code class=&quot;highlighter-rouge&quot;&gt;include C++  surpport&lt;/code&gt;, 如下图; 如果项目已经创建了, 也不要紧, 下面讲解的就是这种情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI新项目.png&quot; alt=&quot;JNI新项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们先来看一下完整的目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI目录结构.png&quot; alt=&quot;目录结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;目录下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;目录(其他目录名也可以, 但是要注意后文的更改), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;目录, 将上面编译好的&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a/lib&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg/armeabi-v7a&lt;/code&gt;下(新建&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;目录, 注意目录名一定要是&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构对应), 需要注意的是生成的动态链接库中有一些不带版本号的是指向另一个待版本号的软链接, 如下举例的两个&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;文件, 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec.so&lt;/code&gt;文件是软链接, 指向&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec-58.so&lt;/code&gt;, 所以拷贝时不需要拷贝这些软链接咯&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/动态链接库.png&quot; alt=&quot;动态链接库&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再将&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;文件夹拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;下; 创建好后目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建jni目录.png&quot; alt=&quot;创建jni目录&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt;目录下创建&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;(一定要是这个名字咯), 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建CMakeLists.png&quot; alt=&quot;创建CMakeLists&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.4.1) # cmake最低版本

add_library( # Sets the name of the library.
             wlffmpeg

             # Sets the library as a shared library.
             SHARED

             # Provides a relative path to your source file(s).
             src/main/jni/ffmpeg/player.c )

add_library( avcodec-58  # 库名字
             SHARED
             IMPORTED)
set_target_properties( avcodec-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavcodec-58.so) 

add_library( avdevice-58
             SHARED
             IMPORTED)
set_target_properties( avdevice-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavdevice-58.so)

add_library( avfilter-7
             SHARED
             IMPORTED)
set_target_properties( avfilter-7
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavfilter-7.so)

add_library( avformat-58
             SHARED
             IMPORTED)
set_target_properties( avformat-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavformat-58.so)

add_library( avutil-56
             SHARED
             IMPORTED)
set_target_properties( avutil-56
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavutil-56.so)

add_library( swresample-3
             SHARED
             IMPORTED)
set_target_properties( swresample-3
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswresample-3.so)

add_library( swscale-5
             SHARED
             IMPORTED)
set_target_properties( swscale-5
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswscale-5.so)


find_library( # Sets the name of the path variable.
              log-lib  # Android内置的log模块, 用于将JNI层的log打到AS控制台

              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )

include_directories(src/main/jni/ffmpeg/include)

target_link_libraries( # Specifies the target library.  # 链接

                       wlffmpeg  
                       avcodec-58
                       avdevice-58
                       avfilter-7
                       avformat-58
                       avutil-56
                       swresample-3
                       swscale-5

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib} )

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;配置可以参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在模块级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;下配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android {
    ...
    defaultConfig {
        ...
        externalNativeBuild {
            cmake {
                cppFlags &quot;&quot; 
            }
            ndk {
                abiFilters &quot;armeabi-v7a&quot; # 指定CPU架构
            }
        }
        sourceSets {
            main {
                jniLibs.srcDirs = ['src/main/jni/ffmpeg']  # 指定jni路径
            }
        }
    }
    externalNativeBuild {
        cmake {
            path 'CMakeLists.txt' # 指定cmake的配置文件路径
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg.java&lt;/code&gt;类, 使用静态代码块加载动态链接库, 定义&lt;code class=&quot;highlighter-rouge&quot;&gt;native&lt;/code&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;, 如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FFmpeg {
    static {
        System.loadLibrary(&quot;avutil-56&quot;);
        System.loadLibrary(&quot;swresample-3&quot;);
        System.loadLibrary(&quot;avcodec-58&quot;);
        System.loadLibrary(&quot;avformat-58&quot;);
        System.loadLibrary(&quot;swscale-5&quot;);
        System.loadLibrary(&quot;avfilter-7&quot;);
        System.loadLibrary(&quot;avdevice-58&quot;);
        System.loadLibrary(&quot;wlffmpeg&quot;); // 注意不要忘了加载这个库
    }

    public native void playMyMedia(String url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;上快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt;Alt + Enter&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;create function xxx&lt;/code&gt;, 可以自动创建对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件, 当然该&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件也可以自命名, 此处命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;的完整代码如下: 该代码摘自&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;jni.h&amp;gt;
#include &quot;libavformat/avformat.h&quot;
#include &amp;lt;android/log.h&amp;gt;
#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);  // 输出到AS的log中
#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);

JNIEXPORT void JNICALL
Java_com_gif_ping_jnidemo_FFmpeg_playMyMedia(JNIEnv *env, jobject instance, jstring url_) {
    const char *url = (*env)-&amp;gt;GetStringUTFChars(env, url_, 0);
    LOGI(&quot;url:%s&quot;, url);
    av_register_all();
    AVCodec *c_temp = av_codec_next(NULL);
    while (c_temp != NULL)
    {
        switch (c_temp-&amp;gt;type)
        {
            case AVMEDIA_TYPE_VIDEO:
                LOGI(&quot;[Video]:%s&quot;, c_temp-&amp;gt;name);
                break;
            case AVMEDIA_TYPE_AUDIO:
                LOGI(&quot;[Audio]:%s&quot;, c_temp-&amp;gt;name);
                break;
            default:
                LOGI(&quot;[Other]:%s&quot;, c_temp-&amp;gt;name);
                break;
        }
        c_temp = c_temp-&amp;gt;next;
    }
    (*env)-&amp;gt;ReleaseStringUTFChars(env, url_, url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;MainActivity&lt;/code&gt;中使用, 也比较简单; 注意添加网络权限, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;中就可以看到输出的视频信息啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {

    FFmpeg mFFmpeg;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
    }

    private void init() {
        mFFmpeg = new FFmpeg();
        mFFmpeg.playMyMedia(&quot;http://video.xxx&quot;); // 随便找一个视频url啦~
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这里, 项目应该就能跑起来啦~&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程参见&lt;a href=&quot;https://github.com/HusterYP/JNIDemo&quot;&gt;JNIDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;编译参见: https://github.com/HusterYP/FFmpeg&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-参考链接&quot;&gt;三. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@karthikcodes1999/cross-compiling-ffmpeg-4-0-for-android-b988326f16f2&quot;&gt;Cross Compiling FFmpeg 4.0 for Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yhaolpz/article/details/76408829&quot;&gt;Android 集成 FFmpeg (一) 基础知识及简单调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;Android Studio通过cmake创建FFmpeg项目&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>进程与线程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作系统之进程与线程总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-进程&quot;&gt;一. 进程&lt;/h2&gt;

&lt;p&gt;定义: 一个运行中的程序&lt;/p&gt;

&lt;p&gt;进程和程序的区别: 一个进程是某种类型的活动, 它有程序, 输入, 输出以及状态, 如果一个程序运行了两遍, 则算作两个进程&lt;/p&gt;

&lt;p&gt;进程地址空间见下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程地址空间.png&quot; alt=&quot;进程地址空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内核模式和用户模式的实现: 通常是用某个控制寄存器中的一个模式位实现的&lt;/p&gt;

&lt;p&gt;进程有三种状态: 运行态, 就绪态, 阻塞态; 其相互之间的切换见下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程状态切换.png&quot; alt=&quot;进程状态切换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;子进程的回收: 当一个进程由于某种原因终止时, 内核并不是立即把它从系统中清除, 相反, 进程被保持在已终止的状态, 知道被它的父进程回收, 一个终止但还未被回收的进程称为僵死进程, 即使僵死进程没有运行, 他们仍然消耗系统的内存资源; 如果一个父进程终止了, 内核会安排&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;进程成为它的孤儿进程的养父&lt;/p&gt;

&lt;h3 id=&quot;11-进程创建fork&quot;&gt;1.1 进程创建–fork()&lt;/h3&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;可以创建进程, 新创建的子进程与父进程几乎但不是完全相同的, 子进程得到与父进程用户级虚拟地址空间相同(但是独立)的副本, 包括代码和数据段, 堆, 共享库以及用户栈, 子进程还获得与父进程任何打开文件描述符相同的副本, 这就意味着当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, 子进程可以读写父进程中打开的任何文件; 其最大的区别就是具有不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;UID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通常子进程会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execve&lt;/code&gt;或一个相同的系统调用以修改其内存映像并运行一个新的程序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;函数调用一次但是返回两次, 一次是在父进程中, 另一次是在新创建的子进程中, 参见一下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main() 
{
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0) // 子进程
    {
        printf(&quot;Child: x = %d\n&quot;, ++x); 
        exit(0);
    }
    printf(&quot;Parent: x = %d\n&quot;, --x); // 父进程
    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;输出(注意由于并发不定性, 所以输出顺序不定):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent: x = 0
Child: x = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意理解上述程序:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;调用一次, 返回两次&lt;/li&gt;
    &lt;li&gt;并发执行&lt;/li&gt;
    &lt;li&gt;相同但是独立的地址空间: 写时复制; 子进程共享父进程的所有内存, 但这块内存通过写时复制共享, 这意味着一旦两者之一想要修改部分内存, 则这块内存首先被明确的复制, 以确保修改发生在私有内存区域&lt;/li&gt;
    &lt;li&gt;共享文件: 当运行这个程序时, 我们注意到父进程和子进程都把他们的输出显示到屏幕上, 原因是子进程继承了父进程所有的打开文件, 当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;文件是打开的, 并指向屏幕, 子进程继承了这个文件, 因此它的输出也是指向屏幕的(&lt;strong&gt;注意理解此处&lt;/strong&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-进程间通信&quot;&gt;1.2 进程间通信&lt;/h3&gt;

&lt;h4 id=&quot;121-如何保证临界区互斥&quot;&gt;1.2.1 如何保证临界区互斥&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;屏蔽中断: 在单处理器系统中, 最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断, 并在要离开之前再打开中断&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;严格的轮换法: 自旋锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Peterson&lt;/code&gt;解法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令: 测试并加锁; 读字和写字操作保证是不可分割的, 即该指令结束之前其他处理器均不允许访问该内存字; 执行&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;锁住内存总线, 以禁止其他&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;在本指令结束之前访问内存(原子操作的更底层解释)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;122-生产者消费者问题&quot;&gt;1.2.2 生产者消费者问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;信号量: 用一个整型变量来累计唤醒次数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define N 100 // 缓冲区的槽数目
typedef int semaphore; // 信号量是一种特殊类型的整型数据
semaphore mutex = 1; // 控制对临界区的访问
semaphore empty = N; // 计数缓冲区的空槽数目
semaphore full = 0; // 计数缓冲区的满槽数目

void producer(void)
{   
    int item;

    while(true)
    {   
        item = produce_item();
        down(&amp;amp;empty); // 将空槽数目减一; 注意理解, 若交换这里两个down操作的顺序, 可能会造成死锁
        down(&amp;amp;mutex); // 进入临界区
        insert_item(item);
        up(&amp;amp;mutex); // 离开临界区
        up(&amp;amp;full); // 将满槽数目加一
    }
}

void consumer(void)
{
    int item;

    while(true)
    {
        down(&amp;amp;full);
        down(&amp;amp;mutex);
        item = remove_item();
        up(&amp;amp;mutex);
        up(&amp;amp;empty);
        comsume_item(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;互斥量: 没有计数能力, 可以处于两态之一: 解锁和加锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管程: 一个管程是一个由过程, 变量以及数据等组成的一个集合, 它们组成一个特殊的模块或软件包, 进程可以在任何需要的时候调用管程中的过程, 但是不能在管程之外声明的过程中直接访问管程内的数据结构&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/管程.png&quot; alt=&quot;管程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入管程的互斥由编译器负责, 但通常的做法是用一个互斥量或二元信号量&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;避免锁: 读-复制-更新&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-调度&quot;&gt;1.3 调度&lt;/h3&gt;

&lt;p&gt;进程切换做的工作: 首先用户态切换到内核态, 然后保存当前进程的状态, 包括在进程表中存储器值; 在许多系统中, 内存映像(如: 页表内内存访问位)也必须保存, 接着, 通过运行调度程序选择一个新进程, 之后, 将该新进程的内存映像装进&lt;code class=&quot;highlighter-rouge&quot;&gt;MMU&lt;/code&gt;, 最后新进程开始运行; 除此之外, 进程切换还要使整个内存高速缓存失效, 强迫缓存从内存中动态重新装入两次(进入内核一次, 离开内核一次)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/上下文切换.png&quot; alt=&quot;上下文切换&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;131-调度时机&quot;&gt;1.3.1 调度时机&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么时候调度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新进程之后, 决定是运行子进程还是父进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个进程退出时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个进程阻塞在&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;和信号量上或由于其他原因阻塞时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;中断时&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;132-调度策略&quot;&gt;1.3.2 调度策略&lt;/h4&gt;

&lt;p&gt;有三种环境:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;批处理&lt;/li&gt;
    &lt;li&gt;交互式&lt;/li&gt;
    &lt;li&gt;实时&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;批处理&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;先来先服务&lt;/li&gt;
    &lt;li&gt;最短作业优先&lt;/li&gt;
    &lt;li&gt;最短剩余时间优先&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;交互式&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;轮转调度: 时间分片; 维护一个进程队列, 用完时间片后, 排到队列末尾&lt;/li&gt;
    &lt;li&gt;优先级调度&lt;/li&gt;
    &lt;li&gt;多级队列&lt;/li&gt;
    &lt;li&gt;最短进程优先&lt;/li&gt;
    &lt;li&gt;保证调度&lt;/li&gt;
    &lt;li&gt;彩票调度&lt;/li&gt;
    &lt;li&gt;公平分享调度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;133-读者-写者问题&quot;&gt;1.3.3 读者-写者问题&lt;/h4&gt;

&lt;p&gt;实现目标是: 可以多个读者&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以数据库为例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int semaphore;
semaphore mutex = 1; 
semaphore db = 1; // 控制对数据库的访问
int rc = 0; // 正在读或者即将读的进程数目

void reader(void)
{
    while(true)
    {
        down(&amp;amp;mutex); // 获得对rc的互斥访问权
        rc = rc + 1; // 多了一个读者
        if (rc == 1) // 如果是第一个读者
            down(&amp;amp;db);
        up(&amp;amp;mutex);
        read_data_base(); // 访问数据
        down(&amp;amp;mutex);
        rc = rc - 1; // 减少了一个读者
        if (rc == 0) // 如果是最后一个读者
            up(&amp;amp;db); 
        up(&amp;amp;mutex);
        use_data_read(); // 非临界区
    }
}

void writer(void) 
{   
    while(true)
    {
        think_up_data(); // 非临界区
        down(&amp;amp;db); // 获取互斥访问
        write_data_basae(); // 更新数据
        up(&amp;amp;db); // 释放互斥访问
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-线程&quot;&gt;二. 线程&lt;/h2&gt;

&lt;p&gt;为什么要使用线程:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;并行实体拥有共享同一个地址空间和所有可用数据的能力, 这是多进程无法表达的&lt;/li&gt;
    &lt;li&gt;线程比进程更轻量级, 它们比进程更容易创建, 也更容易撤销&lt;/li&gt;
    &lt;li&gt;若多个线程都是&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;密集型的, 那么并不能获得性能上的增强(考虑调度消耗时间), 但是如果存在大量的计算和大量的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;处理, 拥有多个线程允许这些活动彼此重叠进行, 从而会加快应用程序执行的速度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在线程中有一个程序计数器, 用来记录接着要执行哪一条指令, 线程拥有寄存器, 用来保存线程当前的工作变量, 线程还拥有一个堆栈, 其中每一帧保存了一个已调用的但是还没有从中返回的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/线程与进程.png&quot; alt=&quot;线程与进程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程用于把资源集中到一起, 而线程则是在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;上被调度执行的实体(资源管理的单位是进程)&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java并发[三]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解锁等高级主题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-死锁及其避免&quot;&gt;一. 死锁及其避免&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;死锁出现的原因通常是出现锁环路造成的, 不管是显示的还是隐式的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过定义获取锁的顺序来避免死锁: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;System.identityHashCode(object)&lt;/code&gt;来返回一个锁对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.hashCode()&lt;/code&gt;的返回值; 通过这个值来定义锁的顺序, 并在整个应用程序中都按照这个顺序来获取锁, 那么就不会形成锁环路了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Object fromAcct = new Object(); // 这里的锁对象也可以是其他
        Object toAcct = new Object();
        Object tieLock = new Object();
        int fromHash = System.identityHashCode(fromAcct);
        int toHash = System.identityHashCode(toAcct);
        if (fromHash &amp;lt; toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    // doSomething
                }
            }
        } else if (fromHash &amp;gt; toHash) {
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    // doSomething
                }
            }
        } else { // 这种情况主要是避免Hash冲突, 此时需要额外的锁
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        // doSomething
                    }
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用开放调用(如果在调用某个方法时, 不需要持有锁, 那么这种调用就被成为开放调用)避免死锁: 这种情况下适用于持有不同锁的方法之间的相互调用(注意锁的级别是在方法上, 而不是代码块上)(相当于形成一个隐式的环); 将锁从方法上转移到需要同步的内部代码块上可以避免死锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock.tryLock()&lt;/code&gt;: 可以检测死锁和从死锁中恢复过来; 即指定一个超时时限, 在等待超过该时间后&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock()&lt;/code&gt;会返回一个失败信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的几点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;对象分配操作的开销比同步的开销更低(实际上, 现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;的分配操作已经比&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;调用更快&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的以前实现中(现在实现不同咯)采用分段锁, 使用了一个包含&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个锁的数组, 每个锁保护散列桶的&lt;code class=&quot;highlighter-rouge&quot;&gt;1/16&lt;/code&gt;, 这样就能够支持多达&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个并发的写入器; &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;将对每个分段进行枚举并将每个分段中的元素数量相加, 而不是维护一个全局计数, 为了避免枚举每个计数, &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;为每个分段都维护了一个独立的计数, 并通过每个分段的锁来维护这个值(这个地方有两点需要注意: 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算是在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作都会改变一次, 这样虽然增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;的操作, 但是这会使得&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算从&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;; 另一个是为每个分段维护一个&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 而不是使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 如果使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的话, ,实际上就破坏了分段锁的分段特性, 因为访问共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的时候, 需要同步)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 09 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
