<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 27 Sep 2018 19:42:32 +0800</pubDate>
    <lastBuildDate>Thu, 27 Sep 2018 19:42:32 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Java内存区域与内存溢出异常</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第二章以及其他博客的阅读总结&lt;/p&gt;

&lt;p&gt;重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同时还需要明确的一点是各部分会产生的异常, 以及产生异常的原因&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自网络, 但是忘了出处, 侵删~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;p&gt;在开始讲解之前, 需要先明确关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;的一些基本概念&lt;/p&gt;

&lt;p&gt;我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是一个跨平台的语言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;跨平台的基本支撑其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;对操作系统底层细节的屏蔽, 相当于加了一个中间层(计算机中的任何问题都可以加一个中间层解决~), &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;不再像&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;等语言一样直接翻译为针对特殊平台的机器码, 而是翻译为字节码, 也即是我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 下图大概可以比较简明的概括了~; 字节码就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;世界中的汇编, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;则不是跨平台的, 只是不同平台的&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;都能识别和运行标准格式的字节码文件而已&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/Java编译.png&quot; alt=&quot;Java编译&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 我觉得下图已经可以比较准确的表达了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面要讲的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-运行时数据区&quot;&gt;二. 运行时数据区&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序的时候把它所管理的内存划分为若干个不同的数据区, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM内存区域.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-程序计数器&quot;&gt;2.1 程序计数器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;211-存储数据类型&quot;&gt;2.1.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;指向下一条需要执行的字节码指令; 如果线程正在执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法, 该计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法, 该计数器值则为空(&lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;212-异常情况&quot;&gt;2.1.2 异常情况&lt;/h4&gt;

&lt;p&gt;该区域是是唯一一个在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有规定任何&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;情况的区域&lt;/p&gt;

&lt;h3 id=&quot;22-java虚拟机栈&quot;&gt;2.2 Java虚拟机栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;221-存储数据类型&quot;&gt;2.2.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;描述&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法执行的内存模型, 每个方法调用就对应着一个栈帧的入栈和出栈; 一个栈帧里面存储了局部变量表, 操作数栈, 动态链接, 方法出口等信息&lt;/p&gt;

&lt;p&gt;局部变量表存储了编译器可知的各种基本数据类型, 对象引用, &lt;code class=&quot;highlighter-rouge&quot;&gt;returnAddress&lt;/code&gt;; 局部变量表的大小在编译期间即可确定, 运行期间大小不变&lt;/p&gt;

&lt;h4 id=&quot;222-异常情况&quot;&gt;2.2.2 异常情况&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;StackOverflowError&lt;/strong&gt;: 线程请求栈深度大于虚拟机允许深度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF sof = new JavaVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;Stack Length: &quot; + sof.stackLength);
            throw e;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;: 虚拟机栈动态扩展时无法申请到足够内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop();
                }
            }).start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 由于操作系统分配给每个进程的内存空间是有限制的, 所以如果是由于建立过多的线程导致内存溢出, 在不能减少线程数或者更换&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位虚拟机的情况下, 可以选择通过减少最大堆和减少栈容量来换取更多的线程&lt;/p&gt;

&lt;h3 id=&quot;23-本地方法栈&quot;&gt;2.3 本地方法栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-存储数据类型&quot;&gt;2.3.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;和虚拟机栈类似, 只是本地方法栈提供的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法服务&lt;/p&gt;

&lt;h4 id=&quot;232-异常情况&quot;&gt;2.3.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StackOverflowError&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-java堆&quot;&gt;2.4 Java堆&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;垃圾收集管理的主要区域&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;241-存储数据类型&quot;&gt;2.4.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;几乎所有的对象实例都在这里分配&lt;/p&gt;

&lt;h4 id=&quot;242-异常情况&quot;&gt;2.4.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMHeapOOM {

    static class HeapOOM {
    }

    public static void main(String[] args) {
        List&amp;lt;HeapOOM&amp;gt; list = new ArrayList();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-方法区&quot;&gt;2.5 方法区&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;该区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;251-存储数据类型&quot;&gt;2.5.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;存储已被虚拟机加载的类信息, 常量, 静态变量, 即使编译器编译后的代码等数据&lt;/p&gt;

&lt;h4 id=&quot;252-运行时常量池&quot;&gt;2.5.2 运行时常量池&lt;/h4&gt;

&lt;p&gt;运行时常量池是方法区的一部分, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK6&lt;/code&gt;之后, 常量池被放入了堆中;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中也有常量池部分, 即编译期生成的各种字面量和符号引用, 这部分将在类加载后进入方法区的运行时常量池中, 此外还会把翻译出来的直接引用也存储在运行时常量池中&lt;/p&gt;

&lt;p&gt;运行时常量池相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件常量池的另外一个最重要的特征是具备动态性, 即运行期间也可以将新的常量放入池中, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;intern()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String.intern()&lt;/code&gt;作用是: 如果字符串常量池中已经包含一个等于此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的字符串, 则返回代表池中这个字符串的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象; 否则, 将此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象包含的字符串添加到常量池中, 并且返回此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的引用&lt;/p&gt;

&lt;p&gt;同样, 收方法区的限制, 当常量池无法再申请到内存时会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;253-异常情况&quot;&gt;2.5.3 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;: 方法区无法满足内存分配需求&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;26-直接内存&quot;&gt;2.6 直接内存&lt;/h3&gt;

&lt;p&gt;直接内存不是虚拟机运行时数据区的一部分, 但是也被频繁使用, 如: 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.4&lt;/code&gt;中新加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;类, 引入了一种基于通道(&lt;code class=&quot;highlighter-rouge&quot;&gt;Chanel&lt;/code&gt;)和缓冲区(&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;方式, 它可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;函数库直接分配堆外内存, 然后通过一个存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirectByteBuffer&lt;/code&gt;对象作为这块内存的引用进行操作, 避免了在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;堆中来回复制数据, 提高性能&lt;/p&gt;

&lt;p&gt;同样会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-常见问题&quot;&gt;三. 常见问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 下文摘自文末参考链接, 权作个人笔记~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序运行永远都是在栈中进行的，因而参数传递时, 只存在传递基本类型和对象引用的问题, 不会直接传对象本身;  但是传引用的错觉是如何造成的呢? 在运行栈中, 基本类型和引用的处理是一样的, 都是传值, 所以, 如果是传引用的方法调用, 也同时可以理解为“传引用值”的传值调用, 即引用的处理跟基本类型是完全一样的; 但是当进入被调用方法时, 被传递的这个引用的值, 被程序解释(或者查找)到堆中的对象, 这个时候才对应到真正的对象; 如果此时进行修改; 修改的是引用对应的对象; 而不是引用本身; 即: 修改的是堆中的数据; 所以这个修改是可以保持的了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我产生的对象不多呀, 为什么还会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答: 你继承层次忒多了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;中产生的对象是先产生父类, 然后才产生子类, 明白不?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;错误分几种?
答: 分两种, 分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError:java heap size&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError: PermGen space&lt;/code&gt;, 两种都是内存溢出, &lt;code class=&quot;highlighter-rouge&quot;&gt;heap size&lt;/code&gt;是说申请不到新的内存了, 这个很常见，检查应用或调整堆内存大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;PermGenspace&lt;/code&gt;是因为永久存储区满了, 这个也很常见, 一般在热发布的环境中出现, 是因为每次发布应用系统都不重启, 久而久之永久存储区中的死对象太多导致新对象无法申请内存, 一般重新启动一下即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么不建议在程序中显式的生命&lt;code class=&quot;highlighter-rouge&quot;&gt;System.gc()&lt;/code&gt;?
答: 因为显式声明是做堆内存全扫描, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;, 是需要停止所有的活动的(&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop The World Collection&lt;/code&gt;), 你的应用能承受这个吗?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.importnew.com/1993.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.cnblogs.com/dolphin0520/p/3783345.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/2905-JVM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java之IO流</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中一个比较重要的模块–&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;流&lt;/p&gt;

&lt;p&gt;以下内容是对&lt;strong&gt;Java核心技术卷II&lt;/strong&gt;的总结, 权做个人笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java I/O&lt;/code&gt;流指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.io&lt;/code&gt;包和&lt;code class=&quot;highlighter-rouge&quot;&gt;java.nio&lt;/code&gt;包提供的各种操作文件和输入输出等的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 具体可以分为两大类: 一类是面向字节的, 一类是面向字符的; 面向字节的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;是以&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStream&lt;/code&gt;类为基类, 每次以一个字节为单位进行读写操作; 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt;为基类, 每次以两个字节为单位进行读写操作, 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;主要是针对文本操作设计的&lt;/p&gt;

&lt;p&gt;可以参见下图:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字节&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字节.png&quot; alt=&quot;面向字节&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字符&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字符.png&quot; alt=&quot;面向字符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: &lt;a href=&quot;https://blog.csdn.net/zhoupenglei/article/details/46312405&quot;&gt;图片来源&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-重要概念&quot;&gt;二. 重要概念&lt;/h2&gt;

&lt;h3 id=&quot;21-流嵌套&quot;&gt;2.1 流嵌套&lt;/h3&gt;

&lt;p&gt;即将不同功能的流嵌套起来, 过滤; 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中流默认是不被缓冲区缓存的, 也就是说每个&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;的调用都会请求操作系统再分发一个字节, 相比之下, 请求一个数据块并将其置于缓冲区中会显得更加高效, 如果我们想使用缓冲机制, 以及用于文件输入方法, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;            BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;file&quot;));&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-glob模式匹配&quot;&gt;2.2 Glob模式匹配&lt;/h3&gt;

&lt;p&gt;即使用正则筛选文件, 如筛选文件后缀名为&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;的文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;), &quot;*.java&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Glob&lt;/code&gt;模式见下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模式&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;匹配路径组成部分中0个或多个字符&lt;/td&gt;
      &lt;td&gt;*.java匹配当前目录中的所有Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;**&lt;/td&gt;
      &lt;td&gt;匹配跨目录边界的0个或多个字符&lt;/td&gt;
      &lt;td&gt;**.java匹配在所有子目录中的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;匹配一个字符&lt;/td&gt;
      &lt;td&gt;????.java匹配所有四个字符的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[…]&lt;/td&gt;
      &lt;td&gt;匹配一个字符集合&lt;/td&gt;
      &lt;td&gt;Test[0-9A-F].java匹配Testx.java, 其中x是一个十六进制数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;{…}&lt;/td&gt;
      &lt;td&gt;匹配由逗号隔开的多个可选项之一&lt;/td&gt;
      &lt;td&gt;*.{java, class}匹配所有的Java文件和类class文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;转移上述任意模式中的字符&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;*&lt;/em&gt;匹配所有文件名中包含*的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;23-常用工具类&quot;&gt;2.3 常用工具类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Files&lt;/strong&gt;: 使得读写文件和操作文件及文件夹变得简单; 旧的&lt;code class=&quot;highlighter-rouge&quot;&gt;File&lt;/code&gt;类中有一个方法可以用来获取一个目录下的所有文件构成的数组, 但是当目录中包含大量文件时, 这个方法的性能非常低, &lt;code class=&quot;highlighter-rouge&quot;&gt;Files&lt;/code&gt;类设计了一个方法可以产生&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;对象, 如下示例代码:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;));
Iterator&amp;lt;Path&amp;gt; iterator = entries.iterator();
for (Path path : entries) {
    System.out.println(path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Paths&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths&lt;/code&gt;可以用来构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Path&lt;/code&gt;对象: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths.get(args)&lt;/code&gt;, 可以接收一个或多个字符串, 并将它们用默认文件系统分隔符连接起来&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-内存映射文件&quot;&gt;2.4 内存映射文件&lt;/h3&gt;

&lt;p&gt;大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分”映射”到内存中, 然后这个文件就可以当做是内存数组一样的访问, 中比传统的文件操作要快得多; 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;25-易忘类&quot;&gt;2.5 易忘类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStreamReader&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStreamWriter&lt;/code&gt;: 可以指定编码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintWriter&lt;/code&gt;: 以文本格式写出数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccessFile&lt;/code&gt;: 在任何位置查找或写入数据; 可以用于实现断点续传&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DataInputStream&lt;/code&gt;: 读取数字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectOutputStream&lt;/code&gt;: 读取对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;26-文件操作处理效率&quot;&gt;2.6 文件操作处理效率&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;普通输入流&lt;/td&gt;
      &lt;td&gt;110s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;带缓冲的输入流&lt;/td&gt;
      &lt;td&gt;9.9s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;随机方访问文件&lt;/td&gt;
      &lt;td&gt;162s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存映射文件&lt;/td&gt;
      &lt;td&gt;7.2s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View绘制流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之绘制流程&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的绘制流程分为三大步: &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;即测量, 测量&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;即布局, 按照一定的规则排布&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;即绘制, 绘制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的外形; 这三步是和我们自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;息息相关的, 熟悉和掌握这三大流程, 我们才能随心所欲的定制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; 本文也将从这三个方面入手, 结合源码讲解&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制的整体流程, 如下图;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View绘制流程.png&quot; alt=&quot;View绘制流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 图片来自: https://www.jianshu.com/p/dc0b039e7c4f&lt;/p&gt;

&lt;p&gt;可以看出, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;三大流程直接相关的是从&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的; 大致流程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performTraversals() {
    ...
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
    performLayout(lp, mWidth, mHeight);
    ...
    performDraw();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-measure过程&quot;&gt;二. measure过程&lt;/h2&gt;

&lt;p&gt;在开始讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之前, 我们需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程的理解还是很重要的&lt;/p&gt;

&lt;h3 id=&quot;21-measurespec&quot;&gt;2.1 MeasureSpec&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的值, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;的位组合; 高&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;, 低&lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 这样设计其实是为了节约空间; 关于二者如何组合, 可以参见以下代码; 可以看出, 其实就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MODE_MASK&lt;/code&gt;掩码以及位操作实现将两个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型整合为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;; 当然, 要分别提取这两个值的话, 也可以很简单的用位操作实现, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &amp;lt;&amp;lt; MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size &amp;amp; ~MODE_MASK) | (mode &amp;amp; MODE_MASK); // MODE_MASK  = 0x3 &amp;lt;&amp;lt; 30; 
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;即测量模式, 一共有三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;: 父容器不对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;有任何限制, 要多大给多大, 这种情况一般用于系统内部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;: 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和具体数值这两种模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;: 父容器指定了一个可用大小即&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小不能大于该值, 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;的类型区别可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的确定受&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;的影响, 但是也要分情况: 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;RootView&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;来说, 由于其没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由窗口尺寸和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定; 对于普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;来说, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由父容器传递的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定&lt;/p&gt;

&lt;p&gt;普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;创建规则见下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;childLayoutParams&lt;/strong&gt; \ &lt;strong&gt;parentSpecMode&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;dp/px&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;match_parent&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;wrap_content&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自«Android开发艺术探索»&lt;/p&gt;

&lt;p&gt;上面表格中展现的规则需要好好理解:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸是明确的值时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_height&lt;/code&gt;有确定的值, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;是什么, &lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;都保持规定尺寸不变; 这点比较好理解, 因为明确指定&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸之后, 我们肯定希望显示的也是指定尺寸&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;时, 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是确定尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸也能确定, 也就是父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, parentSize&lt;/code&gt;也可以理解; 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸不确定, 此时父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;只知道一个最大尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;, 也只能知道一个最大尺寸, 而且该最大尺寸不应该超过&lt;code class=&quot;highlighter-rouge&quot;&gt;parentSize&lt;/code&gt;, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;, 即尺寸大小不确定的话, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是具有确定尺寸还是尺寸不确定, 反正&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸始终是不确定的, 所以此时应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;, 而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸也不应该超过父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 故综上为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-decorview的measure过程&quot;&gt;2.2 DecorView的measure过程&lt;/h3&gt;

&lt;p&gt;我们知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;是整个&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;树的&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;, 我们首先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的测量过程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getRootMeasureSpec()&lt;/code&gt;来获取&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 如下; 结合上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则可以理解&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;MATCH_PARENT&lt;/code&gt;, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以其尺寸就为窗口尺寸, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;WRAP_CONTENT&lt;/code&gt;, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;尺寸不确定, 最大尺寸不应该超过窗口尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, windowSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;明确规定了自己的尺寸, 那么就不受窗口尺寸的影响, 为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, rootDimension&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建好&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;之后, 就直接传入了&lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;中, &lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;的代码如下; 可以看出, 接下来就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;进行测量, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的, 不可重写, 所以应该追溯到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;(继承链为: &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeausre()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;不是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的,
所以我们应该去分析的是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        if (mView == null) {
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的在&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;中将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;进行处理和判断之后, 调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;super.onMeasure()&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;; 如下, 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;方法中处理了&lt;code class=&quot;highlighter-rouge&quot;&gt;Margin&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;)和&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;getPaddingXXX&lt;/code&gt;), 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;中会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;child.measure()&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递(即递归测量), 这样就将测量工作传递到了子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DecorView.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    ...
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    ...
}

// FrameLayout.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int count = getChildCount();
        for (int i = 0; i &amp;lt; count; i++) {
            final View child = getChildAt(i);
            if (mMeasureAllChildren || child.getVisibility() != GONE) {
                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                maxWidth = Math.max(maxWidth,
                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                maxHeight = Math.max(maxHeight,
                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                childState = combineMeasuredStates(childState, child.getMeasuredState());
                if (measureMatchParentChildren) {
                    if (lp.width == LayoutParams.MATCH_PARENT ||
                            lp.height == LayoutParams.MATCH_PARENT) {
                        mMatchParentChildren.add(child);
                    }
                }
            }
        }

        // Account for padding too
        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
        ...
}

// FrameLayout.measureChildWithMargins()
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
            ....
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程分为&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量过程&lt;/p&gt;

&lt;h3 id=&quot;23-viewgroup的measure过程&quot;&gt;2.3 ViewGroup的measure过程&lt;/h3&gt;

&lt;p&gt;我们来看子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时的测量过程; 其实对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;有不同的布局规则, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearLayout&lt;/code&gt;, 有竖直布局和水平布局两种, 而这两种不同的布局测量方式也不同; 所以我们这里只是简单的看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;对子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的通用测量方式&lt;/p&gt;

&lt;p&gt;代码如下; 测量逻辑比较简单, 也是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递, 实现递归测量, 不做细讲啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i &amp;lt; size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
}


protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();
            
        // 获取child的MeasureSpec, 同时考虑Padding
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 递归调用, 又回到了这里
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的一点是子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getChildMeasureSpec()&lt;/code&gt;为例, 如下; 其构造规则除了考虑了&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;以外, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构造规则表是相同的, 可以结合代码注释再次理解该表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        case MeasureSpec.EXACTLY: // 如果父View尺寸确定
            if (childDimension &amp;gt;= 0) { // childDimension &amp;gt;= 0, 表示的是子View的layout_xxx设置了具体的数值, 因为wrap_content = -2
                                       // match_parent = -1
                resultSize = childDimension; // 那么集合MeasureSpec的构造规则及对应解释, 这里应该为childDimension, EXACTLY
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 同时父View尺寸也确定
                resultSize = size;  // 说明子View尺寸确定, 且为父View尺寸
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸确定
                resultSize = size;  // 说明子View尺寸不确定, 最大不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.AT_MOST: // 如果父View尺寸不确定
            if (childDimension &amp;gt;= 0) {
                resultSize = childDimension; // 如果子View的layout_xxx设置了明确的值
                resultMode = MeasureSpec.EXACTLY; // 那么子View有确定尺寸, 即为设置的值
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 但是父View的尺寸不定
                resultSize = size; // 那么子View的尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸不定
                resultSize = size; // 那么子View尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.UNSPECIFIED:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-view的measure过程&quot;&gt;2.4 View的measure过程&lt;/h3&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;啦~, 只是一个单纯的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;控件而已; 其默认测量规则如下; 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getSuggestedMinimumWidth()&lt;/code&gt;为例, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;android:minWidth&lt;/code&gt;属性, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 如果设置了背景, 则返回背景宽度和指定&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;中的最大值; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;则是返回默认尺寸, 我们只需关心&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;两种情况即可(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;UNSPECIFIED&lt;/code&gt;一般用于系统, 不常用), 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对于这两种情况默认都是返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即传入的尺寸,
我们上面说了&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;模式, &lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和指定数值情况, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;将这两种情况都默认返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;可用空间, 很明显, 这对于&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;是不支持的(因为此时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;), 所以在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 需要自己根据逻辑实现&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的情况, 具体实现可以参见&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ImageView&lt;/code&gt;等对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// 这里以Width为例
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}

public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, 最终我们确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的尺寸之后, 还需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;正真设置和作用到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;上; 需要注意的是, 此时只是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高, 可能不是实际宽高, 实际宽高在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中才能确定, 出现测量宽高和实际宽高不相等的原因 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中改变了&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;实际布局的位置尺寸等造成的, 但是一般情况下二者都是相等的&lt;/p&gt;

&lt;h3 id=&quot;25-自定义view时measure过程注意事项&quot;&gt;2.5 自定义View时measure过程注意事项&lt;/h3&gt;

&lt;p&gt;到这里, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制过程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程就已经讲解完了; 但是笔者还想提一下在实际使用, 即自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 还需要注意哪些方面; 这里需要提前声明的是, 下面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包含&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;, 只是单纯的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;需要自己实现对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要自己处理&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;的情况, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;还需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记住使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;使测量尺寸生效, 否则会抛异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-layout过程&quot;&gt;三. layout过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程会确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;最终的位置和尺寸, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程才是真正实现不同布局的关键; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的传递是从&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;开始往下传递&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;中则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());&lt;/code&gt;, 前面我们已经说过了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;,
但是这里我们并不去分析&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 因为这是针对某一具体布局而言的; 我们这里选择具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法如下; 可以看出其调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;中, 可以看出调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 同时还需要注意一点就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法是由&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的, 这也就意味着自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的时候, 不能重写&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;是一个抽象方法, 也就是说我们必须自己去是实现; 其实这也很好理解, 因为对于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 我们需要实现自己的布局,
这里实现逻辑其实就是写在&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;中即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewGroup.layout()
public final void layout(int l, int t, int r, int b) {
    ...
    super.layout(l, t, r, b);
    ...
}

// View.layout()
public void layout(int l, int t, int r, int b) {
    ...
    boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    ...
    onLayout(changed, l, t, r, b);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 还需要注意一点的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法中还调用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setFrame()&lt;/code&gt;, 该方法的作用其实是设置&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mRight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mTop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mBottom&lt;/code&gt;的值; 这里反应的其实是上文说过的一句话, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程中确定测量宽高, 实际宽高需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中确定; 这里就是记录&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的实际宽高; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredHeight()&lt;/code&gt;来获取, 这在&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之后即可得到; 实际宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getHeight()&lt;/code&gt;来得到,
这在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程之后可以获取; 至于二者的区别, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;为例, 如下; 可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;获取的其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;获取的则是实际宽高(因为是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的右边界减去左边界); 上面已经说过了测量宽高和实际宽高的区别, 这里就不再赘述啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final int getMeasuredWidth() {
    return mMeasuredWidth &amp;amp; MEASURED_SIZE_MASK;
}

public final int getWidth() {
    return mRight - mLeft;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程比较简单, 也是一个递归调用的过程, 至于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时主要是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的设计, 需要考虑的还是要&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的影响啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-draw过程&quot;&gt;四. draw过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;过程其实就是其&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 最终会调用到&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;(实际上调用栈是: &lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;performDraw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;drawSoftware()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时官方并不建议去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 而是建议重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;去实现自己的逻辑, &lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中实际上是一个空实现; 我们这里先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;的实现逻辑&lt;/p&gt;

&lt;p&gt;官方文档注释中已经说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;过程的实现逻辑, 如下; 可以看出, 主要绘制逻辑为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绘制背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制内容(即自己)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制装饰, 如滚动条等前景&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;步和第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;步一般会跳过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// View.draw()
public void draw(Canvas canvas) {
        ...
        /*
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
        ...
         // Step 1, draw the background, if needed
         if (!dirtyOpaque) {
             drawBackground(canvas);
         }
         // skip step 2 &amp;amp; 5 if possible (common case)
         // Step 3, draw the content
         if (!dirtyOpaque) 
            onDraw(canvas);
         // Step 4, draw the children
         dispatchDraw(canvas);
         // Step 6, draw decorations (foreground, scrollbars)
         onDrawForeground(canvas);
         ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道, 绘制内容这一步是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;, 即我们自己自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时需要实现的内容; 另外, 这里需要注意的一点是绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchDraw()&lt;/code&gt;去传递绘制绘制过程, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 一般用于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;中其实现如下; 其实就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后依次调用子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法绘制出子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void dispatchDraw(Canvas canvas) {
    ...
    for (int i = 0; i &amp;lt; childrenCount; i++) {
        ...
        more |= drawChild(canvas, transientChild, drawingTime); // 在drawChild()中调用child.draw(canvas, this, drawingTime)将绘制过程传递
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的整个绘制流程就讲解完成啦~, 当然这对于我们随心所欲的实现炫酷的自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;还是第一步理论基础, 真正要做到还是需要靠自己多动手去画咯~&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View事件分发机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之事件分发机制&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的触摸事件分发是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列中的一个重难点, 主要需要掌握的是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的传递规则和处理规则, 这是自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中冲突处理的理论来源~&lt;/p&gt;

&lt;p&gt;触摸事件分发的处理主要是对&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;封装了用户的一系列行为, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指刚触摸屏幕), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指在屏幕上滑动), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;(手指抬起)等; 以及事件发生的坐标(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getX()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getY()&lt;/code&gt;可以得到)等&lt;/p&gt;

&lt;p&gt;在开始讲解之前需要明确的一些概念是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个事件序列: 指的是一次完整的触摸过程, 即从&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指触摸屏幕)开始, 到中间的一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指滑动), 最后到&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;为止(手指抬起); 总结起来就是&lt;code class=&quot;highlighter-rouge&quot;&gt;down...move...move..up&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触摸事件的分发其实是一个从上到下不断递归传递和拦截的过程; 一个大致的传递流程是: &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 当然如果向下传递但是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;又没有消耗的话, 又会逐层返回, 最终将没有消耗的&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-事件分发之源&quot;&gt;二. 事件分发之源&lt;/h2&gt;

&lt;p&gt;触摸事件产生和分发的源头是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中处理的, 即在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;中; 如下; 处理思路也很简单, 只是单纯的向下分发而已, 如果事件没有得到处理, 那么最终就交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理; 另外, 这里还为用户提供了一个监听和拦截事件的方法, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;onUserInteraction()&lt;/code&gt;, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中是一个空实现, 可以重写该方法在事件向下传递之前进行特殊拦截和处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();  // 自定义事件拦截
        }
        if (getWindow().superDispatchTouchEvent(ev)) {  // 通过Window向下分发事件
            return true;
        }
        return onTouchEvent(ev);  // 如果事件最终没有被处理, 那么交给Activity自己的onTouchEvent()来处理
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow&lt;/code&gt;, 这里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow.superDispatchTouchEvent()&lt;/code&gt;传递实际上是只是简单调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor.superDispatchTouchEvent(event)&lt;/code&gt;, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;superDispatchTouchEvent()&lt;/code&gt;方法中, 也只是简单的将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行分发(即&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;); 到这里就将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了, 也是事件分发处理中最主要的一部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-viewgroup分发事件&quot;&gt;三. ViewGroup分发事件&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;中对事件的分发处理过程比较长, 实际上大致分成了三个部分来处理&lt;/p&gt;

&lt;h3 id=&quot;31-事件拦截&quot;&gt;3.1 事件拦截&lt;/h3&gt;

&lt;p&gt;首先, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;会判断是否进行事件拦截, 如下; 从后面将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的条件可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截, 那么该事件序列将不再向下分发; 这里还需要注意的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;判断是否进行事件拦截的条件一个是为&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget != null&lt;/code&gt;时; 也就是说一个事件序列的在开始时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;(当然, 还有一个影响因素是&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 我们稍后讲解); 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的赋值是在后面分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 如果有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值;&lt;/p&gt;

&lt;p&gt;上面是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截的基本思路, 简单总结起来就是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截(&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;), 那么同一事件序列将不再向下分发(因为之后的&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;到来时, 由于之前&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时进行了事件拦截, &lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;没有机会赋值, 所以仍然为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 故直接走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;语句, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;intercepted = true&lt;/code&gt;);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值, 即不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 此时仍然会继续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;判断是否进行事件拦截, 需要注意的是此时仍然在同一事件序列中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 也没有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;仍为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 即走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, 交由&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不处理事件时, &lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;才只会调用一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // ViewGroup是否进行事件拦截
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            if (!canceled &amp;amp;&amp;amp; !intercepted) { // 如果拦截事件, 将不再分发给子View
                // 事件分发给子View
                ....
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 上面还讲了, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;, 这里还有一个影响因素是标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 该标志位是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;requestDisallowInterceptTouchEvent()&lt;/code&gt;设置的, 作用是在子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中强制父&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 但是该标志位不能影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;, 因为在一个事件序列开始之前会先进行状态重置, 如下; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;resetTouchState()&lt;/code&gt;中会将该标志位重置, 所以就不会影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState(); // 状态重置
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-事件分发&quot;&gt;3.2 事件分发&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截的话, 会将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理; 事件分发的主要代码如下; 逻辑也比较简单, 就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;进行将事件传递给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        ...
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &amp;lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign); // 设置mFirstTouchTarget的值
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                        ...
                    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续来看&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;的处理过程, 如下; 从上面的代码中我们可以看出, 将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;非空, 所以应该调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 这样就将事件传递到子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中去了; 这里关于子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;处理在后文继续讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        ...
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event); // child非null
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event); // 调用child.dispatchTouchEvent(event)

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面我们说过, 如果子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 将会去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的值, 该值的设置其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;中, 也就是说, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 就会去调用该函数, 也就证明了我们前面所说的; 我们来看&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;, 如下; 可以看出这里实际上相当于一个单链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget; 
        mFirstTouchTarget = target; // 设置mFirstTouchTarget
        return target;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-viewgroup处理事件&quot;&gt;3.3 ViewGroup处理事件&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;将进行事件处理, 如下; 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件处理也是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;, 只是传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 那么从上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;代码中我们可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;调用的应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;进行事件处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 调用的其实都是&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;, 所以接下来我们要看的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中对事件的处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-view事件处理&quot;&gt;四. View事件处理&lt;/h2&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中没有&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;方法来进行事件拦截; 我们这里关注的, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截之后对事件的处理以及子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理; 因为从前面我们已经说了, 不管是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件)还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent()&lt;/code&gt;(子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理事件), 其实都是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;; 所以二者对事件的处理实际上是一样的, 同时需要注意的是, 这一节不包括事件的分发了,
事件分发在上一节中已经讲解完啦~&lt;/p&gt;

&lt;p&gt;触摸事件的处理主要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;的处理优先级&lt;/p&gt;

&lt;p&gt;主要代码如下; 可以看出先处理的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;View.setOnTouchListener()&lt;/code&gt;)的话, 再去处理&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;,  所以&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的优先级比&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;高; 同时还要注意的一点是, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的话, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;将不再调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
            &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
            &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {  // OnTouchListener
        result = true;
    }
    if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { // onTouchEvent
        result = true;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick()&lt;/code&gt;其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;中处理的; 如下; &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;是在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中触发的, 可以看出, 要触发&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;需要的条件是: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是可以点击的(&lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;), 这里的可点击包括了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLICKABLE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LONG_CLICKABLE&lt;/code&gt;, 注意&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;enable&lt;/code&gt;属性不影响&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;的返回值, 只要它可点击, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;就会处理该点击事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                    if (!focusTaken) {
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) {
                            mPerformClick = new PerformClick();
                        }
                        if (!post(mPerformClick)) {
                            performClickInternal();
                        }
                    }
                }
                ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;进行处理, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;会判断, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 则会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的事件分发和处理流程就分析结束啦~; 我们最开始讲&lt;strong&gt;事件分发之源&lt;/strong&gt;时讲&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;对事件的传递的时候, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;getWindow().superDispatchTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的话, 就最终将事件交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理, 这种情况其实对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;都不进行事件处理, 那么就逐层回传咯~&lt;/p&gt;

&lt;p&gt;当然理论学习完了, 就应该实际测试一下, 这里笔者写了一个测试的&lt;code class=&quot;highlighter-rouge&quot;&gt;Demo&lt;/code&gt;, &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/touch/TouchActivity.java&quot;&gt;参见Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后将上述流程总结为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View事件分发.png&quot; alt=&quot;View事件分发机制&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>Handler</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android消息机制分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handler源码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;算是我们平时开发中比较常用的一个, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所代表的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中重要的一部分, 即消息机制; 本文将分析&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的运行机制&lt;/p&gt;

&lt;h3 id=&quot;11-使用场景&quot;&gt;1.1 使用场景&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程切换: 这个是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见和最频繁的场景了; 我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中不允许执行耗时操作, 那么当我们需要先去获取数据(耗时)再进行&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;展示或者交互的时候, 线程切换就必不可少了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务延时: 即在未来某个时刻再执行任务, 这个主要是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.postDelayed()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessageDelayed()&lt;/code&gt;完成的(实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;postDelayed()&lt;/code&gt;也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessageDelayed()&lt;/code&gt;完成的)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-为什么会有handler&quot;&gt;1.2 为什么会有Handler&lt;/h3&gt;

&lt;p&gt;我们都知道&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的作用主要是用于切换线程, 那么为什么会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;喃; 我们以&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中执行耗时操作为例, 对于耗时操作, 特别是在需要实时交互的应用中, 肯定是需要设计为多线程的, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;设计之初为什么不使用多线程去访问&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;呢, 最致命的一点就是, 多线程存在并发访问的不确定性, 这就会造成&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;表现的不可预期性, 造成用户体验极差; 当然, 对于多线程并发的问题还是有很多方式去避免和解决的, 最常见的一个就是加锁, 那么为什么不采用多线程访问,
对&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;加锁的方式实现呢, 一个是加锁会使&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;逻辑变得复杂, 另一个是加锁会降低效率, 阻塞某些线程的执行&lt;/p&gt;

&lt;p&gt;所以, 基于很多方面的考虑, 特别是对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;应用这样交互性很强的场景而言, 使得需要去实现自己的一套异步通信机制, 需要达到的目标是, 线程之间的独立性保持和数据交互的便利性, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实现的&lt;/p&gt;

&lt;h3 id=&quot;13-概述&quot;&gt;1.3 概述&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;消息机制中, 有非常重要的几个部分, 也是我们分析的切入点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;: 单链表, 实现消息存储; 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层的连接纽带&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Looper&lt;/strong&gt;: 无限循环查询是否有新消息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Handler&lt;/strong&gt;: 消息接受和分发处理的中转站&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见的一种写法, 我们通常会重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;来实现自己的逻辑; 当在其他线程中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessage()&lt;/code&gt;来发送消息时, 我们就会在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中接收到该消息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            // do somthing with msg
            super.handleMessage(msg);
        }
    };

    new Thread() {
        @Override
        public void run() {
           mHandler.sendEmptyMessage(0);
        }
    }.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行线程切换和消息传递的一个大致流程是, 当我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessage()&lt;/code&gt;发送消息的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;负责存储该消息, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;会无限循环的去检查&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 如果有则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage()&lt;/code&gt;进行消息分发, 最终会回到&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;p&gt;在开始讲解之前, 需要先明确几个结论(在稍后会验证): 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是默认没有创建(除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程外); &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所必须的(否则会抛异常); &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是一一对应的关系, 也就是说每个线程会有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;在哪个线程中创建就在哪个线程中处理消息, 其他线程发送的消息存储在对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-构造函数&quot;&gt;二. 构造函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;提供了七个构造函数, 如下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler()&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(Looper looper)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(boolean async)&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback, boolean async)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback, boolean async)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这七个构造函数最常用的是默认构造函数(即不带参数那个), 其他几个, 一类是带&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;的, 是提供的消息处理函数, 我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;一般都会重写其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;方法来处理消息, 但是也可以不重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;, 而是在构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;回调, &lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的一个接口, 如下; 另一类是带标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;的, 是设置消息是否为异步处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的消息默认是同步处理的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public interface Callback {
        public boolean handleMessage(Message msg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们以构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler(Callback callback, boolean async)&lt;/code&gt;进行分析, 如下; 可以看出, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLooper&lt;/code&gt;是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;获取的, 如果我们获取为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;也就是说当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛出异常, 这个异常也是我们大多数初学者会遇到的; 这里也验证了上面所说的, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造所必须的, 如果当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛异常(至于为什么说是当前线程, 接下来马上分析~)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Handler(Callback callback, boolean async) {
        ...
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;又是如何获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的呢; 如下, 可以看出是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;获取的, &lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;类型的实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;不是一个线程, 而是用于在每个线程中存储数据的, &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;可以在不同的线程中互不干扰的存储并提供数据; 那么它是如何实现在不同线程中互不干扰的存取数据的呢, 我们先来看其&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;方法, 可以看出, 其实际上会先去检查当前线程是否持有&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;, 如果有的话, 直接将&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;存储进去即可, 否则, 初始化当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;然后再存放值, 这样就可以根据不同的线程来存取各自线程的值了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们要构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;就必须获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么我们又是什么时候构造和存储的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;喃; 前面我们说了, 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程以外都默认没有创建; 我们先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中是什么时候创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityThread&lt;/code&gt;, 在其&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数中, 我们发现了如下与&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;相关的语句, 这实际上是开启了主线程的消息处理(因为要处理各种事件, 所以一开始就开启了)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    ...
    Looper.prepareMainLooper();
    ...
    Looper.loop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续看&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.prepareMainLooper()&lt;/code&gt;, 其中实际上是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;, 如下; 这里我们看到了熟悉的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal.set()&lt;/code&gt;, 而且存储的是一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么这里就将线程和各自的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;联系起来了, 我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造函数中获取的也就是和各个线程相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里我们知道了, &lt;code class=&quot;highlighter-rouge&quot;&gt;perpare&lt;/code&gt;实际上是在准备&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;又是在做啥呢, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是开启消息处理循环, 前面我们说了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;不断的去检测&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 实际上就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;中开启的&lt;/p&gt;

&lt;p&gt;这里我们暂时不讲&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;, 而是放到后面讲消息处理的时候讲; 我们平时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候, 大多是在&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;
线程中创建的, 因为上面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中默认是创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的, 所以不需要我们再去手动创建, 但是我们如何在子线程中构造和使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;呢; 其实在&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的文档中已经给出了示例, 如下; 其实, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的处理过程差不多, 只是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程的特殊性, 所以单独给它准备了一个方法~(实际上是做一些其他特殊判断和处理)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();
 
          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;三-消息发送&quot;&gt;三. 消息发送&lt;/h3&gt;

&lt;p&gt;当我们需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;发送消息时, 可以使用两个系列, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;系列, 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;系列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;postXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列主要是发送一个自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件, 然后去执行(延迟执行)自定义事件&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;post(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, Object token, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, Object token, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtFrontOfQueue(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;sendXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列主要是发送封装的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;, 然后根据&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;带的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;或者数据在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessage(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessage(int what)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageDelayed(int what, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageAtTime(int what, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageDelayed(Message msg, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtTime(Message msg, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtFrontOfQueue(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;但是, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列最终还是将&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件封装为了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列处理, 而不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;, 最终转到的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;进行处理; 另外, 不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;int what&lt;/code&gt;等其他类型, 其实最终都会将每一条消息封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象进行传递&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-消息存储&quot;&gt;四. 消息存储&lt;/h2&gt;

&lt;p&gt;前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;会对发送的消息进行存储, 这一步就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;中处理的; 如下; 需要注意的是这里传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;是在创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;时创建, 也就是说和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关, 因为涉及到多线程的处理, 所以需要清楚&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;的来源, 不然消息处理的时候就混了~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们简单看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的组织方式, 如下, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.enqueueMessage()&lt;/code&gt;, 可以看出是很明显的单链表的存储方式, 之所以用单链表, 是因为单链表在增加和删除节点上有优势&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean enqueueMessage(Message msg, long when) {
    ...
    needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
    Message prev;
    for (;;) {
        prev = p;
        p = p.next;
        if (p == null || when &amp;lt; p.when) {
            break;
        }
        if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
            needWake = false;
        }
    }
    msg.next = p; // invariant: p == prev.next
    prev.next = msg;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-消息处理&quot;&gt;五. 消息处理&lt;/h2&gt;

&lt;p&gt;还记得前面我们还有一个问题没有解决吗, 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程实际上就是开启循环处理消息的过程~&lt;/p&gt;

&lt;p&gt;该函数如下; 首先获取消息处理线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 前面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是在消息处理线程中调用的, 所以这里获取到的, 也就是消息处理线程, 即创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的线程; 之后获取对应线程的消息队列, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 需要注意这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;关联的, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的获取是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.currentThread()&lt;/code&gt;来判断和获取的, 那么这里就能获取到和对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 当我们在不同线程中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMsg&lt;/code&gt;的时候, 插入的也是和该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 这样, 一整条完整的线就串成了:  不同的线程往需要发送消息的线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中插入&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;, 而和线程关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;又从该&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中不断获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;处理, 这样就完成了线程的切换 !!&lt;/p&gt;

&lt;p&gt;接下来就是用一个死循环(&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;)开始消息处理了; 逻辑也比较简单, 其实就是不断的从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息(&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;), 然后回调&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.dispatchMessage(msg)&lt;/code&gt;分发, 需要注意的是, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;msg.target&lt;/code&gt;实际上是存储的对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void loop() {
    final Looper me = myLooper();
    ...
    final MessageQueue queue = me.mQueue;
    ...

     for (;;) {
        Message msg = queue.next(); // might block
        // 如果消息为null, 不处理咯
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        ...
        msg.target.dispatchMessage(msg);
     }

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage&lt;/code&gt;的处理逻辑, 如下; 逻辑也很简单, 就是消息处理的优先级: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;自身设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;, 就直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;(这种情况对应前面说的&lt;code class=&quot;highlighter-rouge&quot;&gt;post(Runnable)&lt;/code&gt;的情况); 如果构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;那么交给该&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;处理, 否则回调&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还要注意的一点是从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;, 这是一个阻塞方法, 也就是说当&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中没有消息的时候, 会阻塞在这里, 直到&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中再次存储消息&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-总结&quot;&gt;六. 总结&lt;/h2&gt;

&lt;p&gt;到这里&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层面的运行机制我们就讲解完啦~ , 到这里我们对整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;的消息传递和处理机制也有了比较详细的了解了; 为加深记忆, 可以对着源码自己再过一遍过程~&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/15/Handler/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/15/Handler/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Linux开机启动流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux开机启动流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中实验基于&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;版本（&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.x&lt;/code&gt;版本都可以，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS7.x&lt;/code&gt;版本会有所区别）&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-启动流程&quot;&gt;一. 启动流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;开关电源（&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;）在开机之后将&lt;code class=&quot;highlighter-rouge&quot;&gt;AC&lt;/code&gt;信号转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;DC&lt;/code&gt;信号，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;会进行电压的检测，如果正常，&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;将会发送&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt; 信号给主板定时器，主板定时器接收到&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt;信号之后，将会停止发送&lt;code class=&quot;highlighter-rouge&quot;&gt;reset&lt;/code&gt;指令给&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;，这意味着电脑可以正常启动&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;的设置中有一些值是固定的，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;才知道从哪里开始读取指令，在&lt;code class=&quot;highlighter-rouge&quot;&gt;X86&lt;/code&gt;计算机中，第一条指令是&lt;code class=&quot;highlighter-rouge&quot;&gt; FFFF:0000h &lt;/code&gt;，指向&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;的最后一个字节，该指令因为只有一个字节，所以只是简单的包含一个跳转指令，该跳转指令指向的是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;所在的地址（&lt;code class=&quot;highlighter-rouge&quot;&gt;EPROM&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;中）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;就是基本输入输出系统，其功能主要有两个：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;POST：&lt;code class=&quot;highlighter-rouge&quot;&gt;Power On Self Test&lt;/code&gt;；硬件自检；即在&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中有一个硬件设备的列表，为了检测某一个硬件设备是否可用，就发送一个电脉冲给每一个设备，如果该脉冲被设备返回，说明设备可用，否则，不可用；如果有新的硬件接入，那么会使用同样的检测过程，同时会更新&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中的列表，用于下次启动过程&lt;/li&gt;
    &lt;li&gt;选择第一个启动设备：&lt;code class=&quot;highlighter-rouge&quot;&gt; BIOS&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;里面的记录的启动顺序以及上一步硬件自检过程中，设备的可用装态，确定最终的可启动设备顺序，具体的过程是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;将磁盘的第一扇区（磁盘最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节）载入内存，放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X0000:0X7C00&lt;/code&gt;处，然后检查这个扇区的最后两个字节是不是&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;，如果是则认为这是一个有效的启动扇区，如果不是就会尝试下一个启动介 质，如果找到可以启动的程序就会从这一介质启动，如果所有的启动介质都判断过后仍然没有找到可启动的程序那么&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;会给出错误提示&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 我们平时所说的更改&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;设置，实际上是错的，我们更改的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;中存储的设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中信息不能被用户改变，需要厂商提供闪存程序&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;MBR&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;确定好第一个启动设备之后，去该设备磁盘的第一个扇区读取最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节到内存（通过硬件的&lt;code class=&quot;highlighter-rouge&quot;&gt;INT 13&lt;/code&gt;中断功能来读取的），该&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;，即主引导记录；这&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节中有&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节才是正真的主引导加载代码（&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，即可以安装引导加载程序的地方），还有&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;字节用于存放磁盘分区表信息，以及最后两个字节用于校验（&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;)是否为有效的启动扇区；每个分区需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节用于存储分区的开始，结束位置，分区类型等（由于每个分区信息需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节，所以对于采用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;型分区结构的硬盘(其磁盘卷标类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;MS-DOS&lt;/code&gt;)，最多只能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个主要分区。所以对于一个采用此种分区结构的硬盘来说，想要得到&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个以上的主要分区是不可能的。这里就需要引出了扩展分区。扩展分区也是主分区（&lt;code class=&quot;highlighter-rouge&quot;&gt;Primary partition&lt;/code&gt;）的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;结构类似的扩展引导记录(&lt;code class=&quot;highlighter-rouge&quot;&gt;EBR&lt;/code&gt;) ）（&lt;code class=&quot;highlighter-rouge&quot;&gt; MBR&lt;/code&gt;分区方案无法支持超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;容量的磁盘。因为这一方案用&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节存储分区的总扇区数，最大能表示&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;次方的扇区个数，按每扇区&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节计算，每个分区最大不能超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，如果磁盘容量超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，那分区的起始位置 就无法表示了）&lt;/li&gt;
  &lt;li&gt;继续之前，我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;的信息，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;为例（后文不再声明），使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;dd if=/dev/sda of=mbr bs=512 count=1&lt;/code&gt;，将第一个扇区的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节内容转存到&lt;code class=&quot;highlighter-rouge&quot;&gt;mbr&lt;/code&gt;文件中，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt;表示大小；然后可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;file mbr&lt;/code&gt;来查看分区信息等，输出如下；其中&lt;code class=&quot;highlighter-rouge&quot;&gt;partition x&lt;/code&gt;表示第&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;个分区的信息，上面说了，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;时最多只能有四个分区，而且这四个分区中最多只能有一个活动分区，也就是下面被标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;active&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;partition 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 19451904 sectors; partition 2: ID=0x5, starthead 254, startsector 19455998, 2093058 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage1&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;中的前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节存储着引导加载程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;为例；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;有两个阶段（实际上应该是三个阶段，后面会解释），实际上这&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中存储的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;的第一阶段，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节的空间实在有限，做不了太多事情；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;第一阶段的作用主要是加载第二阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;实际上分为三个阶段：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1 -- stage1.5 -- stage2&lt;/code&gt;）&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;是存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中的引导加载程序；&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1.5&lt;/code&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;：扇区编号从0开始，但是真正的磁盘分区一般是从第63个扇区开始的，也就是说从1-63扇区是空闲的（第0个扇区存储&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;），这段空间叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;），因为&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;）存储于磁盘上，但是读取文件系统需要驱动，&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GA&lt;/code&gt;P中主要存储的就是读取文件系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;driver&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;读取该部分内容之后，就可以去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;grub&lt;/code&gt;配置文件，即&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage2&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件，主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;，这里我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.conf&lt;/code&gt;的内容，如下&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;：这个必须和下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;对应，在配置文件中有几个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;，启动的时候就会有几个菜单可以选择；&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;表示使用第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;选项来启动，&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;表示在读秒时间结束前都没有按键，则使用默认选项启动&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout=5&lt;/code&gt;：读秒时间，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;秒钟内没有按键，则使用默认选项启动；当然可以自行调整时间&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;splashimage=(hd0,0)/grub/splash.xpm.gz&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS&lt;/code&gt;启动的时候，后台不是黑白而是彩色变化的，就是这个文件提供的后台图示&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hidemenu&lt;/code&gt;：是否显示提示菜单，默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;hide&lt;/code&gt;的，但是笔者这里将这个选项注释掉了，在选择开机启动项的时候还会显示提示菜单&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;：这部分指定的是菜单选项，开机时有多少个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;就会有多少个菜单选项；每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;下的内容，一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;文件及设置，另一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;位置&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/grub_conf.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;加载：&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loade&lt;/code&gt;根据用户的选项，去加载相应的磁盘映像到内存，内核是一个压缩文件，解压缩后，内核会再一次进行测试与驱动周边设备；之后，内核需要去加载各个模块，&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;内核可以动态加载内核模块，这些内核模块放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;目录下，由于模块放置到磁盘根目录下，所以内核要去读取这些模块的话，需要挂载到根目录，这样才能读取内核模块加载驱动程序的功能，但是内核根本不认识&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘，所以需要加载&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘的驱动程序，否则根本无法挂载根目录，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;的驱动程序是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;内，这就出现了两难的问题，所以为了去挂载根目录，就出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;这个东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;initrd&lt;/strong&gt;：虚拟文件系统，一般位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/initrd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;在将内核加载到内存的同时，也会将&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;加载到内存中，并仿真成为一个根目录；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;的作用就是去加载必要的驱动，以便内核可以访问真正的根文件系统（如：磁盘控制器驱动，文件系统驱动（&lt;code class=&quot;highlighter-rouge&quot;&gt;ext3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt;等）），然后去挂载真正的根文件系统，进行根切换操作，用真正的根文件系统进行启动；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;完成上述任务之后，会清除掉自己在内存中的痕迹，让出空间&lt;/li&gt;
  &lt;li&gt;内核及其必要模块加载完毕之后，会主动执行第一个程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;，这也是第一个启动的进程；&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;的主要功能是根据其配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;）去准备软件的执行环境（系统服务等）；这里我们看一下其配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;的内容；如下；前面的注释是对该配置文件的描述，在笔者的该系统中，&lt;code class=&quot;highlighter-rouge&quot;&gt;inittab&lt;/code&gt;中只有一项配置，即运行级别（&lt;code class=&quot;highlighter-rouge&quot;&gt;runlevel&lt;/code&gt;）的设置，所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;的设置来启动不同的服务，让&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;的运行环境不同；至于&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;，分为七个等级：如下；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0 -- halt&lt;/code&gt;：系统直接关机&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 -- single user mode&lt;/code&gt;：单用户维护模式，用在系统出问题时的维护&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 -- Multi-user， without NFS&lt;/code&gt;：类似下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;，只是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;NFS&lt;/code&gt;服务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3 -- Full multi-user mode&lt;/code&gt;：完整含有网络功能的纯文本模式&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4 -- unused&lt;/code&gt;：系统保留功能&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5 -- X11&lt;/code&gt;：与&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;类似，但是加载使用&lt;code class=&quot;highlighter-rouge&quot;&gt;X Window&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6 -- reboot&lt;/code&gt;：重新启动&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里笔者将运行级别设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;，所以是以纯文本形式启动，即纯命令行模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/inittab.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;到这里系统就启动起来啦 ~ ，这也是系统启动的大致流程 ~&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-参考链接&quot;&gt;二. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;鸟哥私房菜基础学习篇第三版&lt;/li&gt;
  &lt;li&gt;https://www.slashroot.in/linux-booting-process-step-step-tutorial-understanding-linux-boot-sequence&lt;/li&gt;
  &lt;li&gt;https://www.linuxnix.com/linux-booting-process-explained/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Linux</category>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之Queue</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;的实现类, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;集合框架系列博客&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;Java集合框架概述&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/&quot;&gt;Java集合框架之List&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/&quot;&gt;Java集合框架之Set&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/&quot;&gt;Java集合框架之Queue&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;是一个双端队列, 内部使用数组实现, 既可以作为栈使用, 也可以作为队列使用(当作为栈使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;快; 当作为队列使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;快); 既然是双端队列, 那么自然支持首尾插入删除等操作; &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;不是线程安全的, 不允许插入&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;内部使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object[] elements&lt;/code&gt;来容纳元素, 默认初始容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, 需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量大小需要为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数幂次方, 这是为了使用位运算去代替普通的乘除运算来提高效率; 下面将从两个方面讲解其有关知识点: 即基本方法和扩容规则&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-基本方法&quot;&gt;二. 基本方法&lt;/h2&gt;

&lt;h3 id=&quot;21-构造函数&quot;&gt;2.1 构造函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;提供了三个构造函数, 这里只挑其中一个比较难的讲解; 如下, 该构造函数允许提供自定义初始容量, 但是并不是说, 我们传进去多少容量, 最初就会分配多少容量, 因为传进去的值还经过了&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的处理; &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的作用是, 找出不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;numElements&lt;/code&gt;的最小的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的整数, 因为上面已经说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量需要都是&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂; 这点和&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的扩容规则比较相像, 具体分析可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;中对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;扩容规则一节的讲解; 另外, 值得一提的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;的时候还进行了边界值的判断, 一个是初始容量最小为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 最大不得超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2^30&lt;/code&gt;, 如下代码;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void allocateElements(int numElements) {
        elements = new Object[calculateSize(numElements)];
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static int calculateSize(int numElements) {
        int initialCapacity = MIN_INITIAL_CAPACITY;  // 初始最小容量为8
        // Find the best power of two to hold elements.
        // Tests &quot;&amp;lt;=&quot; because arrays aren't kept full.
        if (numElements &amp;gt;= initialCapacity) {
            initialCapacity = numElements;
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
            initialCapacity++;

            if (initialCapacity &amp;lt; 0)   // Too many elements, must back off
                initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements // 最大容量为2^30
        }
        return initialCapacity;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-元素增删&quot;&gt;2.2 元素增删&lt;/h3&gt;

&lt;p&gt;双端队列的难点在于数据元素增删的时候, 如何通过首尾指针的关系判断当前队列是满还是空, 以及插入和删除元素后首尾指针的变化情况; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中的处理是, &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针指向队列首元素, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向队列尾元素的后一个位置, 那么比如在队列头部插入元素时,  通过判断&lt;code class=&quot;highlighter-rouge&quot;&gt;(head - 1) &amp;amp; (elements.length - 1) == tail&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的时候队列就满了, 这样, 虽然双端队列在队列满和空的情况下, 都是&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;, 但是仍然能够分辨&lt;/p&gt;

&lt;p&gt;下面我们通过具体的元素添加来看, 如下, 为在队列头添加元素, 这里需要注意的一点是先添加元素, 再判断队列是否已满, 这是因为上面我们说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向的是队尾元素的下一个位置, 一定是空位置, 否则在上一次添加元素的时候就会引起扩容了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addFirst(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e;
        if (head == tail)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里讲一下&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;的运算规则, 比如, 当我们的数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 本次插入之前&lt;code class=&quot;highlighter-rouge&quot;&gt;head = 0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail = 7&lt;/code&gt;的时候, 执行该插入操作, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;元素, 即 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1 &amp;amp; 7&lt;/code&gt;, 转换为二进制就是(&lt;code class=&quot;highlighter-rouge&quot;&gt;1111 &amp;amp; 0111 = 0111&lt;/code&gt;), 最终运算结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;, 所以可以判断队列满了, 需要扩容 ~&lt;/p&gt;

&lt;p&gt;其实这里使用位运算也是利用了数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的特点&lt;/p&gt;

&lt;p&gt;同理, 在队列尾插入元素也是一样的, 如下; 就不再分析啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addLast(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[tail] = e;
        if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于删除元素来说, 这里举一个例子, 如下; 主要看&lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针的变化规则, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (h + 1) &amp;amp; (elements.length - 1);&lt;/code&gt;, 其实就是和插入元素相反的过程而已&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public E pollFirst() {
        int h = head;
        E result = (E) elements[h];
        // Element is null if deque empty
        if (result == null)
            return null;
        elements[h] = null;     
        head = (h + 1) &amp;amp; (elements.length - 1);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-扩容规则&quot;&gt;三. 扩容规则&lt;/h2&gt;

&lt;p&gt;什么时候会扩容呢, 我们注意到, 上面我们讲解插入元素指针变化规则的时候, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;也就是队列满了的时候, 会调用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;
函数, 其实该函数就是用于扩容的&lt;/p&gt;

&lt;p&gt;那么根据上面的分析, 什么时候会发生扩容呢, 其实就是当队列满的时候; 扩容的规则又是怎样的呢, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;的函数名我们猜测, 就是将数组容量加倍而已; 如下, 思路也比较简单, 就是创建一个扩容的新数组进行旧元素的复制罢了, 比较简单, 不再赘述&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void doubleCapacity() {
        assert head == tail;
        int p = head;
        int n = elements.length;
        int r = n - p; // number of elements to the right of p
        int newCapacity = n &amp;lt;&amp;lt; 1; // 左移一位, 相当于容量加倍
        if (newCapacity &amp;lt; 0)
            throw new IllegalStateException(&quot;Sorry, deque too big&quot;); // 这是因为左移溢出之后会变成负值, 说明队列太大啦~
        Object[] a = new Object[newCapacity];
        System.arraycopy(elements, p, a, 0, r);
        System.arraycopy(elements, 0, a, r, p);
        elements = a;
        head = 0;
        tail = n;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四-总结&quot;&gt;四. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的源码就分析完啦~; 最后笔者还想补充解释一点的是, 最开始我们提过, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为栈来使用的时候, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;要快, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;, 我们在&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;Java集合框架概述&lt;/a&gt;中粗略的提过, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java 2&lt;/code&gt;以前的几个遗留&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 其内部也是使用数组实现的, 但是由于其加了锁, 支持多线程访问, 所以会比&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;要慢; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为队列使用的时候,
比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;要快是因为在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;内部是使用链表节点实现的, 不具备数组的索引定位, 当然也就是慢啦~&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Fresco源码解析</title>
        <description>&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化Fresco: Fresco.initialize(this); 最好在Application中初始化, 多次初始化是无意义的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心类为: SimpleDraweeView; 在layout中使用该类, 然后在代码中, 剩下的Fresco自动完成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;);
SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);
draweeView.setImageURI(uri);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Fresco会自动完成:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;显示占位图直到加载完成；&lt;/li&gt;
        &lt;li&gt;下载图片；&lt;/li&gt;
        &lt;li&gt;缓存图片；&lt;/li&gt;
        &lt;li&gt;图片不再显示时，从内存中移除；&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;关键概念&quot;&gt;关键概念&lt;/h2&gt;

&lt;h3 id=&quot;一-drawees&quot;&gt;一. Drawees&lt;/h3&gt;

&lt;p&gt;分为三个主要部分, 有点像MVC模式&lt;/p&gt;

&lt;h4 id=&quot;11-draweeview&quot;&gt;1.1 DraweeView&lt;/h4&gt;

&lt;p&gt;一般情况下使用SimpleDraweeView即可&lt;/p&gt;

&lt;h4 id=&quot;12-draweehierarchy&quot;&gt;1.2 DraweeHierarchy&lt;/h4&gt;

&lt;p&gt;用于组织和维护最终绘制和呈现的 Drawable 对象, 可通过它来自定义图片显示效果&lt;/p&gt;

&lt;h4 id=&quot;13-draweecontroller&quot;&gt;1.3 DraweeController&lt;/h4&gt;

&lt;p&gt;负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的), 对所要显示的图片做更多的控制&lt;/p&gt;

&lt;p&gt;如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类&lt;/p&gt;

&lt;h4 id=&quot;14-draweecontrollerbuilder&quot;&gt;1.4 DraweeControllerBuilder&lt;/h4&gt;

&lt;p&gt;由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改&lt;/p&gt;

&lt;h4 id=&quot;15-listeners&quot;&gt;1.5 Listeners&lt;/h4&gt;

&lt;p&gt;使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。&lt;/p&gt;

&lt;h3 id=&quot;二-image-pipeline&quot;&gt;二. Image Pipeline&lt;/h3&gt;

&lt;p&gt;负责图片的获取和管理&lt;/p&gt;

&lt;p&gt;压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。Image pipeline 会首先从内存中搜寻图片，然后是磁盘缓存，再然后是网络或其他来源&lt;/p&gt;

&lt;p&gt;在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。&lt;/p&gt;

&lt;p&gt;SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline&lt;/p&gt;

&lt;p&gt;Image pipeline 默认有3个线程池:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;3个线程用于网络下载&lt;/li&gt;
    &lt;li&gt;2个线程用于磁盘操作: 本地文件的读取，磁盘缓存操作。&lt;/li&gt;
    &lt;li&gt;2个线程用于CPU相关的操作: 解码，转换，以及后处理等后台操作。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;uri格式&quot;&gt;URI格式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/supported-uris.html&quot;&gt;URI支持格式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;drawee的各种效果配置fresco支持的各种图片层级&quot;&gt;Drawee的各种效果配置(Fresco支持的各种图片层级)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/drawee-branches.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置要加载的图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;占位图(Placeholder)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置加载失败占位图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击重新加载图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示进度条&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置叠加图(Overlay)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置按压状态下的叠加图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓存策略&quot;&gt;缓存策略&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/caching.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/getting-started.html&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Fresco/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Fresco/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
      <item>
        <title>大二下总结</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;将一切交给时光, 相信一切都是最好的结局&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;大二下学期可能是我大学生活中最刺激的一个阶段, 大概就是整整一个学期, 从周一到周末, 每天满课的那种; 更刺激的是一天考了三门(早中晚, 没毛病~)&lt;/p&gt;

&lt;p&gt;上课期间, 学的主要是算法和&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;基础这部分; 暑假期间, 主要是做项目&lt;/p&gt;

&lt;p&gt;总体感受: 稍显疲惫 ~&lt;/p&gt;

&lt;h2 id=&quot;二-项目&quot;&gt;二. 项目&lt;/h2&gt;

&lt;p&gt;项目部分主要是暑假接触到的两个项目, 一个与&lt;code class=&quot;highlighter-rouge&quot;&gt;OpenGL&lt;/code&gt;有关, 另一个是工具类&lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;21特点&quot;&gt;2.1特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;产品迭代快, 周期短&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;框架复用, 模块化明显: 广告, 打点, 使用逻辑等(后者复用前者的大部分, 除了使用逻辑改变了, 其余基本相同)(同一个框架填不同内容)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心功能简单直接, 迭代快, 但注定消亡的也快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纯&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22一点体会&quot;&gt;2.2一点体会&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;公司业务紧跟市场&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;负载量大: 大概就是想摸鱼都没有水的那种 ~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对一个产品细节上感受: &lt;code class=&quot;highlighter-rouge&quot;&gt;The Best !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个产品的总体流程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三-规划&quot;&gt;三. 规划&lt;/h2&gt;

&lt;h3 id=&quot;31不足&quot;&gt;3.1不足&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;知识点零碎, 构不成框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新事物的把握不足&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不够深入和全面&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32安排&quot;&gt;3.2安排&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;总结成文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;具体安排新事物的学习时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;各方面的联系, 框架~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;思考和内化&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/01/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/01/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/</guid>
        
        <category>Hust</category>
        
        
      </item>
    
      <item>
        <title>图片缓存之Picasso源码分析</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片缓存系列之&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;在开始之前, 我想先贴两张比较具有概括性的流程图&lt;/p&gt;

&lt;p&gt;下面这张是对&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;核心交互类的概括, 来自&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso.png&quot; alt=&quot;Picasso&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面这张是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;下载一张图片的时候的执行流程图, 来自&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso执行流程图.png&quot; alt=&quot;picasso流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 笔者在看&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码的时候, 发现其执行流程和上图有些不符, 主要是没有最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;Downloader&lt;/code&gt;, 下载过程完全交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去做, 应该是不同版本造成的; (本文对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码版本为&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso:2.71828&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中比较重要的类在上面第一张图片已经列出, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;; 下面分别总述一下其作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;: 该类是我们使用的起点, 是图片下载, 图片转换, 图片缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;; 其提供的静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;, 用于接收用户配置, 一般而言, 我们都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的一个全局实例(单例);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;: 顾名思义, 就是一个调度中转站, 用于分发请求(下载请求, 暂停请求, 恢复请求等), 传递数据(数据成功返回时进行分发绑定), 错误处理分发等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;: 这是一个抽象类, 提供了数据处理的公共抽象; &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;默认实现的有&lt;code class=&quot;highlighter-rouge&quot;&gt;AssetRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceDrawableRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContentStreamRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContactsPhotoRequestHandler&lt;/code&gt;; 分别对应于不同的处理场景和模式, 其中最重要和最常见的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;了; 当然, 也可以自定义实现该类, 用于处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;所没有涵盖的特殊情况(需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso.Builder.addRequestHandler(RequestHandler)&lt;/code&gt;注册)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面, 笔者将主要分析网络请求这一部分, 包括: 一条&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;被处理的完整流程,  暂停,恢复和取消请求机制, 缓存机制; 当然, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;还处理了很多其他情况, 如程序监控部分, 图片处理部分等, 但这些不是最主要的, 本文不再赘述&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-url处理流程&quot;&gt;二. URL处理流程&lt;/h2&gt;

&lt;p&gt;开始之前, 需要先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的典型使用, 如下; 各部分的作用都已经标注清楚了, 下面将对每一个过程进行讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     PicassoProvider.get() // 单例, 用于得到一个全局唯一Picasso实例
        .load(url) // 加载url
        .placeholder(R.drawable.placeholder) // 设置图片加载过程中的占位图片
        .error(R.drawable.error) // 设置出错后的占位图片
        .fit() // 图片处理部分, 表示将图片适应ImageView大小
        .tag(context) // 设置tag, 用于暂停, 恢复, 取消请求时使用
        .into(view); // 加载成功后设置到哪个View中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoProvider.get()&lt;/code&gt;是实现的一个单例模式, 如下; 该模式比较常见, 不多讲&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Picasso get() {
    if (instance == null) {
      synchronized (PicassoProvider.class) {
        if (instance == null) {
          Context autoContext = PicassoContentProvider.context;
          if (autoContext == null) {
            throw new NullPointerException(&quot;context == null&quot;);
          }
          instance = new Picasso.Builder(autoContext).build();
        }
      }
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面我们可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的实例是通过其静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;进行&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;的, 这也是一种典型的设计模式–&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;模式; 该模式对于有很多参数要设置时是很方便的, 这里没有进行额外的参数设置, 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部的默认参数(比如: 默认缓存大小, 使用自带&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;等进行请求处理等)&lt;/p&gt;

&lt;p&gt;之后的过程是将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;加载进去, 然后将该&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt;实例, 返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestCreator&lt;/code&gt;实例, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;into&lt;/code&gt;的时候, 进行异步请求图片; 当然, 在之前, 还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;placeholder()&lt;/code&gt;的过程, 该过程上面说了就是设置一个请求过程中的占位图片, 其内部做的也很简单, 只是将&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt;保留下来, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;中进行统一的逻辑处理&lt;/p&gt;

&lt;p&gt;接下来, 主要的处理逻辑都指向了&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;函数, 下面我们来详细看其逻辑; 如下, 先设置占位图片, 然后将请求封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;实例提交到线程池中处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void into(@NonNull ImageView target, @Nullable Callback callback) {
    ...
    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable()); // 设置占位图片
      }
      return;
    }
    ...
    Action action = new ImageViewAction(picasso, wrapper, request, callback);
    picasso.enqueueAndSubmit(action); // 提交请求
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.enqueueAndSubmit()&lt;/code&gt;又只是单纯的去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;中将任务分配给&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void submit(Action action) {
    dispatcher.dispatchSubmit(action);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行消息传递的, 该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherHandler&lt;/code&gt;, 我们直接去看其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;就好;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void handleMessage(final Message msg) {
    case REQUEST_SUBMIT: {
          Action action = (Action) msg.obj;
          dispatcher.performSubmit(action);
          break;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performSubmit()&lt;/code&gt;中进行处理, 将请求再次封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 之后提交给线程池进行异步加载, 即下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;service.submit()&lt;/code&gt;, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoExecutorService&lt;/code&gt;, 继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;, 默认开了&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个线程, 当然, 这部分与网络请求相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部也进行了判断, 比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;Wifi&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;2G&lt;/code&gt;环境下采用不同的请求策略, 感兴趣的话可以自己跟着走一遍, 这里的主要目的是看一个网络请求的完整处理过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void performSubmit(Action action, boolean dismissFailed) {
        ...
        hunter = forRequest(action.getPicasso(), this, cache, stats, action);
        hunter.future = service.submit(hunter);
        ...
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们上面说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 线程池执行的时候, 就是去执行其&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中, 有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;, 其作用是将请求得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;返回, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;是一个阻塞耗时方法, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;异步运行, 所以也没有问题; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;中, 又是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;的一个实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去处理的, 处理过程也是常规的图片下载过程, 如下;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    result = hunt();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void load(@NonNull Picasso picasso, @NonNull final Request request, @NonNull
  final Callback callback) {
    ...
    ResponseBody body = response.body();
    ...
    Bitmap bitmap = decodeStream(body.source(), request);
    callback.onSuccess(new Result(bitmap, loadedFrom));
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在图片接受完成之后, 再一步步函数返回, 封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;, 回传至&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行通知图片接受成功还是失败; 最终会在&lt;code class=&quot;highlighter-rouge&quot;&gt;deliver()&lt;/code&gt;中调用主线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;通知进行处理;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    if (result.getBitmap() == null &amp;amp;&amp;amp; result.getDrawable() == null) {
        dispatcher.dispatchFailed(this);
    } else {
        dispatcher.dispatchComplete(this);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void deliver(BitmapHunter hunter) {
    ...
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;的处理逻辑在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;类中, 很明显, 到这里之后就是将图片设置到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final Handler HANDLER = new Handler(Looper.getMainLooper()) {
    @Override public void handleMessage(Message msg) {
      switch (msg.what) {
        case HUNTER_COMPLETE: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          hunter.picasso.complete(hunter);
          break;
        }
        ...
      }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 从网络请求图片的一个完整过程就讲完了, 当然, 中间还涉及很多代码细节和处理, 最好自己跟着流程再一遍 ~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-暂停-恢复-取消请求处理&quot;&gt;三. 暂停, 恢复, 取消请求处理&lt;/h2&gt;

&lt;p&gt;暂停请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;; 恢复请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 取消请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;; 一般来说, 这些的使用场景是, 考虑当我们从网络加载图片填充到&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;的时候, 如果我们在用户不断滑动过程中不暂停请求的话, 那么就会造成加载的延迟和卡顿(因为在不断滑动过程中会产生许多网络请求); 一般比较通用的解决方法是给&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;GridScrollListener&lt;/code&gt;), 监听滑动过程, 在滑动过程中暂停请求, 停止滑动时恢复请求即可&lt;/p&gt;

&lt;p&gt;那么暂停, 恢复, 取消请求的实现机制又是如何的呢, 下面我们将一一分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31-暂停请求&quot;&gt;3.1 暂停请求&lt;/h3&gt;

&lt;p&gt;我们直接看&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;做了什么, 如下; 其直接交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行请求分发, 这也符合我们上面总述的时候讲的&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;的功能; 之后&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;仍然通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行事件分发, 如下; 而其对&lt;code class=&quot;highlighter-rouge&quot;&gt;TAG_PAUSE&lt;/code&gt;事件的处理则是直接转交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.performPauseTag(tag);&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void pauseTag(@NonNull Object tag) {
    checkNotNull(tag, &quot;tag == null&quot;);
    dispatcher.dispatchPauseTag(tag);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchPauseTag(Object tag) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performPauseTag()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedActions&lt;/code&gt;中, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performPauseTag(Object tag) {
    // Trying to pause a tag that is already paused.
    if (!pausedTags.add(tag)) { // 如果已经添加, 则直接返回
      return;
    }

    // Go through all active hunters and detach/pause the requests
    // that have the paused tag. // 否则, 遍历BitmapHunter, 将对应tag保存下来
    for (Iterator&amp;lt;BitmapHunter&amp;gt; it = hunterMap.values().iterator(); it.hasNext();) {
        ...
        pausedActions.put(single.getTarget(), single);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们什么时候会用到该&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;呢, 就是在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;分发请求的时候, 这里先去判断在&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中是否有对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;记录, 如果有的话, 就不进行请求分发, 那么自然也就不会去下载图片了 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performSubmit(Action action, boolean dismissFailed) {
    if (pausedTags.contains(action.getTag())) {
      pausedActions.put(action.getTarget(), action);
      ...
      return;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32--恢复请求&quot;&gt;3.2  恢复请求&lt;/h3&gt;

&lt;p&gt;恢复请求使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 恢复请求的过程和暂停请求的过程差不多, 前面都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;直接进行请求分发, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;去发送消息, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;进行处理; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;中, 一个是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中移除, 另一个是将原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;(封装了请求等信息)通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;传递, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;REQUEST_BATCH_RESUME&lt;/code&gt;的处理, 则是对每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeAction()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performResumeTag(Object tag) {
    // Trying to resume a tag that is not paused.
    if (!pausedTags.remove(tag)) {
      return;
    }

    List&amp;lt;Action&amp;gt; batch = null;
    for (Iterator&amp;lt;Action&amp;gt; i = pausedActions.values().iterator(); i.hasNext();) {
      Action action = i.next();
      if (action.getTag().equals(tag)) {
        if (batch == null) {
          batch = new ArrayList&amp;lt;&amp;gt;();
        }
        batch.add(action);
        i.remove();
      }
    }

    if (batch != null) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;resumeAction()&lt;/code&gt;中, 其实就是将请求交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueAndSubmit()&lt;/code&gt;, 而该过程在上面我们分析一个&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;的完整请求过程的时候, 已经看到过该函数了; 接下来的过程就不赘述了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void resumeAction(Action action) {
    ...
    enqueueAndSubmit(action);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-取消请求&quot;&gt;3.3 取消请求&lt;/h3&gt;

&lt;p&gt;取消请求用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;, 该函数一共有三个重载函数, 但是最终都是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelExistingRequest()&lt;/code&gt;处理, 接下来的过程和上面的过程差不多, &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.dispatchCancel()&lt;/code&gt;分发消息, 然后交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;传递消息, 最终调用&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;处理请求; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;移除就好了, 前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 所以将其移除之后, 自然就取消请求啦 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performCancel(Action action) {
    String key = action.getKey();
    BitmapHunter hunter = hunterMap.get(key);
    if (hunter != null) {
      hunter.detach(action);
      if (hunter.cancel()) {
        hunterMap.remove(key);
        ...
      }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;34-小结&quot;&gt;3.4 小结&lt;/h3&gt;

&lt;p&gt;到这里, 暂停, 恢复, 取消请求的过程我们已经有了比较详细的了解, 当然, 对于一个图片加载库来说, 这些接口也都是必备的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-缓存&quot;&gt;四. 缓存&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的缓存也分为内存缓存和磁盘缓存, 内存缓存基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;可以自行配置缓存大小等, 磁盘缓存依赖与&lt;code class=&quot;highlighter-rouge&quot;&gt;Http&lt;/code&gt;缓存, 不可配置&lt;/p&gt;

&lt;p&gt;至于内存缓存部分, 逻辑很常规, 在&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;中已经比较详细的讲过&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;的源码了, 可以参照该博客; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认使用的内存缓存最大容量是可用内存的&lt;code class=&quot;highlighter-rouge&quot;&gt;15%&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;磁盘缓存, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;去实现, 而没有明确的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;去缓存; 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;okhttp3.Cache&lt;/code&gt;, 该类中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;用于磁盘缓存; &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的缓存策略可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;, 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;OKHttp&lt;/code&gt;的缓存策略会单独抽取一篇博客出来;
这里只是简单提一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认的磁盘缓存策略, 即使用存储容量的&lt;code class=&quot;highlighter-rouge&quot;&gt;2%&lt;/code&gt;, 但是不多于&lt;code class=&quot;highlighter-rouge&quot;&gt;50M&lt;/code&gt;不少于&lt;code class=&quot;highlighter-rouge&quot;&gt;5M&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pciasso&lt;/code&gt;的主要源码就分析到这里, 最后还想贴一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的总体特性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;轻量级的图片加载库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自带监控功能, 可以检测&lt;code class=&quot;highlighter-rouge&quot;&gt;cache hit/内存大小&lt;/code&gt;等等数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片预加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程并发数依网络状态变化而变化, 优先级调度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片变换, 图片压缩, 自适应&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;易扩展&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是一个优秀的图片加载库, 其也具备了一个图片加载库应该具有的模块:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;请求分发模块。负责封装请求,对请求进行优先级排序,并按照类型进行分发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存模块。通常包括一个二级的缓存，内存缓存、磁盘缓存。并预置多种缓存策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载模块。负责下载网络图片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监控模块。负责监控缓存命中率、内存占用、加载图片平均耗时等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片处理模块。负责对图片进行压缩、变换等处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地资源加载模块。负责加载本地资源，如assert、drawable、sdcard等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示模块。负责将图片输出显示。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考链接&quot;&gt;六. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/&quot;&gt;Picasso源代码分析&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
