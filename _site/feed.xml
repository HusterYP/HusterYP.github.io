<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 09 Nov 2018 11:35:28 +0800</pubDate>
    <lastBuildDate>Fri, 09 Nov 2018 11:35:28 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Java并发[三]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解锁等高级主题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-死锁及其避免&quot;&gt;一. 死锁及其避免&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;死锁出现的原因通常是出现锁环路造成的, 不管是显示的还是隐式的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过定义获取锁的顺序来避免死锁: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;System.identityHashCode(object)&lt;/code&gt;来返回一个锁对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.hashCode()&lt;/code&gt;的返回值; 通过这个值来定义锁的顺序, 并在整个应用程序中都按照这个顺序来获取锁, 那么就不会形成锁环路了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Object fromAcct = new Object(); // 这里的锁对象也可以是其他
        Object toAcct = new Object();
        Object tieLock = new Object();
        int fromHash = System.identityHashCode(fromAcct);
        int toHash = System.identityHashCode(toAcct);
        if (fromHash &amp;lt; toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    // doSomething
                }
            }
        } else if (fromHash &amp;gt; toHash) {
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    // doSomething
                }
            }
        } else { // 这种情况主要是避免Hash冲突, 此时需要额外的锁
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        // doSomething
                    }
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用开放调用(如果在调用某个方法时, 不需要持有锁, 那么这种调用就被成为开放调用)避免死锁: 这种情况下适用于持有不同锁的方法之间的相互调用(注意锁的级别是在方法上, 而不是代码块上)(相当于形成一个隐式的环); 将锁从方法上转移到需要同步的内部代码块上可以避免死锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock.tryLock()&lt;/code&gt;: 可以检测死锁和从死锁中恢复过来; 即指定一个超时时限, 在等待超过该时间后&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock()&lt;/code&gt;会返回一个失败信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的几点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;对象分配操作的开销比同步的开销更低(实际上, 现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;的分配操作已经比&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;调用更快&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的以前实现中(现在实现不同咯)采用分段锁, 使用了一个包含&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个锁的数组, 每个锁保护散列桶的&lt;code class=&quot;highlighter-rouge&quot;&gt;1/16&lt;/code&gt;, 这样就能够支持多达&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个并发的写入器; &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;将对每个分段进行枚举并将每个分段中的元素数量相加, 而不是维护一个全局计数, 为了避免枚举每个计数, &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;为每个分段都维护了一个独立的计数, 并通过每个分段的锁来维护这个值(这个地方有两点需要注意: 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算是在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作都会改变一次, 这样虽然增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;的操作, 但是这会使得&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算从&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;; 另一个是为每个分段维护一个&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 而不是使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 如果使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的话, ,实际上就破坏了分段锁的分段特性, 因为访问共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的时候, 需要同步)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 09 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[二]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要讲解了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;框架&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-executor框架&quot;&gt;一. Executor框架&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程池: 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Executors&lt;/code&gt;中的静态工厂方法之一来创建一个线程池&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newFixedThreadPool&lt;/code&gt;: 创建一个固定长度的线程池, 每当提交一个任务时就创建一个线程, 直到达到线程池的最大数量, 这是线程池规模将不再变化(如果某个线程发生异常终止, 那么线程池会补充一个线程)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newCachedThreadPool&lt;/code&gt;: 创建一个可缓存的线程池, 如果线程池的当前规模超过了处理需求时, 那么将回收空闲的线程, 而当需求增加时, 则可以添加新的线程, 线程池的规模不存在任何限制&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;: 一个单线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;, 它创建单个工作者线程来执行任务, 如果这个线程异常结束, 会创建另一个线程来代替;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;能确保依照任务在队列中的顺序来执行(如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LIFO&lt;/code&gt;, 优先级)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newScheduledThreadPool&lt;/code&gt;: 创建了一个固定长度的线程池, 而且以延迟或定时的方式来执行任务, 类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;生命周期: 为了解决执行服务的生命周期问题, &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;扩展了&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;接口; &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;的生命周期有三种状态: 运行, 关闭, 已终止; 提供了如下方法:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt;: 执行平缓的关闭过程, 不再接受新任务, 同时等待已经提交的任务执行完成(包括那些还未开始执行的任务)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow()&lt;/code&gt;: 执行粗暴的关闭过程, 尝试取消所有运行中的任务, 并且不再启动队列中尚未开始执行的任务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;awaitTermination()&lt;/code&gt;: 等待&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;到达终止状态, 或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;isTerminated()&lt;/code&gt;来轮循是否已经终止&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;延迟任务与周期任务: &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;ScheduleThreadPoolExecutor&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;: 在执行所有定时任务时只会创建一个线程, 如果某个任务执行时间过长, 那么将破坏其他&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;的定时精确性; &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;线程并不捕获异常, 因此当&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;抛出未检查异常时将终止定时线程&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序, 运行&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;秒之后结束, 而不是运行&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;秒; 同时还会抛出异常&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class OutOfTime {
    public static void main(String[] args) throws InterruptedException {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 5);
        SECONDS.sleep(5);
    }

    public static class ThrowTask extends TimerTask {

        @Override
        public void run() {
            throw new RuntimeException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;携带结果的任务&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;任务主入口点(即&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;)将返回一个值, 并可能抛出一个异常&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;: 表示一个任务的生命周期, 并提供了相应的方法来判断是否已经完成或取消, 以及获取任务的结果和取消任务等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;二者区别参见其提供方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-中断&quot;&gt;二. 中断&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;有三个中断方法: &lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupted()&lt;/code&gt;, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;能中断目标线程, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupt()&lt;/code&gt;能返回目标线程的中断状态, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;将清除当前线程的中断状态并返回它之前的值; 这也是清除中断状态的唯一方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阻塞库方法, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.wait()&lt;/code&gt;等, 都检查线程何时中断, 它们在响应中断时执行的操作包括: 清除中断状态, 抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;并不意味着立即停止目标线程正在进行的工作, 而只是传递了请求中断的消息(由线程自己去决定如何处理中断)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中断是实现取消最合理的方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;响应中断:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;传递异常&lt;/li&gt;
        &lt;li&gt;恢复中断状态&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;不可阻塞中断: 许多可阻塞的方法都是通过提前返回或者抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;来响应中断请求的; 但是并非所有的可阻塞方法或者阻塞机制都能响应中断, 有如下两种情况:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当线程执行同步的&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket I/O&lt;/code&gt;时&lt;/li&gt;
    &lt;li&gt;等待获得内置锁而阻塞时: 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;类中提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;lockInterruptibly&lt;/code&gt;方法来允许在等待一个锁的同时仍能响应中断&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-守护线程&quot;&gt;三. 守护线程&lt;/h2&gt;

&lt;p&gt;线程可以分为两种: 普通线程和守护线程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;启动时创建的所有线程中, ,除了主线程以外, 其他的线程都是守护线程(例如垃圾回收器以及其他执行辅助工作的线程); 当创建一个新线程时, 新线程将继承它的线程的守护状态&lt;/p&gt;

&lt;p&gt;普通线程与守护线程的区别仅在于当线程退出时发生的操作, 当一个线程退出时, &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会检查其他正在运行的线程, 如果这些线程都是守护线程, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会正常退出操作, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;停止时, 所有仍然存在的守护线程都将被抛弃–既不会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finally&lt;/code&gt;代码块, 也不会执行回卷栈, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;只是直接退出&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java并发编程实战第一部分总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;先检查后执行&lt;/strong&gt;: 首先观察到某个条件为真(例如文件X不存在), 然后根据这个观察结果采用相应的动作(创建文件X), 但事实上, 在你观察到这个结果以及开始穿件文件之间, 观察结果可能变得无效(另一个线程创建了文件X), 从而导致各种问题(未预期异常, 数据被覆盖, 文件被破坏等)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象都可以用作一个实现同步的锁, 这些锁被称为内置锁或监视锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要在构造过程中使&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用逸出: 当且仅当对象的构造函数返回时, 对象才处于可预测的和一致的状态, 因此, 当从对象的构造函数中发布对象时, 只是发布了一个尚未构造完成的对象, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出, 那么这种对象就被认为是不正确的构造; 常见场景是:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在构造函数中创建线程: 在构造函数中创建线程并没有错, 但是最好不要立即启动它&lt;/li&gt;
    &lt;li&gt;在构造函数中注册事件监听: 依据是非静态内部类会持有外部类的引用&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() { // this逸出
            public void onEvent(Event e) { 
                doSomething(); 
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用静态工厂方法来防止&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething();
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener listener = new SafeListener();
        source.registerListener(listener.listener);
        return listener;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;一个正确构造的对象可以通过以下方式来安全的发布:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;在静态初始化函数中初始化一个对象引用&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的域或者&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicReferance&lt;/code&gt;对象中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到某个正确构造对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;类型域中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到一个由锁保护的域中&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要安全的发布一个静态构造的对象, 最简单和安全的方式是使用静态的初始化器: 静态初始化器由&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;在类的初始化阶段执行, 由于在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;内部存在着同步机制, 因此通过这种方式初始化的任何对象都可以被安全的发布&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Holder holder = new Holder();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-synchronized&quot;&gt;二. synchronized&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;使用的是对象锁, 修饰方法, 代码块或局部执行代码时, 使用的是当前锁对象; 修饰静态方法时, 使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;XX.class&lt;/code&gt;锁对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内置锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)可重入; 可重入: 如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功, 而不会造成死锁
考虑如下代码, 子类改写了父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;方法, 然后调用父类中的方法, 此时如果没有可重入的锁, 那么这段代码将产生死锁&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
    public synchronized void doSomething() {
        System.out.println(&quot;Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public synchronized void doSomething() {
        System.out.println(&quot;LoggingWidget&quot;);
        super.doSomething();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;不能被继承:
    &lt;blockquote&gt;
      &lt;p&gt;1、子类继承父类时, 如果没有重写父类中的同步方法, 子类同一对象, 在不同线程并发调用该方法时, 具有同步效果&lt;/p&gt;
      &lt;ol&gt;
        &lt;li&gt;子类继承父类, 并且重写父类中的同步方法,但没有添加关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;, 子类同一对象, 在不同线程并发调用该方法时, 不再具有同步效果&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Widget {
    public synchronized void doSomething() {
        System.out.println(Thread.currentThread() + &quot; Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public void doSomething() { // 这里没有加synchronized
        System.out.println(Thread.currentThread() + &quot; LoggingWidget&quot;); // 由于子类的doSomething()没有加synchronized方法, 所以子类的doSomething()不可同步
        super.doSomething(); // 但是父类的doSomething()仍可同步
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-volatile&quot;&gt;三. volatile&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量用来确保将变量的更新操作通知到其他线程; 当把变量声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型后, 不会将该变量上的操作与其他内存操作一起重排序, &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量不会被缓存在寄存器或者对其他处理器不可见的地方, 因此在读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的变量总会返回最新写入的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前大多数处理器架构上, 读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销只比读取非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销略高一些&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;变量(&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位), &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;允许将&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位的读操作或写操作分解为两个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位的操作; 当读取一个非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;变量时, 如果对该变量的读操作和写操作在不同线程中执行, 那么很可能会读取到某个值的高&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位和另一个值的低&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位; 因此, 即使不考虑失效数据问题, 在多线程中使用共享且可变的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;等类型的变量也是不安全的, 除非用&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;来声明他们, 或者用锁保护起来&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-同步工具类&quot;&gt;四. 同步工具类&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步工具类可以根据其自身的状态来协调线程的控制流; 可以用作同步工具类的如: 阻塞队列, 信号量(Semaphore), 栅栏(Barrier), 闭锁(Latch)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;41-阻塞队列-blockingqueue&quot;&gt;4.1 阻塞队列-BlockingQueue&lt;/h3&gt;

&lt;p&gt;阻塞队列提供了可阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法, 以及支持定时的&lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt;方法, 如果队列已经满了, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法将阻塞直到有空间可用; 如果队列为空, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法将阻塞直到有元素可用(实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;循环不断插入元素和获取元素, 以及结合信号量来实现的阻塞)&lt;/p&gt;

&lt;p&gt;常用的接口&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现有: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayBlockingQueue&lt;/code&gt;, 这两个是&lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;队列, 分别与&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;类似; 还有一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt;, 是一个优先级队列, 可以按照元素的自然顺序来排列, 也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;来排列(如果它们实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;方法); 最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现是&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;, 实际上它不是一个真正的队列, 因为它不会为队列中元素维护存储空间, 与其他队列不同的是, 它维护一组线程,
这些线程在等待这把元素加入或移出队列, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;没有存储功能, 因此&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;会一直阻塞, 直到有另一个线程已经准备好参与到交付过程中, 仅当有足够多的消费者, 并且总是有一个消费者准备好获取交付工作时, 才适合使用同步队列&lt;/p&gt;

&lt;p&gt;这里再提一下&lt;strong&gt;双端队列&lt;/strong&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Deque&lt;/code&gt;(可以在队列头和队列尾高效插入和移除), 具体实现包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingDeque&lt;/code&gt;; 双端队列适用于工作密取, 即每个消费者都有自己的双端队列, 如果一个消费者完成了自己双端队列的全部工作, 那么它可以从其他消费者双端队列末尾秘密的获取工作(因为可以首尾插入和获取, 所以互不影响)&lt;/p&gt;

&lt;h3 id=&quot;42-闭锁&quot;&gt;4.2 闭锁&lt;/h3&gt;

&lt;h4 id=&quot;421-countdownlatch&quot;&gt;4.2.1 CountDownLatch&lt;/h4&gt;

&lt;p&gt;作用: 可以延迟线程的进度直到其到达终止状态; 闭锁的作用相当于一扇门: 在闭锁到达结束状态之前, 这扇门一直是关闭的, 并且没有任何线程能通过, 当到达结束状态时, 这扇门会打开并允许所有的线程通过; 当闭锁到达结束状态后, 将不再改变状态, 因此这扇门永远保持打开状态; 闭锁可以用来确保某些活动直到其他活动都完成后才继续进行(可以使一个或多个线程等待一组事件发生)&lt;/p&gt;

&lt;p&gt;闭锁状态包括一个计数器, 该计数器被初始化为一个正数, 表示需要等待的事件数量, &lt;code class=&quot;highlighter-rouge&quot;&gt;countDown&lt;/code&gt;递减计数器 , 表示有一个事件已经发生了, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法等待计数器达到零, 这表示所有需要等待的事件都已发生; 如果计数器值非零, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;会一直阻塞直到计数器为零, 或者等待中的线程中断, 或者等待超时&lt;/p&gt;

&lt;p&gt;用法参见下列程序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class LatchTest {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i &amp;lt; nThreads; i++) {
            Thread t = new Thread(() -&amp;gt; {
                try {
                    startGate.await(); // 等待所有线程准备完毕
                    task.run();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    endGate.countDown();
                }
            });
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown(); // 执行到这里, 说明所有线程准备好了, 可以开始执行了
        endGate.await(); // 主线程等待任务执行完毕
        long end = System.nanoTime();
        return end - start;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;422-futuretask&quot;&gt;4.2.2 FutureTask&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FutureTask&lt;/code&gt;也可以用作闭锁, 相当于一种可生成结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future.get()&lt;/code&gt;: 如果任务已经完成, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;会立即返回结果, 否则&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;将阻塞直到任务进入完成状态, 然后返回结果或者抛出异常&lt;/p&gt;

&lt;p&gt;基本使用参见如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FutureTest {
    private final FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;String&amp;gt;(new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            // 耗时操作
            return &quot;Hello&quot;;
        }
    });

    private final Thread thread = new Thread(futureTask);

    public void start() { // 不要在构造函数中构造和start线程: 参见上文安全发布
        thread.start();
    }

    public String get() throws ExecutionException, InterruptedException {
        return futureTask.get(); // 阻塞直到结束或者异常
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-信号量-semaphore&quot;&gt;4.3 信号量-Semaphore&lt;/h3&gt;

&lt;p&gt;计数信号量用来控制同时访问某个特定资源的操作数量, 或者同时执行某个指定操作的数量&lt;/p&gt;

&lt;p&gt;计算信号量的一种就简化形式是二值信号量, 即初始值为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;, 二值信号量可以用作互斥体, 并具备不可重入的加锁语义: 谁拥有这个唯一的许可, 谁就拥有了互斥锁&lt;/p&gt;

&lt;p&gt;使用信号量实现有界阻塞容器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BoundedHashSet&amp;lt;T&amp;gt; {
    private final Set&amp;lt;T&amp;gt; set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        set = Collections.synchronizedSet(new HashSet&amp;lt;T&amp;gt;());
        sem = new Semaphore(bound);
    }

    public boolean add(T t) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(t);
            return wasAdded;
        } finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(T o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;44-栅栏-barrier&quot;&gt;4.4 栅栏-Barrier&lt;/h3&gt;

&lt;p&gt;栅栏类似于闭锁, 它能阻塞一组线程直到某个事件发生, 栅栏与闭锁的关键区别在于, 所有线程必须同时到达栅栏位置, 才能继续执行, 闭锁用于等待事件, 而栅栏用于等待其他线程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;可以使一定数量的参与方反复的在栅栏位置汇集, 它在并行迭代算法中非常有用; 当线程到达栅栏位置时将调用&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法, 这个方法将阻塞直到所有线程都到达栅栏位置; 如果所有线程都到达了栅栏位置, 那么栅栏将打开, 此时所有线程都被释放, 而栅栏将被重置以便下次使用; 如果对&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用超时, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;阻塞的线程被中断, 那么栅栏就被认为是打破了, 所有阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用都将终止并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;BrokenBarrierException&lt;/code&gt;; 如果成功通过栅栏, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;将为每个线程返回一个唯一到达索引号;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;还可以使你将一个栅栏操作传递给构造函数, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 当成功通过栅栏时会(在一个子任务线程中)执行它, 但在阻塞线程被释放之前是不能执行的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-遗留&quot;&gt;五. 遗留&lt;/h2&gt;

&lt;p&gt;Vector, Hashtable, CopyOnWriteArrayList(写入时复制: Copy-On-Write), CopyOnWriteArraySet, BlockingQueue, ConcurrentLinkedQueue, PriorityQueue
Deque: ArrayDeque, LinkedBlockingDeque&lt;/p&gt;

&lt;p&gt;三个interrupt()理解&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>编译器笔记与实验记录</title>
        <description>&lt;h1 id=&quot;序言&quot;&gt;序言&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;编译器,教程: http://mooc.study.163.com/learn/1000002001?tid=1000003000#/learn/content?type=detail&amp;amp;id=1000023001&amp;amp;cid=1000019000&lt;/li&gt;
  &lt;li&gt;配套网站: http://staff.ustc.edu.cn/~bjhua/courses/compiler/2014/&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-编译器介绍&quot;&gt;一. 编译器介绍&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;概念: 编译器是一个程序,核心功能是把源程序代码翻译成为目标代码&lt;/li&gt;
  &lt;li&gt;编译器核心功能如下图: 其中&lt;strong&gt;静态计算&lt;/strong&gt;表示的是经过编译器后, 目标程序和源程序的功能需要相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/编译器核心功能.png&quot; alt=&quot;编译器核心功能&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解释器: 也是处理程序的一种程序;(解释器是在线的方式,也就是说解释器解释程序之后实际上还会执行该程序,而编译器只是生成可执行文件,称为离线形式, 编译器输出为可执行程序, 而解释器输出为程序执行结果)&lt;/li&gt;
  &lt;li&gt;结构: 前端–&amp;gt;代码优化–&amp;gt;后端; 词法分析–&amp;gt;语法分析–&amp;gt;语义分析–&amp;gt;代码生成; (流水线模式)&lt;/li&gt;
  &lt;li&gt;编译器结构: 如下图(一个没有优化的编译器结构)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/一个没有优化的编译器结构.png&quot; alt=&quot;一个没有优化的编译器&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;栈式计算机: 如:JVM&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-词法分析&quot;&gt;二. 词法分析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;编译器可以分为一个前端和后端, 前端又可细分为如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/前端.png&quot; alt=&quot;前端&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作用: 字符流–&amp;gt;词法分析–&amp;gt;记号流; (字符,关键字的切分等)&lt;/li&gt;
  &lt;li&gt;记号流: 编译器内部定义的数据结构, 编码所识别出的词法单元; 如下是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言实现的记号流的数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/记号流的数据结构.png&quot; alt=&quot;记号流&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析的实现方法:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;手工编码实现方法: 是目前非常流行的实现方法,如:GCC,LLVM&lt;/li&gt;
        &lt;li&gt;词法分析器的自动生成器: 可以快速成型,但是难以控制细节&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;手工分析法: 转移图(实际上有点类似状态转移,需要注意的是有的地方需要回滚(回滚的实现: 一个可以通过文件指针的回退,另一个是可以将文件内容读取到一个字符数组中,然后需要回退时将索引减一即可))&lt;/li&gt;
  &lt;li&gt;关键字表算法: 对给定语言的所有关键字构造一个Hash表,也就是对所有的标识符和关键字,先统一按标识符的转移图进行识别,识别完成后,再进一步查表看是否是关键字(关键字的完美Hash表: 完美哈希函数是没有冲突的的哈希函数，也就是，函数 H 将 N 个 KEY 值映射到 M 个整数上，这里 M&amp;gt;=N ，而且，对于任意的 KEY1 ，KEY2 ，H( KEY1 ) != H( KEY2 ) ，并且，如果 M = = N ，则 H 是最小完美哈希函数（Minimal Perfect Hash Function，简称MPHF)&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-gperf.html&quot;&gt;参考博文&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;自动生成法(生成器): 通过一些转换工具,如: lex,flex,jlex等将正则表达式转换为词法分析器; 需要用到:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;正则&lt;/li&gt;
        &lt;li&gt;有限状态自动机: 输入的串是否能被状态机接受(DFA(确定的),NFA(不确定的))&lt;/li&gt;
        &lt;li&gt;正则表达式到&lt;code class=&quot;highlighter-rouge&quot;&gt;NFA&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Thompson&lt;/code&gt;算法,从&lt;code class=&quot;highlighter-rouge&quot;&gt;NFA&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;DFA&lt;/code&gt;是子集构造算法,从DFA到词法分析器是Hopcraft最小化算法&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;DFA: 确定状态有限自动机(只有一个状态)(词法分析器是一个DFA); NFA: 非确定有限状态自动机(有多个状态)&lt;/li&gt;
  &lt;li&gt;正则表达式转换为词法分析器:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/正则表达式转换为词法分析器.png&quot; alt=&quot;正则表达式转换为词法分析器&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA最小化算法: Hopcroft算法&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-语法分析&quot;&gt;三. 语法分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语法分析器: 判断程序是否符合语法规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/语法分析器的作用.png&quot; alt=&quot;语法分析器的作用&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;语法分析的数据工具: 上下文无关文法(乔姆斯基文法体系: 为研究自然语言提供的一系列数学工具)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 28 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/28/Compiler/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/28/Compiler/</guid>
        
        <category>Compiler</category>
        
        
      </item>
    
      <item>
        <title>数字图像处理</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;数字图像处理笔记&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以使用Utrapdit软件查看图片的ASIIC值(可以看任何文件的ASIIC值)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一-第一讲-数字图像处理概述&quot;&gt;一. 第一讲 数字图像处理概述&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;图形和图像的区别:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;图形: 一条指令; 比如一条直线的表示&lt;/li&gt;
    &lt;li&gt;图像: 大矩阵, 里面的数据是每一点的颜色值&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;宽高相乘就是图像的像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图像空间分辨率和灰度级分辨率(表用多少位表示)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jpg是压缩格式; 网上的视屏也是经过压缩后传输再解压缩播放的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-第二讲-图像存储格式&quot;&gt;二. 第二讲 图像存储格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单色图像(黑白图像): 一位;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8位索引图像: 有一个颜色表和一个像颜色表的序号的数据矩阵&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;8位索引灰度图像: 颜色表中的RGB相等&lt;/li&gt;
    &lt;li&gt;8位伪彩色索引图像: 颜色表中的RGB值不等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;彩色图像: 分为伪彩色和真彩色(每个像素24位, RGB各占8位);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BMP, GIF, TIF, JPEG&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;GIF: 主要用于不同平台上交流和传输, 而不是作为文件的存储格式&lt;/li&gt;
        &lt;li&gt;TIF: 最复杂&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-第三讲-bmp位图文件的存储格式&quot;&gt;三. 第三讲 BMP位图文件的存储格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;BMP文件组成:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;位图文件头结构: BITMAPFILEHEADER&lt;/li&gt;
    &lt;li&gt;位图信息头结构: BITMAPINFOHEADER&lt;/li&gt;
    &lt;li&gt;位图颜色表: RGBQUAD(有的可能没有颜色表, 具体有没有, 参见第二讲)&lt;/li&gt;
    &lt;li&gt;位图像素数据&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;BMP文件头: 14个字节&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagBITMAPFILEHEADER
{
    WORD bfType; // BM: BMP文件标识(前两个字节), 一个字节是B, 一个字节是M
    DWORD bfSize; // 文件大小
    WORD bfReserved1; // 0
    WORD bfReserved2; // 0
    DWORD bfOffBits; // 位图数据的起始位置
} BITMAPFILEHEDADER; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;BMP信息头结构: 40个字节&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagBITMAPINFOHEADER
{
    DWORD biSize; // 本结构的大小: 40个字节
    LONG biWidth; // 位图宽度, 像素为单位
    LONG biHeight; // 位图高度, 像素为单位
    WORD biPlanes; // 位平面数, 是标准的一般是1
    WORD biBitCount; // 每个像素所需的位数
    DWORD biCompression; // 位图压缩类型: BMP位图一般不压缩, 取0
    DWORD biSizeImage; // 位图大小
    LONG biXpelsPerMeter; // 水平分辨率(像素点/米)
    LONG biYPelsPerMeter; // 垂直分辨率(像素点/米)
    DWORD biCIrUsed; // 颜色数: 如果是标准颜色, 如16, 24, 256等位颜色, 则是0; 如果是自己定义, 则需要将颜色数写在这
    DWORD biCIrImportant; // 重要的颜色数
} BITMAPINFOHEADER;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;颜色表:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagRGBQUAD 
{
    BYTE rgbBlue; // 蓝色
    BYTE rgbGreen; // 绿色
    BYTE rgbRed; // 红色
    BYTE rgbReserved; // 保留字节; 0
} RGBQUAD;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;位图信息 – BITMAPINFO结构: 图像显示时作为参数传入函数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1]; // 颜色表(上的第一项)
} BITMAPINFO;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-几何变换基础&quot;&gt;四. 几何变换基础&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解平移, 缩放, 旋转, 镜像等的矩阵和原理&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 22 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</guid>
        
        <category>数字图像处理</category>
        
        
      </item>
    
      <item>
        <title>OpenGL笔记</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;阅读OpenGL中文文档笔记&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-入门&quot;&gt;一. &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;入门&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;11-opengl&quot;&gt;1.1 OpenGL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是OpenGL: 并不是API, 而是一个规范; OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定; OpenGL基于显卡, 所以OpenGL API大多由显卡厂商提供&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心模式与立即渲染模式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;立即渲染模式(固定渲染管线): 用于早期OpenGL; 封装性好, 使用方便, 但是效率低, 灵活性不够&lt;/li&gt;
    &lt;li&gt;核心模式: 从OpenGL3.2开始, 规范文档开始废弃立即渲染模式; 当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;状态机: OpenGL状态通常被成为OpenGL上下文; OpenGL本质上是一个大状态机(理解状态函数和状态使用函数)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-hello-window&quot;&gt;1.2 Hello Window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;视口: ViewPort; OpenGL渲染窗口的尺寸大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双缓冲: 应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-hello-三角形&quot;&gt;1.3 Hello 三角形&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图形渲染管线: 又称为管线; 指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程;  在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素; 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的; 图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器: 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器; 而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如下为每个图形渲染管线的抽象展示; 其中蓝色部分是可以注入自定义着色器的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/图形渲染管线.png&quot; alt=&quot;图形渲染管线&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图元(Primitive): 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点着色器(Vertex Shader): 顶点着色器主要的目的是把3D坐标转为另一种3D坐标, 同时顶点着色器允许我们对顶点属性进行一些基本处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图元装配(Primitive Assembly): 将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状; 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;光栅化阶段: 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片段着色器: 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准化设备坐标: 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/标准化设备坐标.png&quot; alt=&quot;标准化设备坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;深度: 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器程序: 着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;glVertexAttribPointer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/glVertexAttribPointer.png&quot; alt=&quot;glVertexAttribPointer&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-glsl&quot;&gt;1.4 GLSL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GLSL基本数据类型: int, float, double, uint, bool&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容器类型: Vector, Matrix&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Uniform: Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-纹理&quot;&gt;1.5 纹理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理: 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采样: 使用纹理坐标获取纹理颜色叫做采样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理坐标.png&quot; alt=&quot;纹理坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;纹理环绕方式: 纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理环绕方式.png&quot; alt=&quot;纹理环绕方式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理过滤: 纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标(Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色); 纹理过滤主要有两种: GL_NEAREST和GL_LINEAR; 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项(使用glTexParameteri())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;邻近过滤(GL_NEAREST): 默认纹理过滤方式; 当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性过滤(GL_LINEAR): 会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大(GL_LINEAR可以产生更真实的输出)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多级渐远纹理: 简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一; 多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好(glGenerateMipmaps())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理单元: 一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元; 纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-变换&quot;&gt;1.5 变换&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向量: 有大小和方向; 其实就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;N*1&lt;/code&gt;的矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量运算:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/向量与标量运算.png&quot; alt=&quot;向量与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量取反: 个分量都取反&lt;/li&gt;
    &lt;li&gt;向量之间加减: 各分量之间对应加减&lt;/li&gt;
    &lt;li&gt;向量乘积&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;点乘: 点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘.png&quot; alt=&quot;点乘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘2.png&quot; alt=&quot;点乘2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;叉乘:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/叉乘.png&quot; alt=&quot;叉乘&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;矩阵运算&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与标量运算.png&quot; alt=&quot;矩阵与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵之间加减: 对应项加减即可&lt;/li&gt;
    &lt;li&gt;矩阵数乘: 将该数和矩阵每一项想乘&lt;/li&gt;
    &lt;li&gt;矩阵相乘: 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘; 矩阵相乘不遵守交换律&lt;/li&gt;
    &lt;li&gt;矩阵与向量相乘:&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;缩放:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之缩放.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;位移:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之位移.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿x轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿x轴旋转.png&quot; alt=&quot;沿x轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿y轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿y轴旋转.png&quot; alt=&quot;沿y轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿z轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿z轴旋转.png&quot; alt=&quot;沿z轴旋转&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;16-坐标系统&quot;&gt;1.6 坐标系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对我们来说比较重要的有五类坐标系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;局部空间(Local Space，或者称为物体空间(Object Space))&lt;/li&gt;
    &lt;li&gt;世界空间(World Space)&lt;/li&gt;
    &lt;li&gt;观察空间(View Space，或者称为视觉空间(Eye Space))&lt;/li&gt;
    &lt;li&gt;裁剪空间(Clip Space)&lt;/li&gt;
    &lt;li&gt;屏幕空间(Screen Space)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/坐标系统.png&quot; alt=&quot;坐标系统&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;局部空间: 物体所在的坐标空间，即对象最开始所在的地方&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界空间: 物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;观察空间: 观察空间经常被人们称之OpenGL的摄像机(Camera); 观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果; 因此观察空间就是从摄像机的视角所观察到的空间; 这通常用一个观察矩阵(View Matrix)完成，它被用来将世界坐标变换到观察空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;裁剪空间:  在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来; 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection
Matrix)，它指定了一个范围的坐标(如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围)(一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;透视投影: 离你越远的东西看起来更小; 使用透视投影矩阵来完成的; 一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上, 即将顶点坐标中的每个分量除以w分量; 透视投影如下图; 位于视景体之内的物体被投影到金字塔的顶点, 也就是照相机或观察点的位置; 靠近观察点的物体看上去更大一些, 因为和远处的物体相比, 它占据了视景体中相对较大的区域(实际上从相机(观察点)的角度看顶面和底面, 其占据的空间大小相同, 都是视口大小); 平截头体的四个侧面, 顶面和底面对应与视景体的6个裁剪平面, 位于这些平面之外的物体将被裁剪掉, 不会出现在最终的图像中;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/透视投影.png&quot; alt=&quot;透视投影&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个顶点坐标会根据以下过程被变换到裁剪坐标(注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法)): 最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/裁剪坐标.png&quot; alt=&quot;裁剪坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Z缓冲(深度缓冲): 深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视景体 : 管线会确定的一个可视空间区域, 由 上平面(up), 下平面(down), 左平面(left), 右平面(right), 远平面(far), 近平面(near) 六个平面组成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视景体与投影 : 视景体内的物体会投影到近平面, 视景体之外的内容会被裁减掉, 例如眼睛看不到的范围就是处于视景体外即被裁减掉的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;17-摄像机&quot;&gt;1.7 摄像机&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-光照&quot;&gt;二. 光照&lt;/h2&gt;

&lt;h3 id=&quot;21-颜色&quot;&gt;2.1 颜色&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;物体的颜色为物体从一个光源反射各个颜色分量的大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;物体的颜色是其和光源颜色的向量乘积&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/颜色.png&quot; alt=&quot;颜色&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-基础光照&quot;&gt;2.2 基础光照&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;冯氏光照模型(Phong Lighting Model): 冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/冯氏光照模型.png&quot; alt=&quot;冯氏光照模型&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个十分常见的错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏; 如下图; 修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵(Normal Matrix)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/缩放导致法向量破坏.png&quot; alt=&quot;缩放导致法向量破坏&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-材质&quot;&gt;2.3 材质&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在现实世界里，每个物体会对光产生不同的反应; 有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义一个材质(Material)属性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以用这三个分量来定义一个材质颜色(Material Color)：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting), 再添加一个反光度(Shininess), 就能够对物体的颜色输出有着精细的控制了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们为每个冯氏光照模型的分量都定义一个颜色向量。ambient材质向量定义了在环境光照下这个物体反射得是什么颜色，通常这是和物体颜色相同的颜色。diffuse材质向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要设置为我们需要的物体颜色。specular材质向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，shininess影响镜面高光的散射/半径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体材质的该四个分量可以参见: http://devernay.free.fr/cours/opengl/materials.html&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射。光源对环境光、漫反射和镜面光分量也具有着不同的强度&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-光照贴图&quot;&gt;2.4 光照贴图&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;漫反射贴图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;镜面光贴图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;25-投光物&quot;&gt;2.5 投光物&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;平行光: 当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点光源: 定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源(Point Light)。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;聚光: 聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</guid>
        
        <category>OpenGL</category>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Activity生命周期</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期讲解&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;本文将分析和总结各种情况下, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的生命周期情况, 包括正常情况下, 异常情况下(如: 用户屏幕旋转, 资源分配不足等)以及特殊情况下(如: 当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;上覆盖对话框或者透明&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 当按下&lt;code class=&quot;highlighter-rouge&quot;&gt;Home&lt;/code&gt;键回到桌面时, 当屏幕熄灭时)&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期的调用情况; 同时还将简述各个方法下适于做什么工作等&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-正常情况&quot;&gt;二. 正常情况&lt;/h2&gt;

&lt;h3 id=&quot;21-单独的activity分析&quot;&gt;2.1 单独的Activity分析&lt;/h3&gt;

&lt;p&gt;如下为一张典型的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期图(摘自官方文档); 也是正常情况下, 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的经历&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Activity/Activity生命周期.png&quot; alt=&quot;Activity生命周期&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;记忆的时候可以通过两两配对来记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面将结合上图讲解各个状态:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;: 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;启动时只调用一次, 表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;创建; 可以进行一些数据绑定, 类变量初始化或者上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;恢复等工作(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;savedInstanceState&lt;/code&gt;实现)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onStart()&lt;/code&gt;: 可见, 处于后台, 不能交互&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;: 可见, 处于前台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;: 时间短暂, 处于后台; 如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;的时候再快速的回到当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume&lt;/code&gt;会被调用(一般用户操作很难实现这一场景); 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android7.0&lt;/code&gt;或者更高, 应用可以在多窗口模式下运行, 但是只要每个时刻只有一个应用可以得到焦点, 那么此时就需要暂停另一个应用(处于&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;状态); (一个处于onPause状态的Activity可能仍然是完全可见的, 比如说在多窗口模式下); 不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;执行数据保存工作, 因为该阶段非常短暂, 同时只有&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;执行完,
新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;才会执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop()&lt;/code&gt;: 不可见, 可以执行一些稍微重量级的工作, 比如资源释放与数据保存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy()&lt;/code&gt;: 表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁, 可以做一些最终的回收工作和资源释放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestart()&lt;/code&gt;: 表示当当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;从不可见重新变为可见状态时调用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-activity启动新activity分析&quot;&gt;2.2 Activity启动新Activity分析&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里以Activity A正常启动Activity B的情况分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;启动&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;的时候, 会依次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;A.onPause()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onCreate()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onStart()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onResume()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;A.onStop()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看出, 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;方法执行完成之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;的一系列方法才会调用; 这也说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;方法中不能执行耗时操作, 因为新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;是在其之后执行的, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;中执行太耗时的操作的话, 会影响新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的显示; 我们应当尽量在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop()&lt;/code&gt;中操作, 使新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;尽快显示出来并出现在前台&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-异常情况&quot;&gt;三. 异常情况&lt;/h2&gt;

&lt;h3 id=&quot;31-资源相关系统配置改变导致activity被杀死并重新创建&quot;&gt;3.1 资源相关系统配置改变导致Activity被杀死并重新创建&lt;/h3&gt;

&lt;p&gt;默认情况下, 如果不做特殊处理, 当系统配置发生改变之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;就会被杀死并重建; 比如: 当手机进行横竖屏切换的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;默认就会被销毁重建&lt;/p&gt;

&lt;p&gt;在这种情况下, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;会依次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStart&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onResume&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是这里和正常情况下不同的是, 需要等到&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁之后才能开始重新创建; 另一个就是, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁的时候, 会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;来保存当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的状态, 该方法的调用在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;之前, 但是和&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;没有既定的时序关系; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;的调用确是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStart&lt;/code&gt;之后, 有既定的时序关系;&lt;/p&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁重建保存数据的方法是: 委托下级子元素调用其自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;来保存自己的状态和数据; 即让其关联&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;保存数据, &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;再委托子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行数据保存, 最终会调用每个子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onSaveInstanceState()&lt;/code&gt;来保存自己的数据&lt;/p&gt;

&lt;p&gt;当进行数据恢复的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle savedInstanceState&lt;/code&gt;参数不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 可以在此处进行数据恢复, 但是推荐在&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;中进行数据恢复&lt;/p&gt;

&lt;h3 id=&quot;32-资源内存不足导致低优先级activity被杀死&quot;&gt;3.2 资源内存不足导致低优先级Activity被杀死&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;优先级:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;前台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 正在和用户交互的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 优先级最高&lt;/li&gt;
    &lt;li&gt;可见但非前台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中弹出了一个对话框, 导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可见但是位于后台, 无法与用户直接交互&lt;/li&gt;
    &lt;li&gt;后台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 已经被暂停的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 比如执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;, 优先级最低&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;被杀死的可能性如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Activity/系统杀死Activity.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-特殊情况&quot;&gt;四. 特殊情况&lt;/h2&gt;

&lt;h3 id=&quot;41-按下home键或者当屏幕熄灭&quot;&gt;4.1 按下Home键或者当屏幕熄灭&lt;/h3&gt;

&lt;p&gt;这种情况下会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;; 需要注意的是这里仍然调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;; 但是该情况下是不会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;, 原因下面说明&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;调用的几点说明:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;的调用: &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;会在当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;有可能被销毁的时候调用, 用于进行数据保存; 注意, 只要是&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;有可能被销毁都会调用方法; 比如: 按下&lt;code class=&quot;highlighter-rouge&quot;&gt;Home&lt;/code&gt;键或者屏幕熄灭&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;进行后台的时候, 该&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可能被回收, 所以此时会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;的调用和&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;的调用不一定是成对的, &lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;要调用的前提是当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;&lt;strong&gt;确实&lt;/strong&gt;被系统销毁了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;42-透明对话框或者透明activity&quot;&gt;4.2 透明对话框或者透明Activity&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;上覆盖一层透明对话框的时候, 不会使&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;进入后台(不会调用任何方法), 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;不可和当前用户交互&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;启动一个透明&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的时候, 会调用前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;, 但是不会调用前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;, 此时前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可见但是处于后台&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-注&quot;&gt;五. 注&lt;/h2&gt;

&lt;p&gt;验证代码参见: &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/lifecycle/ReadMe.md&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/13/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/13/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>排序算法</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;排序算法总结, 分析各种排序算法的时间复杂度, 空间复杂度, 使用场景和优化等方面&lt;/p&gt;

&lt;p&gt;包括: 选择排序, 归并排序, 插入排序, 冒泡排序, 快排, 堆排, 基数排序, 希尔排序, 计数排序, 桶排序&lt;/p&gt;

&lt;p&gt;文中代码使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;实现, &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;实现可以参见: https://github.com/HusterYP/DataStructure&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-选择排序&quot;&gt;一. 选择排序&lt;/h2&gt;

&lt;h3 id=&quot;11-基本思路&quot;&gt;1.1 基本思路&lt;/h3&gt;

&lt;p&gt;找到数组中的最小元素, 将它和数组的第一个元素交换, 然后在剩下元素中找到最小元素和数组第二个元素交换, 如此往复, 直到有序&lt;/p&gt;

&lt;h3 id=&quot;12-主要代码&quot;&gt;1.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0) // 边界条件
            return;
        int N = noSort.length;
        for (int i = 0; i &amp;lt; N; i++) {
            int min = i;
            for (int j = i + 1; j &amp;lt; N; j++) {
                if (Utils.less(noSort[min], noSort[j]) &amp;lt; 0) // 注意此处比较条件, 不要写成noSort[i]和noSort[j]比较了
                    min = j;
            }
            Utils.exch(noSort, i, min);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-特点&quot;&gt;1.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;; 需要进行&lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)+(N-2)+...+1 = (N-1)*N/2&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;次交换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界时间&lt;/strong&gt;: 选择排序的最好情况与最坏情况时间相同, 同其时间复杂度分析(也可以说没有最好最坏情况)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 需要一个临时变量&lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定的; 如&lt;code class=&quot;highlighter-rouge&quot;&gt;[5, 5, 2]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-插入排序&quot;&gt;二. 插入排序&lt;/h2&gt;

&lt;h3 id=&quot;21-基本思路&quot;&gt;2.1 基本思路&lt;/h3&gt;

&lt;p&gt;从第一个元素开始, 该元素可认为已经被排序, 取出下一个元素, 在已排序元素序列中从后往前开始扫描, 插入到相应位置&lt;/p&gt;

&lt;h3 id=&quot;22-主要代码&quot;&gt;2.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        for (int i = 1; i &amp;lt; N; i++) {
            int index = i;
            while (index &amp;gt; 0 &amp;amp;&amp;amp; Utils.less(noSort[index], noSort[index - 1])) {
                Utils.exch(noSort, index, index - 1);
                index--;
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-特点&quot;&gt;2.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;; 平均情况下需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 4&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 4&lt;/code&gt;次交换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界情况&lt;/strong&gt;: 最好情况是, 所有数据有序, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N-1&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;次交换; 最坏情况是所有数据逆序有序, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 2&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 2&lt;/code&gt;次交换(注意, 其实平均情况就是最坏情况对半, 因为每个位置每个元素出现几率相同)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用情况&lt;/strong&gt;: 对于部分有序的数组, 插入排序的效率很高; 部分有序数组:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;数组中每个元素距离它的最终位置都不远&lt;/li&gt;
    &lt;li&gt;一个有序的大数组接一个小数组&lt;/li&gt;
    &lt;li&gt;数组中只有几个元素的位置不正确&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-希尔排序&quot;&gt;三. 希尔排序&lt;/h2&gt;

&lt;p&gt;插入排序的改进&lt;/p&gt;

&lt;h3 id=&quot;31-基本思路&quot;&gt;3.1 基本思路&lt;/h3&gt;

&lt;p&gt;使数组中任意间隔为&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的数组都是有序的, 称为&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;有序数组; 类似插入排序, 但使用不同增量, 因为在插入排序中讲解适用性的时候说过, 插入排序在用于小数组的时候(可以理解为部分有序数组的第一种情况)很有效, 希尔排序就是将一个大数组按照&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;间隔分为许多小数组, 然后分别对这些小数组进行插入排序, 部分有序之后对整体进行插入排序(&lt;code class=&quot;highlighter-rouge&quot;&gt;h=1&lt;/code&gt;), 此时即有序; 而这两种情况都适用于插入排序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的选择, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2*(3^k-1)&lt;/code&gt;, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;N/3&lt;/code&gt;递减至&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int h = 1;
while(h &amp;lt; N/3)
    h = h * 3 + 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-基本代码&quot;&gt;3.2 基本代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        int h = 1;
        while (h &amp;lt; N / 3)
            h = h * 3 + 1;
        while (h &amp;gt;= 1) {
            for (int i = h; i &amp;lt; N; i++) {
                for (int j = i; j &amp;gt;= h &amp;amp;&amp;amp; Utils.less(noSort[j], noSort[j - h]); j -= h)
                    Utils.exch(noSort, j, j - h);
            }
            h = h / 3;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-特点&quot;&gt;3.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: 优于插入排序; 取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的取值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用情况&lt;/strong&gt;: 希尔排序也可以用于大数组, 对任意排序(不一定是随机的)的数组表现也很好; 可以先考虑使用希尔排序, 然后再考虑是否值得将它替换为更加复杂的排序算法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-冒泡排序&quot;&gt;四. 冒泡排序&lt;/h2&gt;

&lt;h3 id=&quot;41-基本思路&quot;&gt;4.1 基本思路&lt;/h3&gt;

&lt;p&gt;比较相邻元素, 如果第一个比第二个大, 就交换他们两个, 遍历所有元素, 一趟之后, 最后一个元素为最大元素; 对剩余元素重复该步骤(除了最后一个)&lt;/p&gt;

&lt;h3 id=&quot;42-主要代码&quot;&gt;4.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        for (int i = N; i &amp;gt; 0; i--) {
            for (int j = 0; j &amp;lt; i - 1; j++) {
                if (Utils.less(noSort[j + 1], noSort[j]))
                    Utils.exch(noSort, j, j + 1);
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-特点&quot;&gt;4.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;改进&lt;/strong&gt;: 添加标志位, 如果一趟遍历中没有交换, 说明已经有序, 直接退出即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        boolean isChange = true;
        for (int i = N; i &amp;gt; 0 &amp;amp;&amp;amp; isChange; i--) {
            isChange = false;
            for (int j = 0; j &amp;lt; i - 1; j++) {
                if (Utils.less(noSort[j + 1], noSort[j])) {
                    Utils.exch(noSort, j, j + 1);
                    isChange = true;
                }
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-归并排序&quot;&gt;五. 归并排序&lt;/h2&gt;

&lt;h3 id=&quot;51-基本思路&quot;&gt;5.1 基本思路&lt;/h3&gt;

&lt;p&gt;递归排序, 先将一个数组分成两半分别排序, 然后将结果归并起来&lt;/p&gt;

&lt;h3 id=&quot;52-主要代码&quot;&gt;5.2 主要代码&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;自顶向下的归并排序:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MergeSort {
    private static int[] aux; // 辅助数组

    public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        aux = new int[noSort.length];
        sort(noSort, 0, noSort.length - 1);
    }

    public static void sort(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int mid = low + (high - low) / 2;
        sort(noSort, low, mid); // 将左半边数组排序
        sort(noSort, mid + 1, high); // 将右半边数组排序
        merge(noSort, low, mid, high); // 将数组归并
    }

    public static void merge(int[] noSort, int low, int mid, int high) {
        int i = low;
        int j = mid + 1;
        for (int k = low; k &amp;lt;= high; k++) {
            aux[k] = noSort[k];
        }

        for (int k = low; k &amp;lt;= high; k++) {
            if (i &amp;gt; mid)
                noSort[k] = aux[j++]; // 如果左边用完
            else if (j &amp;gt; high)
                noSort[k] = aux[i++]; // 如果右边用完
            else if (Utils.less(aux[j], aux[i]))
                noSort[k] = aux[j++];
            else
                noSort[k] = aux[i++];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自底向下的归并排序:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sortBU(int[] noSort) {
        int N = noSort.length;
        aux = new int[N];
        for (int sz = 1; sz &amp;lt; N; sz = sz + sz) {
            for (int low = 0; low &amp;lt; N - sz; low += sz + sz)
                merge(noSort, low, low + sz - 1, Math.min(low + sz + sz - 1, N - 1));
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;53-特点&quot;&gt;5.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;; 归并排序是一种渐进最优的基于比较的排序算法; 能够保证&lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;的时间复杂度(即最坏情况最好情况都相同)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: 需要与&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;成正比的额外数组空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;两种归并方式的区别&lt;/strong&gt;: 自底向上的归并方式比较适合用链表组织的数据, 此时只需要重新组织链表链接就能将链表原地排序, 不需要额外空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;54-改进&quot;&gt;5.4 改进&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对小规模子数组使用插入排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试数组是否已经有序: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;noSort[mid] &amp;lt; noSort[mid+1]&lt;/code&gt;说明数组有序, 可以跳过本次&lt;code class=&quot;highlighter-rouge&quot;&gt;merge()&lt;/code&gt;了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不将元素复制到辅助数组: 可以节省将元素复制到辅助数组所用的时间(但是空间不行), 即进行交替归并即可(可以添加一个标志位标识最终结果存储在哪个数组)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-快排&quot;&gt;六. 快排&lt;/h2&gt;

&lt;h3 id=&quot;61-基本思路&quot;&gt;6.1 基本思路&lt;/h3&gt;

&lt;p&gt;对于某个&lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;已经排定, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[low]&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j-1]&lt;/code&gt;中的所有元素都不大于&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[j+1]&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;a[high]&lt;/code&gt;中的所有元素都不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;62-主要代码&quot;&gt;6.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class QuickSort {

    public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        sort(noSort, 0, noSort.length - 1);
    }

    private static void sort(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int j = partition(noSort, low, high);
        sort(noSort, low, j - 1);
        sort(noSort, j + 1, high);
    }

    private static int partition(int[] noSort, int low, int high) {
        int i = low;
        int j = high + 1;
        int temp = noSort[low];
        while (true) {
            while (Utils.less(noSort[++i], temp))
                if (i == high)
                    break;
            while (Utils.less(temp, noSort[--j]))
                if (j == low)
                    break;
            if (i &amp;gt;= j)
                break;
            Utils.exch(noSort, i, j);
        }
        Utils.exch(noSort, low, j);
        return j;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;63-特点&quot;&gt;6.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;; 比归并和希尔排序都快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界情况&lt;/strong&gt;: 依赖于切分情况; 最好情况是每次都能将数组对半分; 最坏情况是第一次从最小元素切分, 第二次第二小元素切分, 如此这般, 每次调用都只能移除一个元素, 造成最坏情况(可以在开始排序之前, 现将待排序数组打乱(&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle()&lt;/code&gt;))&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;logN&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;64-算法改进&quot;&gt;6.4 算法改进&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;小数组时切换到插入排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三取样切分: 使用子数组的一小部分元素的中位数来切分数组, 这样切分更好, 但代价是需要计算中位数; 将取样大小设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;并用大小居中的元素切分的效果更好; 还可以将取样元素放在数组末尾作为&lt;strong&gt;哨兵&lt;/strong&gt;, 这样可以避免临界值判断&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熵最优排序: 当含有大量重复元素的时候, 快排的递归性会使元素全部重复的子元素经常出现, 这就有很大的改进潜力, 将线性对数级的性能提高到线性级别; 一个简单的想法是将数组切分为三部分, 即小于, 等于和大于(荷兰国旗问题); 基本思路是: 维护一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[low..lt-1]&lt;/code&gt;中的元素都小于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;(切分元素), 一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[gt+1..hi]&lt;/code&gt;中的元素都大于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[lt..i-1]&lt;/code&gt;中元素都等于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i..gt-1]&lt;/code&gt;中元素都还未确定, 一开始&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;low&lt;/code&gt;相等:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;小于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;a[lt]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;交换, &lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;加一&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;大于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;a[gt]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;交换, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;减一&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;加一&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;三向切分改进代码如下:&lt;/strong&gt; 三向切分的最坏情况是所有元素都不同; 在包含大量重复元素时, 其能将对数级别的时间降低到线性级别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort3Way(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int lt = low;
        int i = low + 1;
        int gt = high;
        int temp = noSort[low];
        while (i &amp;lt; gt) { // 找出重复元素
            if (noSort[i] &amp;lt; temp)
                Utils.exch(noSort, lt++, i++);
            else if (noSort[i] &amp;gt; temp)
                Utils.exch(noSort, i, gt--);
            else
                i++;
        }
        sort3Way(noSort, low, lt - 1);
        sort3Way(noSort, gt + 1, high);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;七-堆排&quot;&gt;七. 堆排&lt;/h2&gt;

&lt;h3 id=&quot;71-基本思路&quot;&gt;7.1 基本思路&lt;/h3&gt;

&lt;p&gt;堆是一个二叉树的每个节点都大于等于(或小于等于)它的两个子节点; 分为大顶堆和小顶堆&lt;/p&gt;

&lt;h3 id=&quot;72-主要代码&quot;&gt;7.2 主要代码&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F#Java&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class HeapSort {

    public static void sort(int[] arr) {
        /*
         *  第一步：将数组堆化
         *  beginIndex = 第一个非叶子节点。
         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。
         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。
         */
        int len = arr.length - 1;
        int beginIndex = (len - 1) &amp;gt;&amp;gt; 1;
        for (int i = beginIndex; i &amp;gt;= 0; i--) {
            maxHeapify(arr, i, len);
        }

        /*
         * 第二步：对堆化数据排序
         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。
         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。
         * 直至未排序的堆长度为 0。
         */
        for (int i = len; i &amp;gt; 0; i--) {
            Utils.exch(arr, 0, i);
            maxHeapify(arr, 0, i - 1);
        }
    }

    /**
     * 调整索引为 index 处的数据，使其符合堆的特性。
     *
     * @param index 需要堆化处理的数据的索引
     * @param len   未排序的堆（数组）的长度
     */
    private static void maxHeapify(int[] arr, int index, int len) {
        int li = (index &amp;lt;&amp;lt; 1) + 1; // 左子节点索引
        int ri = li + 1;           // 右子节点索引
        int cMax = li;             // 子节点值最大索引，默认左子节点。

        if (li &amp;gt; len) return;       // 左子节点索引超出计算范围，直接返回。
        if (ri &amp;lt;= len &amp;amp;&amp;amp; arr[ri] &amp;gt; arr[li]) // 先判断左右子节点，哪个较大。
            cMax = ri;
        if (arr[cMax] &amp;gt; arr[index]) {
            Utils.exch(arr, cMax, index);
            maxHeapify(arr, cMax, len);  // 则需要继续判断换下后的父节点是否符合堆的特性。
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;73-特点&quot;&gt;7.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: 堆排序是唯一能够同时最优的利用空间和时间的方法, 在最坏情况下它也能保证&lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;的时间复杂度和恒定空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;: 在空间十分紧张(如嵌入式设别或低成本的移动设备中)十分流行, 但是由于其数据变更比较频繁, 因此无法利用缓存(缓存命中率比较低), 在现代系统的许多应用中很少使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用堆还可以实现优先队列, 使得当有大量数据时, 可用较少空间即可从中筛选出指定数量的最大(小)&lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;个数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;八-小结&quot;&gt;八. 小结&lt;/h2&gt;

&lt;p&gt;上面介绍的七个排序算法都是基于&lt;strong&gt;比较&lt;/strong&gt;的, 这里再以表的形式总结如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;排序算法&lt;/th&gt;
      &lt;th&gt;是否稳定&lt;/th&gt;
      &lt;th&gt;是否为原地排序&lt;/th&gt;
      &lt;th&gt;时间复杂度&lt;/th&gt;
      &lt;th&gt;空间复杂度&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;选择排序&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;N^2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;插入排序&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;介于N和N^2之间&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;希尔排序&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;未知(NlogN / N^(5/6) ?)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;快排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;logN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三向快排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;介于N和NlogN之间&lt;/td&gt;
      &lt;td&gt;logN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;归并排序&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;堆排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面要介绍的是线性排序; 有这样一个结论是: 没有任何基于比较的算法能够保证使用少于&lt;code class=&quot;highlighter-rouge&quot;&gt;log(N!) ~ NlogN&lt;/code&gt;次比较将长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;的数组排序; 所以这也决定了上面基于比较的排序算法的上界;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;九-计数排序&quot;&gt;九. 计数排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liyuming0000/article/details/46913357&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;十-基数排序&quot;&gt;十. 基数排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603669.html&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;十一-桶排序&quot;&gt;十一. 桶排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://hxraid.iteye.com/blog/647759&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>Android动画详解</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;动画也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;系统中一个很重要的模块, 在平时开发中, 为了做出炫酷的效果, 动画可以说是必不可少的; 本文将总结&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中与动画相关的部分, 文中部分内容整理自文末参考链接, 权作笔记~&lt;/p&gt;

&lt;p&gt;需要声明的是文章不会详细通过源码去讲解各种动画的实现细节, 因为相对来说, 动画的熟练使用更为重要, 所以本文只是提一下关键的动画源码部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中动画分为三大类: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画, &lt;code class=&quot;highlighter-rouge&quot;&gt;Transition&lt;/code&gt;(过渡动画), 属性动画; 下文也将从这三个方面进行总结和讲解&lt;/p&gt;

&lt;p&gt;动画的本质实际上就是将作用对象的属性值在一段时间内缓慢的改变, 将每一个小的时间片段对应的属性值改变作用到对象并进行不断重绘, 造成肉眼看起来的的动画效果~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-view动画&quot;&gt;二. View动画&lt;/h2&gt;

&lt;h3 id=&quot;21-基本使用总结&quot;&gt;2.1 基本使用总结&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画分为四种, 如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;标签&lt;/th&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;效果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;平移动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;translate&amp;gt;&lt;/td&gt;
      &lt;td&gt;TranslateAnimation&lt;/td&gt;
      &lt;td&gt;移动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;缩放动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;scale&amp;gt;&lt;/td&gt;
      &lt;td&gt;ScaleAnimation&lt;/td&gt;
      &lt;td&gt;缩放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;旋转动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;rotate&amp;gt;&lt;/td&gt;
      &lt;td&gt;RotateAnimation&lt;/td&gt;
      &lt;td&gt;旋转&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;透明度&lt;/td&gt;
      &lt;td&gt;&amp;lt;alpha&amp;gt;&lt;/td&gt;
      &lt;td&gt;AlphaAnimation&lt;/td&gt;
      &lt;td&gt;透明度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 动画中还有一种叫&lt;strong&gt;帧动画&lt;/strong&gt;, 这里也归为&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画中, 后文单独讲解&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;描述, 也可以使用代码描述(即使用上表中的四个子类); 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;描述的语法格式如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;res/anim/filename.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;set&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:interpolator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@[package:]anim/interpolator_resource&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:shareInterpolator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[true | false]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:fillAfter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[true | false]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;int&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:repeatMode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[reverse | restart]&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;alpha&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromAlpha=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toAlpha=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;scale&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromXScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toXScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromYScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toYScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotY=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;translate&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromXDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toXDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromYDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toYDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rotate&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromDegrees=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toDegrees=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotY=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;
        ...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/set&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/set&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;set&amp;gt;&lt;/code&gt;代表&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimationSet&lt;/code&gt;, 可以包含若干动画&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:shareInterpolator&lt;/code&gt;: 表示集合中的动画是否和集合共享同一个插值器; 如果集合不指定插值器, 那么子动画需要单独指定或者使用默认插值器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:pivotX&lt;/code&gt;: 轴点&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;坐标&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:pivotY&lt;/code&gt;: 轴点&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;坐标&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:fillAfter&lt;/code&gt;: 动画结束之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是否停留在结束位置, &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;表示停留在结束位置, &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;表示不停留&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在代码中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Button button = findViewById(R.id.button);
Animatoin animation = AnimationUtils.loadAnimation(this, R.anim.animation_item);
button.startAnimation(animation);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-自定义view动画&quot;&gt;2.2 自定义View动画&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TranslateAnimation&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ScaleAnimation&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RotateAnimation&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;AlphaAnimation&lt;/code&gt;都继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation&lt;/code&gt;; 如果要自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画的话, 也需要继承&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation&lt;/code&gt;, 并重写&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation.initialize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation.applyTransformation()&lt;/code&gt;方法; &lt;code class=&quot;highlighter-rouge&quot;&gt;initialize()&lt;/code&gt;顾名思义就是进行一些初始化工作, 比如设置属性的初始值等, &lt;code class=&quot;highlighter-rouge&quot;&gt;applyTransformation()&lt;/code&gt;就是根据时间的流失量来计算出当前时间片段所对应的属性值, 并设置到对应的作用对象(对于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画来说该对象就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;); 这里的设置往往是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix&lt;/code&gt;来作用的, 如下以&lt;code class=&quot;highlighter-rouge&quot;&gt;TranslateAnimation.applyTransformation()&lt;/code&gt;为例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
        float dx = mFromXDelta;
        float dy = mFromYDelta;
        if (mFromXDelta != mToXDelta) {
            dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);  // 通过时间流失量计算出x的改变量
        }
        if (mFromYDelta != mToYDelta) {
            dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);  // 通过时间流失量计算出y的改变量
        }
        t.getMatrix().setTranslate(dx, dy);  // 通过Matrix作用到对象
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码其实也可以当做自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画的模板代码, 自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画时, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;来配合计算改变量; 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix&lt;/code&gt;的使用, 可以参见&lt;a href=&quot;https://hencoder.com/ui-1-4/&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-帧动画&quot;&gt;2.3 帧动画&lt;/h3&gt;

&lt;p&gt;帧动画就是顺序播放一组预先定义好的图片, 系统提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimationDrawable&lt;/code&gt;来使用帧动画&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;定义如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;/res/drawable/filename.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;animation-list&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:oneshot=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/animation-list&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用帧动画时, 当图片较多或者较大时可能引起&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-transition过渡动画&quot;&gt;三. Transition(过渡动画)&lt;/h2&gt;

&lt;p&gt;过渡动画其实是用于控制&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;的出场效果, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;之间的切换效果等&lt;/p&gt;

&lt;h3 id=&quot;31-layoutanimation&quot;&gt;3.1 LayoutAnimation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;实现格式如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;/res/anim/anim_layout.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;layoutAnimation&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:delay=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.5&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:animationOrder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[normal | reverse | random]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:animation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@anim/anim_item&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:delay&lt;/code&gt;: 子元素延迟多少时间执行动画; 比如子元素入场动画时间周期为&lt;code class=&quot;highlighter-rouge&quot;&gt;300ms&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;表示每个每个子元素都需要延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;150ms&lt;/code&gt;才能播放入场动画, 总体来说, 第一个子元素延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;150ms&lt;/code&gt;开始播放动画, 第二个子元素延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;300ms&lt;/code&gt;开始播放动画, 以此类推&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:animationOrder&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;normal&lt;/code&gt;表示顺序显示, 即排在前面的子元素先开始动画; &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse&lt;/code&gt;表示逆向显示; &lt;code class=&quot;highlighter-rouge&quot;&gt;random&lt;/code&gt;表示随机显示&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当定义好&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutAnimation&lt;/code&gt;之后, 在布局文件中就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;android:layoutAnimation=&quot;@anim/anim_layout&quot;&lt;/code&gt;来指定入场动画了~&lt;/p&gt;

&lt;p&gt;代码实现, 格式如下: 即通过&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutAnimationController&lt;/code&gt;实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ListView listView = findViewById(R.id.list);
Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item);
LayoutAnimationController controller = new LayoutAnimationController(animation);
controller.setDelay(0.5f);
controller.setOrder(LayoutAnimationController.ORDER_NORMAL);
listView.setLayoutAnimation(controller);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-activity的切换效果&quot;&gt;3.2 Activity的切换效果&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;当启动一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的时候, 可以按照如下方式为其添加自定义的切换效果:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent intent = new Intent(this, AnimActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;退出时, 可以如下添加切换效果:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Override
    public void finish() {
        super.finish();
        overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出, 都是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;overridePendingTransition()&lt;/code&gt;来指定切换动画, 同时需要注意的是这个方法必须在&lt;code class=&quot;highlighter-rouge&quot;&gt;startActivity(intent)&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;finish()&lt;/code&gt;之后被调用才能生效&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;Fragment&lt;/code&gt;添加切换动画: 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentTransaction.setCustomAnimations()&lt;/code&gt;来添加切换动画; 需要注意的是该动画必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画, 不能用属性动画(因为属性动画在&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;引入, &lt;code class=&quot;highlighter-rouge&quot;&gt;Fragment&lt;/code&gt;也是&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;才引入的)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-属性动画&quot;&gt;四. 属性动画&lt;/h2&gt;

&lt;p&gt;属性动画是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;)开始引入的; 属性动画可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;实现, 也可以用代码实现, 但是一般都是用代码实现&lt;/p&gt;

&lt;h3 id=&quot;41-基本使用&quot;&gt;4.1 基本使用&lt;/h3&gt;

&lt;h4 id=&quot;411-viewpropertyanimator&quot;&gt;4.1.1 ViewPropertyAnimator&lt;/h4&gt;

&lt;p&gt;操作&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;属性值, 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;View.animate()&lt;/code&gt;来获取一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;对象, 然后就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;来操作该对象的属性值了~  可以操作的属性值参见下图(图片来源, 参见文末参考链接):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Animation/ViewPropertyAnimator属性动画.png&quot; alt=&quot;ViewPropertyAnimator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用示例如&lt;code class=&quot;highlighter-rouge&quot;&gt;View.animate().setDuration(500).alpha(0.5);&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;412-objectanimator&quot;&gt;4.1.2 ObjectAnimator&lt;/h4&gt;

&lt;p&gt;也是针对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的特定属性, 同时还要求该属性提供了对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法, 基本使用如下; 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;是通过属性的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法来不断改变属性值的, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法是一定需要的, 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法只是用于获取动画开始的初始值的, 如果明确指定了初始值的话, 也可以提供&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法(如果没有提供&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法, 同时又没有指定初始值的话, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;; 如果没有&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法, 不会&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;, 只是没有效果而已)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0, 65);
animator.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果一个属性没有&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法的话, 解决方法有以下三种:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果有权限的话, 自己给对象加上&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用一个类来包装原始对象, 间接为其提供&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采用&lt;code class=&quot;highlighter-rouge&quot;&gt;ValueAnimator&lt;/code&gt;, 监听动画过程, 自己实现属性改变&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;42-插值器&quot;&gt;4.2 插值器&lt;/h3&gt;

&lt;p&gt;所谓插值器就是属性改变的速度, 系统提供了如下插值器:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AccelerateDecelerateInterpolator&lt;/td&gt;
      &lt;td&gt;LinearInterpolator&lt;/td&gt;
      &lt;td&gt;AccelerateInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DecelerateInterpolator&lt;/td&gt;
      &lt;td&gt;AnticipateInterpolator&lt;/td&gt;
      &lt;td&gt;OvershootInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AnticipateOvershootInterpolator&lt;/td&gt;
      &lt;td&gt;BounceInterpolator&lt;/td&gt;
      &lt;td&gt;CycleInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PathInterpolator&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutLinearInInterpolator&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutSlowInInterpolator&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearOutSlowInInterpolator&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutLinearInInterpolator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutSlowInInterpolator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinearOutSlowInInterpolator&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 5.0(API 21)&lt;/code&gt;引入的三个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Interpolator&lt;/code&gt;模型, 并把它们加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;support v4&lt;/code&gt;包中&lt;/p&gt;

&lt;p&gt;关于各种插值器的讲解, 可以参见&lt;a href=&quot;https://hencoder.com/ui-1-6/&quot;&gt;博客&lt;/a&gt;, 该博客讲的比较详细, 此处不再赘述~&lt;/p&gt;

&lt;h3 id=&quot;43-估值器&quot;&gt;4.3 估值器&lt;/h3&gt;

&lt;p&gt;估值器即&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeEvaluator&lt;/code&gt;, 作用是根据当前属性改变的百分比来计算改变后的属性值, 用于协助插值器实现非线性运动; 系统提供了如下估值器:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IntEvaluator&lt;/td&gt;
      &lt;td&gt;IntArrayEvaluator&lt;/td&gt;
      &lt;td&gt;FloatEvaluator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FloatArrayEvaluator&lt;/td&gt;
      &lt;td&gt;ArgbEvaluator&lt;/td&gt;
      &lt;td&gt;PointFEvaluator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RectEvaluator&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果要对其他类型做动画(非&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Color&lt;/code&gt;), 那么需要自定义类型估值算法, 即继承&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeEvaluator&lt;/code&gt;自己实现其&lt;code class=&quot;highlighter-rouge&quot;&gt;evaluate()&lt;/code&gt;方法即可&lt;/p&gt;

&lt;p&gt;估值器基本使用如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ObjectAnimator anim = ObjectAnimator.ofObject(view, &quot;alpha&quot;, new FloatEvaluator(), 0, 1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;44-监听器&quot;&gt;4.4 监听器&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;设置监听器的方法如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ViewPropertyAnimator&lt;/td&gt;
      &lt;td&gt;setListener()&lt;/td&gt;
      &lt;td&gt;setUpdateListener()&lt;/td&gt;
      &lt;td&gt;withStartAction()&lt;/td&gt;
      &lt;td&gt;withEndAction()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ObjectAnimator&lt;/td&gt;
      &lt;td&gt;addListener()&lt;/td&gt;
      &lt;td&gt;addUpdateListener()&lt;/td&gt;
      &lt;td&gt;addPauseListener()&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setUpdateListener()&lt;/code&gt;来设置监听器, 移除监听器可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setListener(null)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setUpdateListener(null)&lt;/code&gt;来移除; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;独有的&lt;code class=&quot;highlighter-rouge&quot;&gt;withStartAction()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt; 方法, 可以设置&lt;strong&gt;一次性&lt;/strong&gt;(动画结束后就自动弃掉了, 即一次有效)的动画开始或结束的监听&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;则是用&lt;code class=&quot;highlighter-rouge&quot;&gt;addListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addUpdateListener()&lt;/code&gt;来添加一个或多个监听器, 移除监听器则是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;removeListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;removeUpdateListener()&lt;/code&gt;来指定移除对象; &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;支持使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pause()&lt;/code&gt;方法暂停, 所以它还多了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;addPauseListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;removePauseListener()&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator.withStartAction/EndAction()&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;的独有方法, 它们和&lt;code class=&quot;highlighter-rouge&quot;&gt;set/addListener()&lt;/code&gt;中回调的 &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationStart()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;相比起来的不同主要有两点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;withStartAction()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt;是一次性的, 在动画执行结束后就自动弃掉了, 就算之后再重用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt; 来做别的动画, 用它们设置的回调也不会再被调用; 而&lt;code class=&quot;highlighter-rouge&quot;&gt;set/addListener()&lt;/code&gt;所设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener&lt;/code&gt;是持续有效的, 当动画重复执行时, 回调总会被调用&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt;设置的回调只有在动画正常结束时才会被调用, 而在动画被取消时不会被执行; 这点和&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener.onAnimationEnd()&lt;/code&gt; 的行为是不一致的&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;监听器方法有:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;AnimatorListener&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;onAnimationStart()&lt;/td&gt;
      &lt;td&gt;onAnimationEnd()&lt;/td&gt;
      &lt;td&gt;onAnimationCancel()&lt;/td&gt;
      &lt;td&gt;onAnimationRepeat()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 即使动画通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cancle()&lt;/code&gt;方法取消, &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;也会被调用; 所以当动画被取消时, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener&lt;/code&gt;, 那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationCancel()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;都会被调用; &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationCancel()&lt;/code&gt;会先于&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;被调用; 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;不支持重复, 所以这个方法对&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;相当于无效&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-动画注意事项&quot;&gt;五. 动画注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;避免使用帧动画, 易造成&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动画需要考虑暂停和取消; 属性动画中有一类无线循环的动画, 这类动画在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;退出时要及时停止, 否则将导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;无法释放从而造成内存泄露; 通过验证后发现&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画无此问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画之后可能会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;无法隐藏的现象, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;setVisibility(View.GONE)&lt;/code&gt;失效了, 此时可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;view.clearAnimation()&lt;/code&gt;来清除&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;以前系统, 不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画还是属性动画, 都只是作用于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;内容(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;以前, 属性动画底层其实也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画实现的), 新位置无法触发单击事件; 从&lt;code class=&quot;highlighter-rouge&quot;&gt;3.0&lt;/code&gt;开始, 属性动画的单击事件触发位置为移动后的位置, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画仍然在原位置&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考&quot;&gt;六. 参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;«Android开发艺术探索»&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://hencoder.com/ui-1-6/&quot;&gt;属性动画 Property Animation&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/04/Android%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/04/Android%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Java类文件结构与类加载机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第六章第七章以及其他博客的总结, 权做笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-类文件结构&quot;&gt;一. 类文件结构&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件是一组以&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节为基础单位的二进制流, 当遇到需要占据&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节进行存储&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式采用一种类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型: 无符号数和表; 无符号数是基本数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;u1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u4&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u8&lt;/code&gt;来分别代表&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个字节,&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个字节, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节和&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节的无符号数, 无符号数可以用来描述数字, 索引引用, 数量值或者按照&lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;编码构成字符串值; 表由多个无符号数或者其他表作为数据项构成的复合数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;_info&lt;/code&gt;结尾&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中没有分隔符, 所以哪个字节代表什么含义, 长度是多少, 先后顺序如何, 都被严格限定且不允许改变&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式见下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;数量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u4&lt;/td&gt;
      &lt;td&gt;magic&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;minor_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;major_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;constant_pool_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cp_info&lt;/td&gt;
      &lt;td&gt;constant_pool&lt;/td&gt;
      &lt;td&gt;constant_pool_count-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;access_flags&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;this_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;super_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;field_info&lt;/td&gt;
      &lt;td&gt;fields&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;method_info&lt;/td&gt;
      &lt;td&gt;methods&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attribute_info&lt;/td&gt;
      &lt;td&gt;attributes&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;11-简介&quot;&gt;1.1 简介&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;魔数&lt;/strong&gt;: 每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件头&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节称为魔数, 唯一作用是确定该文件是否是一个能被虚拟机接受的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;: 紧接着魔数的四个字节存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件的版本号: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个字节是次版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor Version&lt;/code&gt;), 第&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节是主版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Major Version&lt;/code&gt;); 虚拟机必须拒绝执行超过其版本号的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;常量池&lt;/strong&gt;: 紧接着主版本号之后的是常量池入口, 是一个表类型数据项; &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中只有常量池的容量计数是从&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;开始的; 常量池中主要存放两大类常量: 字面量和符号引用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;字面量: 如: 文本字符串, 声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的常量值等&lt;/li&gt;
    &lt;li&gt;符号引用: 类和接口的全限定名; 字段的名称和描述符; 方法的名称和描述符&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;访问标志&lt;/strong&gt;: 常量池结束之后, 紧接着的两个字节代表访问标志; 用于表示一些类或者接口的层次信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;类索引, 父类索引和接口索引集合&lt;/strong&gt;: 用于确定类的继承关系; 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;之外, 所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类都有父类, 因此除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;外, 所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的父类索引都不为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;字段表&lt;/strong&gt;: 描述接口或者类中声明的变量; 字段包括类级变量以及实例级变量, 但不包括方法内部声明的局部变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;方法表&lt;/strong&gt;: 包括访问标志, 名称索引, 描述符索引, 属性表集合; 如果父类方法在子类中没有被重写, 方法表集合中就不会出现来自父类的方法信息, 但是, 同样的, 有可能会出现由编译器自动添加的方法, 最典型的便是类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;方法和实例构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;属性表&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机运行时会忽略掉它不认识的属性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-常见问题&quot;&gt;1.2 常见问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中方法, 字段等都需要引用&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量来描述名称, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量的最大长度也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中方法, 字段名的最大长度; &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;类型能表达的最大值是&lt;code class=&quot;highlighter-rouge&quot;&gt;65535&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-虚拟机类加载机制&quot;&gt;二. 虚拟机类加载机制&lt;/h2&gt;

&lt;h3 id=&quot;21-类加载的时机&quot;&gt;2.1 类加载的时机&lt;/h3&gt;

&lt;p&gt;类从被加载到虚拟机内存中开始, 到卸载出内存为止, 其生命周期如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/类的生命周期.png&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, 加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, 解析阶段则不一定: 在某些情况下, 可以在初始化阶段之后再&lt;strong&gt;开始&lt;/strong&gt;(注意, 是开始, 而不是&lt;em&gt;进行&lt;/em&gt;或者&lt;em&gt;完成&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;遇到以下五种情况必须立即对类进行&lt;em&gt;初始化&lt;/em&gt;(而加载, 验证, 准备自然要在这之前完成):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getstatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;putstatic&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;invokestatic&lt;/code&gt;这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条字节码指令时, 如果类没有初始化, 需要出发初始化; 生成这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条指令的常见&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;代码场景是: 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字实例化对象的时候, 读取或设置一个类的静态字段的时候(注意: 被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰, 已在编译期把结果放入常量池的静态字段除外(由此可见, 添加&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰可以避免不必要的类加载)), 以及调用一个类的静态方法的时候&lt;/li&gt;
    &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;包的方法对类进行反射调用的时候&lt;/li&gt;
    &lt;li&gt;当初始化一个类, 如果发现其父类没有初始化, 则需先初始化其父类&lt;/li&gt;
    &lt;li&gt;虚拟机启动时, 用户需要指定一个要执行的主类(&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;所在的类), 虚拟机会先初始化这个主类&lt;/li&gt;
    &lt;li&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.7&lt;/code&gt;的动态语言支持(比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Groovy&lt;/code&gt;等)时, 如果一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例最后的解析结果&lt;code class=&quot;highlighter-rouge&quot;&gt;REF_getStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_putStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_invokeStatic&lt;/code&gt;的方法句柄, 并且这个方法句柄所对应的类没有进行过初始化, 则需先触发其初始化&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;22-主动引用与被动引用&quot;&gt;2.2 主动引用与被动引用&lt;/h3&gt;

&lt;h4 id=&quot;221-构造函数-代码块-静态代码块的执行时机&quot;&gt;2.2.1 构造函数, 代码块, 静态代码块的执行时机&lt;/h4&gt;

&lt;p&gt;考虑下列代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Practice {

    static {
        System.out.println(&quot;Practice static code block&quot;);
    }

    {
        System.out.println(&quot;Practice code block&quot;);
    }

    public Practice() {
        System.out.println(&quot;Practice constructor&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Practice&lt;/code&gt;对象时, 输出如下; 说明三者的执行顺序是: 静态代码块 –&amp;gt; 代码块 –&amp;gt; 构造函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Practice static code block
Practice code block
Practice constructor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于三者的执行时机与作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;静态代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;用于给类初始化, 随着类的加载而执行, 只执行一次&lt;/li&gt;
    &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前执行&lt;/li&gt;
    &lt;li&gt;一个类可以有多个静态代码块&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;实例对象相关, 给所有对象进行统一初始化(因为构造函数可以重载)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;初始化实例&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;222-被动引用示例&quot;&gt;2.2.2 被动引用示例&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面所说的触发初始化的五个场景对应叫做主动引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;通过子类引用父类的静态字段, 不会导致子类初始化: 对于静态字段, 只有直接定义这个字段的类才会被初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);  // 不会初始化子类~
    }
}

class SuperClass {
    static {
        System.out.println(&quot;SuperClass init&quot;);
    }

    public static int value = 123;
}

class SubClass extends SuperClass{
    static {
        System.out.println(&quot;Child init&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 后文为节省篇幅, 将重用这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;SuperClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SubClass&lt;/code&gt;, 而不再重写~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过数组定义来引用类, 不会触发此类的初始化: 虚拟机会为数组自动生成一个直接继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的子类; &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中对数组的访问比&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;更安全, 是因为这个类封装了数组元素的访问方法, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;直接翻译为数组指针的移动&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[0];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;常量在编译阶段会存入被调用类的常量池中, 本质上并没有直接引用到常量的类, 因此不会出发定义常量的类的初始化: 在编译阶段经过常量传播优化, 已经将次&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World&lt;/code&gt;常量存储到了&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类的常量池中了, 以后&lt;code class=&quot;highlighter-rouge&quot;&gt;Initialization&lt;/code&gt;对常量&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstClass.HELLOWORLD&lt;/code&gt;的引用都被转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类对自身常量池的引用了~&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.CONST);
    }
}

class ConstClass {
    static {
        System.out.println(&quot;ConstClass init&quot;);
    }

    public static final String HELLOWORLD=&quot;Hello World&quot;; // 注意这里不能从static来理解, 因为即使有static, 但是没有final的话仍然会触发ConstClass的初始化~
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-类的加载过程&quot;&gt;2.3 类的加载过程&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;结合前面的图咯~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-加载&quot;&gt;2.3.1 加载&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内存中生成一个代表这个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象(该&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象并没有明确规定是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;HotSpot&lt;/code&gt;虚拟机而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象比较特殊, 它虽然是对象, 但是存在于方法区中), 作为方法区这个类的各种数据的访问入口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;232--验证&quot;&gt;2.3.2  验证&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;文件格式验证:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否以魔数&lt;code class=&quot;highlighter-rouge&quot;&gt;0xCAFEBABE&lt;/code&gt;开头&lt;/li&gt;
    &lt;li&gt;主, 次版本号是否在当前虚拟机处理范围之内&lt;/li&gt;
    &lt;li&gt;常量池的常量中是否有不被支持的类型
….&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;元数据验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否有父类&lt;/li&gt;
    &lt;li&gt;是否继承了不允许被继承的父类(被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的父类)&lt;/li&gt;
    &lt;li&gt;如果这个类不是抽象类, 是否实现其父类或接口中要求实现的所有方法&lt;/li&gt;
    &lt;li&gt;是否非法覆盖(&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;方法), 重载是否正确
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;字节码验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;对类的方法体进行校验分析, 保证被校验的类在运行时不会危害虚拟机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;符号引用验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;符号引用中通过字符串描述的全限定名是否能找到对应的父类&lt;/li&gt;
    &lt;li&gt;符号引用中的类, 字段, 方法的访问性是否可以被当前类访问&lt;/li&gt;
    &lt;li&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;233-准备&quot;&gt;2.3.3 准备&lt;/h4&gt;

&lt;p&gt;正式为类变量分配内存并为其设置初始值&lt;/p&gt;

&lt;h4 id=&quot;234-解析&quot;&gt;2.3.4 解析&lt;/h4&gt;

&lt;p&gt;将常量池中的符号引用替换为直接引用&lt;/p&gt;

&lt;h4 id=&quot;235-初始化&quot;&gt;2.3.5 初始化&lt;/h4&gt;

&lt;p&gt;真正开始执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序代码(字节码)或者说初始化阶段是执行类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程&lt;/p&gt;

&lt;h5 id=&quot;235-1-类构造器方法&quot;&gt;2.3.5-1 类构造器&lt;clinit&gt;()方法&lt;/clinit&gt;&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;代码块)中的语句合并产生的; 静态语句块只能访问到定义在静态语句块之前的变量, 定义在它之后的变量, 在前面的静态语句块可以赋值, 但是不能访问, 如下代码&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Temp {
    static {
        value = 2;
//        System.out.println(value); // 不能访问
    }

    static int value = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法与构造函数(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;)不同, 虚拟机会保证子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法执行之前, 父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法已经执行完毕; 因此在虚拟机中第一个被执行的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的类肯定是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法先于子类的执行, 也就意味着父类中的静态语句块要先于子类的变量赋值操作; 注意如下代码;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SuperClass {
    public static int A = 1;
    static {
        A = 2;
    }
}

class SubClass extends SuperClass{
    public static int B = A; // 注意这里的B应该为2, 而不是1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法对于类或接口来说不是必需的, 如果一个类没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接口中不能有静态语句块, 但是可以有变量的初始化赋值操作, 因此接口与类一样也会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法; 但接口与类不同的是, 执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法不需要先执行父接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法, 只有当父接口中定义的变量使用时, 父接口才会初始化; 另外, 接口的实现类在初始化时也一样不会执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机会保证一个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法在多线程环境中被正确的加锁, 同步; 只能有一个线程去执行&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-类加载器&quot;&gt;2.4 类加载器&lt;/h3&gt;

&lt;p&gt;任意一个类, 都是由加载它的类加载器和这个类本身一同确立其在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中的唯一性; 更通俗一些是: 比较两个类是否&lt;em&gt;相等&lt;/em&gt;, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来自同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件, 被同一个虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等(这里所谓的相等, 包括代表&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isAssignableFrom()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInstance()&lt;/code&gt;方法的返回结果, 以及使用&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;关键字做对象所属关系判断等情况); 如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.io.InputStream;

public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = new ClassLoader() {
            @Override
            public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;
                    InputStream inputStream = getClass().getResourceAsStream(fileName);
                    if (inputStream == null) {
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name, bytes, 0, bytes.length);
                } catch (IOException e) {
                }
                return null;
            }
        };

        Object obj = loader.loadClass(&quot;Practice&quot;).newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof Practice); // 及时是Practice实例, 但是这里仍然返回false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-双亲委派模型&quot;&gt;2.5 双亲委派模型&lt;/h3&gt;

&lt;h4 id=&quot;251-类加载器分类&quot;&gt;2.5.1 类加载器分类&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Bootstrap ClassLoader&lt;/code&gt;): &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现, 虚拟机自身一部分&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Extension ClassLoader&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用程序类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application ClassLoader&lt;/code&gt;): 如果没有定义自己的类加载器, 则为程序中默认的类加载器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;252-双亲委派模型含义&quot;&gt;2.5.2 双亲委派模型含义&lt;/h4&gt;

&lt;p&gt;如下图; 双亲委派模型要求除了顶层的启动类加载器外, 其余的类加载器都应当有自己的父类加载器;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/双亲委派模型.png&quot; alt=&quot;双亲委派模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此; 因此所有的加载请求最终都应该传送到顶层的启动类加载器中, 只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时, 子加载器才会尝试自己去加载&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/02/JVM%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/02/JVM%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
