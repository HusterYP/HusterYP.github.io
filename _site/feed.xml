<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 13 Oct 2018 14:58:40 +0800</pubDate>
    <lastBuildDate>Sat, 13 Oct 2018 14:58:40 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>OpenGL笔记</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;阅读OpenGL中文文档笔记&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-入门&quot;&gt;一. &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;入门&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;11-opengl&quot;&gt;1.1 OpenGL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是OpenGL: 并不是API, 而是一个规范; OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定; OpenGL基于显卡, 所以OpenGL API大多由显卡厂商提供&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心模式与立即渲染模式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;立即渲染模式(固定渲染管线): 用于早期OpenGL; 封装性好, 使用方便, 但是效率低, 灵活性不够&lt;/li&gt;
    &lt;li&gt;核心模式: 从OpenGL3.2开始, 规范文档开始废弃立即渲染模式; 当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;状态机: OpenGL状态通常被成为OpenGL上下文; OpenGL本质上是一个大状态机(理解状态函数和状态使用函数)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-hello-window&quot;&gt;1.2 Hello Window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;视口: ViewPort; OpenGL渲染窗口的尺寸大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双缓冲: 应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-hello-三角形&quot;&gt;1.3 Hello 三角形&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图形渲染管线: 又称为管线; 指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程;  在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素; 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的; 图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器: 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器; 而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如下为每个图形渲染管线的抽象展示; 其中蓝色部分是可以注入自定义着色器的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/图形渲染管线.png&quot; alt=&quot;图形渲染管线&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图元(Primitive): 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点着色器(Vertex Shader): 顶点着色器主要的目的是把3D坐标转为另一种3D坐标, 同时顶点着色器允许我们对顶点属性进行一些基本处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图元装配(Primitive Assembly): 将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状; 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;光栅化阶段: 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片段着色器: 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准化设备坐标: 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/标准化设备坐标.png&quot; alt=&quot;标准化设备坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;深度: 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器程序: 着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;glVertexAttribPointer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/glVertexAttribPointer.png&quot; alt=&quot;glVertexAttribPointer&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-glsl&quot;&gt;1.4 GLSL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GLSL基本数据类型: int, float, double, uint, bool&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容器类型: Vector, Matrix&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Uniform: Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-纹理&quot;&gt;1.5 纹理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理: 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采样: 使用纹理坐标获取纹理颜色叫做采样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理坐标.png&quot; alt=&quot;纹理坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;纹理环绕方式: 纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理环绕方式.png&quot; alt=&quot;纹理环绕方式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理过滤: 纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标(Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色); 纹理过滤主要有两种: GL_NEAREST和GL_LINEAR; 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项(使用glTexParameteri())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;邻近过滤(GL_NEAREST): 默认纹理过滤方式; 当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性过滤(GL_LINEAR): 会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大(GL_LINEAR可以产生更真实的输出)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多级渐远纹理: 简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一; 多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好(glGenerateMipmaps())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理单元: 一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元; 纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-变换&quot;&gt;1.5 变换&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向量: 有大小和方向; 其实就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;N*1&lt;/code&gt;的矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量运算:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/向量与标量运算.png&quot; alt=&quot;向量与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量取反: 个分量都取反&lt;/li&gt;
    &lt;li&gt;向量之间加减: 各分量之间对应加减&lt;/li&gt;
    &lt;li&gt;向量乘积&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;点乘: 点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘.png&quot; alt=&quot;点乘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘2.png&quot; alt=&quot;点乘2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;叉乘:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/叉乘.png&quot; alt=&quot;叉乘&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;矩阵运算&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与标量运算.png&quot; alt=&quot;矩阵与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵之间加减: 对应项加减即可&lt;/li&gt;
    &lt;li&gt;矩阵数乘: 将该数和矩阵每一项想乘&lt;/li&gt;
    &lt;li&gt;矩阵相乘: 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘; 矩阵相乘不遵守交换律&lt;/li&gt;
    &lt;li&gt;矩阵与向量相乘:&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;缩放:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之缩放.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;位移:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之位移.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿x轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿x轴旋转.png&quot; alt=&quot;沿x轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿y轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿y轴旋转.png&quot; alt=&quot;沿y轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿z轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿z轴旋转.png&quot; alt=&quot;沿z轴旋转&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;16-坐标系统&quot;&gt;1.6 坐标系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对我们来说比较重要的有五类坐标系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;局部空间(Local Space，或者称为物体空间(Object Space))&lt;/li&gt;
    &lt;li&gt;世界空间(World Space)&lt;/li&gt;
    &lt;li&gt;观察空间(View Space，或者称为视觉空间(Eye Space))&lt;/li&gt;
    &lt;li&gt;裁剪空间(Clip Space)&lt;/li&gt;
    &lt;li&gt;屏幕空间(Screen Space)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/坐标系统.png&quot; alt=&quot;坐标系统&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;局部空间: 物体所在的坐标空间，即对象最开始所在的地方&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界空间: 物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;观察空间: 观察空间经常被人们称之OpenGL的摄像机(Camera); 观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果; 因此观察空间就是从摄像机的视角所观察到的空间; 这通常用一个观察矩阵(View Matrix)完成，它被用来将世界坐标变换到观察空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;裁剪空间:  在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来; 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection
Matrix)，它指定了一个范围的坐标(如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围)(一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;透视投影: 离你越远的东西看起来更小; 使用透视投影矩阵来完成的; 一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上, 即将顶点坐标中的每个分量除以w分量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个顶点坐标会根据以下过程被变换到裁剪坐标(注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法)): 最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/裁剪坐标.png&quot; alt=&quot;裁剪坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Z缓冲(深度缓冲): 深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;17-摄像机&quot;&gt;1.7 摄像机&lt;/h3&gt;

&lt;p&gt;https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</guid>
        
        <category>OpenGL</category>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>排序算法</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;排序算法总结, 分析各种排序算法的时间复杂度, 空间复杂度, 使用场景和优化等方面&lt;/p&gt;

&lt;p&gt;包括: 选择排序, 归并排序, 插入排序, 冒泡排序, 快排, 堆排, 基数排序, 希尔排序, 计数排序, 桶排序&lt;/p&gt;

&lt;p&gt;文中代码使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;实现, &lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;实现可以参见: https://github.com/HusterYP/DataStructure&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-选择排序&quot;&gt;一. 选择排序&lt;/h2&gt;

&lt;h3 id=&quot;11-基本思路&quot;&gt;1.1 基本思路&lt;/h3&gt;

&lt;p&gt;找到数组中的最小元素, 将它和数组的第一个元素交换, 然后在剩下元素中找到最小元素和数组第二个元素交换, 如此往复, 直到有序&lt;/p&gt;

&lt;h3 id=&quot;12-主要代码&quot;&gt;1.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0) // 边界条件
            return;
        int N = noSort.length;
        for (int i = 0; i &amp;lt; N; i++) {
            int min = i;
            for (int j = i + 1; j &amp;lt; N; j++) {
                if (Utils.less(noSort[min], noSort[j]) &amp;lt; 0) // 注意此处比较条件, 不要写成noSort[i]和noSort[j]比较了
                    min = j;
            }
            Utils.exch(noSort, i, min);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-特点&quot;&gt;1.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;; 需要进行&lt;code class=&quot;highlighter-rouge&quot;&gt;(N-1)+(N-2)+...+1 = (N-1)*N/2&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;次交换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界时间&lt;/strong&gt;: 选择排序的最好情况与最坏情况时间相同, 同其时间复杂度分析(也可以说没有最好最坏情况)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 需要一个临时变量&lt;code class=&quot;highlighter-rouge&quot;&gt;min&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定的; 如&lt;code class=&quot;highlighter-rouge&quot;&gt;[5, 5, 2]&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-插入排序&quot;&gt;二. 插入排序&lt;/h2&gt;

&lt;h3 id=&quot;21-基本思路&quot;&gt;2.1 基本思路&lt;/h3&gt;

&lt;p&gt;从第一个元素开始, 该元素可认为已经被排序, 取出下一个元素, 在已排序元素序列中从后往前开始扫描, 插入到相应位置&lt;/p&gt;

&lt;h3 id=&quot;22-主要代码&quot;&gt;2.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        for (int i = 1; i &amp;lt; N; i++) {
            int index = i;
            while (index &amp;gt; 0 &amp;amp;&amp;amp; Utils.less(noSort[index], noSort[index - 1])) {
                Utils.exch(noSort, index, index - 1);
                index--;
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-特点&quot;&gt;2.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;; 平均情况下需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 4&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 4&lt;/code&gt;次交换&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界情况&lt;/strong&gt;: 最好情况是, 所有数据有序, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N-1&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;次交换; 最坏情况是所有数据逆序有序, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 2&lt;/code&gt;次比较和&lt;code class=&quot;highlighter-rouge&quot;&gt;N^2 / 2&lt;/code&gt;次交换(注意, 其实平均情况就是最坏情况对半, 因为每个位置每个元素出现几率相同)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用情况&lt;/strong&gt;: 对于部分有序的数组, 插入排序的效率很高; 部分有序数组:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;数组中每个元素距离它的最终位置都不远&lt;/li&gt;
    &lt;li&gt;一个有序的大数组接一个小数组&lt;/li&gt;
    &lt;li&gt;数组中只有几个元素的位置不正确&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-希尔排序&quot;&gt;三. 希尔排序&lt;/h2&gt;

&lt;p&gt;插入排序的改进&lt;/p&gt;

&lt;h3 id=&quot;31-基本思路&quot;&gt;3.1 基本思路&lt;/h3&gt;

&lt;p&gt;使数组中任意间隔为&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的数组都是有序的, 称为&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;有序数组; 类似插入排序, 但使用不同增量, 因为在插入排序中讲解适用性的时候说过, 插入排序在用于小数组的时候(可以理解为部分有序数组的第一种情况)很有效, 希尔排序就是将一个大数组按照&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;间隔分为许多小数组, 然后分别对这些小数组进行插入排序, 部分有序之后对整体进行插入排序(&lt;code class=&quot;highlighter-rouge&quot;&gt;h=1&lt;/code&gt;), 此时即有序; 而这两种情况都适用于插入排序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的选择, &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2*(3^k-1)&lt;/code&gt;, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;N/3&lt;/code&gt;递减至&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int h = 1;
while(h &amp;lt; N/3)
    h = h * 3 + 1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-基本代码&quot;&gt;3.2 基本代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        int h = 1;
        while (h &amp;lt; N / 3)
            h = h * 3 + 1;
        while (h &amp;gt;= 1) {
            for (int i = h; i &amp;lt; N; i++) {
                for (int j = i; j &amp;gt;= h &amp;amp;&amp;amp; Utils.less(noSort[j], noSort[j - h]); j -= h)
                    Utils.exch(noSort, j, j - h);
            }
            h = h / 3;
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-特点&quot;&gt;3.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: 优于插入排序; 取决于&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;的取值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;h&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用情况&lt;/strong&gt;: 希尔排序也可以用于大数组, 对任意排序(不一定是随机的)的数组表现也很好; 可以先考虑使用希尔排序, 然后再考虑是否值得将它替换为更加复杂的排序算法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-冒泡排序&quot;&gt;四. 冒泡排序&lt;/h2&gt;

&lt;h3 id=&quot;41-基本思路&quot;&gt;4.1 基本思路&lt;/h3&gt;

&lt;p&gt;比较相邻元素, 如果第一个比第二个大, 就交换他们两个, 遍历所有元素, 一趟之后, 最后一个元素为最大元素; 对剩余元素重复该步骤(除了最后一个)&lt;/p&gt;

&lt;h3 id=&quot;42-主要代码&quot;&gt;4.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        for (int i = N; i &amp;gt; 0; i--) {
            for (int j = 0; j &amp;lt; i - 1; j++) {
                if (Utils.less(noSort[j + 1], noSort[j]))
                    Utils.exch(noSort, j, j + 1);
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-特点&quot;&gt;4.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(N^2)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;改进&lt;/strong&gt;: 添加标志位, 如果一趟遍历中没有交换, 说明已经有序, 直接退出即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        int N = noSort.length;
        boolean isChange = true;
        for (int i = N; i &amp;gt; 0 &amp;amp;&amp;amp; isChange; i--) {
            isChange = false;
            for (int j = 0; j &amp;lt; i - 1; j++) {
                if (Utils.less(noSort[j + 1], noSort[j])) {
                    Utils.exch(noSort, j, j + 1);
                    isChange = true;
                }
            }
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-归并排序&quot;&gt;五. 归并排序&lt;/h2&gt;

&lt;h3 id=&quot;51-基本思路&quot;&gt;5.1 基本思路&lt;/h3&gt;

&lt;p&gt;递归排序, 先将一个数组分成两半分别排序, 然后将结果归并起来&lt;/p&gt;

&lt;h3 id=&quot;52-主要代码&quot;&gt;5.2 主要代码&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;自顶向下的归并排序:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MergeSort {
    private static int[] aux; // 辅助数组

    public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        aux = new int[noSort.length];
        sort(noSort, 0, noSort.length - 1);
    }

    public static void sort(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int mid = low + (high - low) / 2;
        sort(noSort, low, mid); // 将左半边数组排序
        sort(noSort, mid + 1, high); // 将右半边数组排序
        merge(noSort, low, mid, high); // 将数组归并
    }

    public static void merge(int[] noSort, int low, int mid, int high) {
        int i = low;
        int j = mid + 1;
        for (int k = low; k &amp;lt;= high; k++) {
            aux[k] = noSort[k];
        }

        for (int k = low; k &amp;lt;= high; k++) {
            if (i &amp;gt; mid)
                noSort[k] = aux[j++]; // 如果左边用完
            else if (j &amp;gt; high)
                noSort[k] = aux[i++]; // 如果右边用完
            else if (Utils.less(aux[j], aux[i]))
                noSort[k] = aux[j++];
            else
                noSort[k] = aux[i++];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自底向下的归并排序:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sortBU(int[] noSort) {
        int N = noSort.length;
        aux = new int[N];
        for (int sz = 1; sz &amp;lt; N; sz = sz + sz) {
            for (int low = 0; low &amp;lt; N - sz; low += sz + sz)
                merge(noSort, low, low + sz - 1, Math.min(low + sz + sz - 1, N - 1));
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;53-特点&quot;&gt;5.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;; 归并排序是一种渐进最优的基于比较的排序算法; 能够保证&lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;的时间复杂度(即最坏情况最好情况都相同)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: 需要与&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;成正比的额外数组空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;两种归并方式的区别&lt;/strong&gt;: 自底向上的归并方式比较适合用链表组织的数据, 此时只需要重新组织链表链接就能将链表原地排序, 不需要额外空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;54-改进&quot;&gt;5.4 改进&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对小规模子数组使用插入排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试数组是否已经有序: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;noSort[mid] &amp;lt; noSort[mid+1]&lt;/code&gt;说明数组有序, 可以跳过本次&lt;code class=&quot;highlighter-rouge&quot;&gt;merge()&lt;/code&gt;了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不将元素复制到辅助数组: 可以节省将元素复制到辅助数组所用的时间(但是空间不行), 即进行交替归并即可(可以添加一个标志位标识最终结果存储在哪个数组)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-快排&quot;&gt;六. 快排&lt;/h2&gt;

&lt;h3 id=&quot;61-基本思路&quot;&gt;6.1 基本思路&lt;/h3&gt;

&lt;p&gt;对于某个&lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;已经排定, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[low]&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j-1]&lt;/code&gt;中的所有元素都不大于&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[j+1]&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;a[high]&lt;/code&gt;中的所有元素都不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;a[j]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;62-主要代码&quot;&gt;6.2 主要代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class QuickSort {

    public static void sort(int[] noSort) {
        if (noSort == null || noSort.length &amp;lt;= 0)
            return;
        sort(noSort, 0, noSort.length - 1);
    }

    private static void sort(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int j = partition(noSort, low, high);
        sort(noSort, low, j - 1);
        sort(noSort, j + 1, high);
    }

    private static int partition(int[] noSort, int low, int high) {
        int i = low;
        int j = high + 1;
        int temp = noSort[low];
        while (true) {
            while (Utils.less(noSort[++i], temp))
                if (i == high)
                    break;
            while (Utils.less(temp, noSort[--j]))
                if (j == low)
                    break;
            if (i &amp;gt;= j)
                break;
            Utils.exch(noSort, i, j);
        }
        Utils.exch(noSort, low, j);
        return j;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;63-特点&quot;&gt;6.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;; 比归并和希尔排序都快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;临界情况&lt;/strong&gt;: 依赖于切分情况; 最好情况是每次都能将数组对半分; 最坏情况是第一次从最小元素切分, 第二次第二小元素切分, 如此这般, 每次调用都只能移除一个元素, 造成最坏情况(可以在开始排序之前, 现将待排序数组打乱(&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle()&lt;/code&gt;))&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;logN&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;64-算法改进&quot;&gt;6.4 算法改进&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;小数组时切换到插入排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三取样切分: 使用子数组的一小部分元素的中位数来切分数组, 这样切分更好, 但代价是需要计算中位数; 将取样大小设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;并用大小居中的元素切分的效果更好; 还可以将取样元素放在数组末尾作为&lt;strong&gt;哨兵&lt;/strong&gt;, 这样可以避免临界值判断&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熵最优排序: 当含有大量重复元素的时候, 快排的递归性会使元素全部重复的子元素经常出现, 这就有很大的改进潜力, 将线性对数级的性能提高到线性级别; 一个简单的想法是将数组切分为三部分, 即小于, 等于和大于(荷兰国旗问题); 基本思路是: 维护一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[low..lt-1]&lt;/code&gt;中的元素都小于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;(切分元素), 一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[gt+1..hi]&lt;/code&gt;中的元素都大于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 一个指针&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;使得&lt;code class=&quot;highlighter-rouge&quot;&gt;a[lt..i-1]&lt;/code&gt;中元素都等于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a[i..gt-1]&lt;/code&gt;中元素都还未确定, 一开始&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;low&lt;/code&gt;相等:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;小于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;a[lt]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;交换, &lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;加一&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;大于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;a[gt]&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;交换, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;减一&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a[i]&lt;/code&gt;等于&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;加一&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;三向切分改进代码如下:&lt;/strong&gt; 三向切分的最坏情况是所有元素都不同; 在包含大量重复元素时, 其能将对数级别的时间降低到线性级别&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void sort3Way(int[] noSort, int low, int high) {
        if (high &amp;lt;= low)
            return;
        int lt = low;
        int i = low + 1;
        int gt = high;
        int temp = noSort[low];
        while (i &amp;lt; gt) { // 找出重复元素
            if (noSort[i] &amp;lt; temp)
                Utils.exch(noSort, lt++, i++);
            else if (noSort[i] &amp;gt; temp)
                Utils.exch(noSort, i, gt--);
            else
                i++;
        }
        sort3Way(noSort, low, lt - 1);
        sort3Way(noSort, gt + 1, high);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;七-堆排&quot;&gt;七. 堆排&lt;/h2&gt;

&lt;h3 id=&quot;71-基本思路&quot;&gt;7.1 基本思路&lt;/h3&gt;

&lt;p&gt;堆是一个二叉树的每个节点都大于等于(或小于等于)它的两个子节点; 分为大顶堆和小顶堆&lt;/p&gt;

&lt;h3 id=&quot;72-主要代码&quot;&gt;7.2 主要代码&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F#Java&quot;&gt;Wiki&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class HeapSort {

    public static void sort(int[] arr) {
        /*
         *  第一步：将数组堆化
         *  beginIndex = 第一个非叶子节点。
         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。
         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。
         */
        int len = arr.length - 1;
        int beginIndex = (len - 1) &amp;gt;&amp;gt; 1;
        for (int i = beginIndex; i &amp;gt;= 0; i--) {
            maxHeapify(arr, i, len);
        }

        /*
         * 第二步：对堆化数据排序
         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。
         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。
         * 直至未排序的堆长度为 0。
         */
        for (int i = len; i &amp;gt; 0; i--) {
            Utils.exch(arr, 0, i);
            maxHeapify(arr, 0, i - 1);
        }
    }

    /**
     * 调整索引为 index 处的数据，使其符合堆的特性。
     *
     * @param index 需要堆化处理的数据的索引
     * @param len   未排序的堆（数组）的长度
     */
    private static void maxHeapify(int[] arr, int index, int len) {
        int li = (index &amp;lt;&amp;lt; 1) + 1; // 左子节点索引
        int ri = li + 1;           // 右子节点索引
        int cMax = li;             // 子节点值最大索引，默认左子节点。

        if (li &amp;gt; len) return;       // 左子节点索引超出计算范围，直接返回。
        if (ri &amp;lt;= len &amp;amp;&amp;amp; arr[ri] &amp;gt; arr[li]) // 先判断左右子节点，哪个较大。
            cMax = ri;
        if (arr[cMax] &amp;gt; arr[index]) {
            Utils.exch(arr, cMax, index);
            maxHeapify(arr, cMax, len);  // 则需要继续判断换下后的父节点是否符合堆的特性。
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;73-特点&quot;&gt;7.3 特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;: 堆排序是唯一能够同时最优的利用空间和时间的方法, 在最坏情况下它也能保证&lt;code class=&quot;highlighter-rouge&quot;&gt;O(NlogN)&lt;/code&gt;的时间复杂度和恒定空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;: 在空间十分紧张(如嵌入式设别或低成本的移动设备中)十分流行, 但是由于其数据变更比较频繁, 因此无法利用缓存(缓存命中率比较低), 在现代系统的许多应用中很少使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;稳定性&lt;/strong&gt;: 不稳定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用堆还可以实现优先队列, 使得当有大量数据时, 可用较少空间即可从中筛选出指定数量的最大(小)&lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;个数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;八-小结&quot;&gt;八. 小结&lt;/h2&gt;

&lt;p&gt;上面介绍的七个排序算法都是基于&lt;strong&gt;比较&lt;/strong&gt;的, 这里再以表的形式总结如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;排序算法&lt;/th&gt;
      &lt;th&gt;是否稳定&lt;/th&gt;
      &lt;th&gt;是否为原地排序&lt;/th&gt;
      &lt;th&gt;时间复杂度&lt;/th&gt;
      &lt;th&gt;空间复杂度&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;选择排序&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;N^2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;插入排序&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;介于N和N^2之间&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;希尔排序&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;未知(NlogN / N^(5/6) ?)&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;快排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;logN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;三向快排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;介于N和NlogN之间&lt;/td&gt;
      &lt;td&gt;logN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;归并排序&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;堆排&lt;/td&gt;
      &lt;td&gt;否&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt;NlogN&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面要介绍的是线性排序; 有这样一个结论是: 没有任何基于比较的算法能够保证使用少于&lt;code class=&quot;highlighter-rouge&quot;&gt;log(N!) ~ NlogN&lt;/code&gt;次比较将长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;的数组排序; 所以这也决定了上面基于比较的排序算法的上界;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;九-计数排序&quot;&gt;九. 计数排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liyuming0000/article/details/46913357&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;十-基数排序&quot;&gt;十. 基数排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3603669.html&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;十一-桶排序&quot;&gt;十一. 桶排序&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://hxraid.iteye.com/blog/647759&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>Android动画详解</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;动画也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;系统中一个很重要的模块, 在平时开发中, 为了做出炫酷的效果, 动画可以说是必不可少的; 本文将总结&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中与动画相关的部分, 文中部分内容整理自文末参考链接, 权作笔记~&lt;/p&gt;

&lt;p&gt;需要声明的是文章不会详细通过源码去讲解各种动画的实现细节, 因为相对来说, 动画的熟练使用更为重要, 所以本文只是提一下关键的动画源码部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中动画分为三大类: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画, &lt;code class=&quot;highlighter-rouge&quot;&gt;Transition&lt;/code&gt;(过渡动画), 属性动画; 下文也将从这三个方面进行总结和讲解&lt;/p&gt;

&lt;p&gt;动画的本质实际上就是将作用对象的属性值在一段时间内缓慢的改变, 将每一个小的时间片段对应的属性值改变作用到对象并进行不断重绘, 造成肉眼看起来的的动画效果~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-view动画&quot;&gt;二. View动画&lt;/h2&gt;

&lt;h3 id=&quot;21-基本使用总结&quot;&gt;2.1 基本使用总结&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画分为四种, 如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;标签&lt;/th&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;效果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;平移动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;translate&amp;gt;&lt;/td&gt;
      &lt;td&gt;TranslateAnimation&lt;/td&gt;
      &lt;td&gt;移动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;缩放动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;scale&amp;gt;&lt;/td&gt;
      &lt;td&gt;ScaleAnimation&lt;/td&gt;
      &lt;td&gt;缩放&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;旋转动画&lt;/td&gt;
      &lt;td&gt;&amp;lt;rotate&amp;gt;&lt;/td&gt;
      &lt;td&gt;RotateAnimation&lt;/td&gt;
      &lt;td&gt;旋转&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;透明度&lt;/td&gt;
      &lt;td&gt;&amp;lt;alpha&amp;gt;&lt;/td&gt;
      &lt;td&gt;AlphaAnimation&lt;/td&gt;
      &lt;td&gt;透明度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 动画中还有一种叫&lt;strong&gt;帧动画&lt;/strong&gt;, 这里也归为&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画中, 后文单独讲解&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;描述, 也可以使用代码描述(即使用上表中的四个子类); 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;描述的语法格式如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;res/anim/filename.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;set&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:interpolator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@[package:]anim/interpolator_resource&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:shareInterpolator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[true | false]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:fillAfter=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[true | false]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;int&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:repeatMode=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[reverse | restart]&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;alpha&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromAlpha=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toAlpha=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;scale&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromXScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toXScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromYScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toYScale=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotY=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;translate&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromXDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toXDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromYDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toYDelta=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;rotate&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:fromDegrees=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:toDegrees=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotX=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;android:pivotY=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;float&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;set&amp;gt;&lt;/span&gt;
        ...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/set&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/set&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;set&amp;gt;&lt;/code&gt;代表&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimationSet&lt;/code&gt;, 可以包含若干动画&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:shareInterpolator&lt;/code&gt;: 表示集合中的动画是否和集合共享同一个插值器; 如果集合不指定插值器, 那么子动画需要单独指定或者使用默认插值器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:pivotX&lt;/code&gt;: 轴点&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;坐标&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:pivotY&lt;/code&gt;: 轴点&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;坐标&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:fillAfter&lt;/code&gt;: 动画结束之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是否停留在结束位置, &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;表示停留在结束位置, &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;表示不停留&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在代码中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Button button = findViewById(R.id.button);
Animatoin animation = AnimationUtils.loadAnimation(this, R.anim.animation_item);
button.startAnimation(animation);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-自定义view动画&quot;&gt;2.2 自定义View动画&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TranslateAnimation&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ScaleAnimation&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RotateAnimation&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;AlphaAnimation&lt;/code&gt;都继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation&lt;/code&gt;; 如果要自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画的话, 也需要继承&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation&lt;/code&gt;, 并重写&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation.initialize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Animation.applyTransformation()&lt;/code&gt;方法; &lt;code class=&quot;highlighter-rouge&quot;&gt;initialize()&lt;/code&gt;顾名思义就是进行一些初始化工作, 比如设置属性的初始值等, &lt;code class=&quot;highlighter-rouge&quot;&gt;applyTransformation()&lt;/code&gt;就是根据时间的流失量来计算出当前时间片段所对应的属性值, 并设置到对应的作用对象(对于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画来说该对象就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;); 这里的设置往往是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix&lt;/code&gt;来作用的, 如下以&lt;code class=&quot;highlighter-rouge&quot;&gt;TranslateAnimation.applyTransformation()&lt;/code&gt;为例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
        float dx = mFromXDelta;
        float dy = mFromYDelta;
        if (mFromXDelta != mToXDelta) {
            dx = mFromXDelta + ((mToXDelta - mFromXDelta) * interpolatedTime);  // 通过时间流失量计算出x的改变量
        }
        if (mFromYDelta != mToYDelta) {
            dy = mFromYDelta + ((mToYDelta - mFromYDelta) * interpolatedTime);  // 通过时间流失量计算出y的改变量
        }
        t.getMatrix().setTranslate(dx, dy);  // 通过Matrix作用到对象
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码其实也可以当做自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画的模板代码, 自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画时, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;来配合计算改变量; 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Camera&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Matrix&lt;/code&gt;的使用, 可以参见&lt;a href=&quot;https://hencoder.com/ui-1-4/&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-帧动画&quot;&gt;2.3 帧动画&lt;/h3&gt;

&lt;p&gt;帧动画就是顺序播放一组预先定义好的图片, 系统提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimationDrawable&lt;/code&gt;来使用帧动画&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;定义如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;/res/drawable/filename.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;animation-list&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:oneshot=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;item&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:drawable=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@drawable/item&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:duration=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/animation-list&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用帧动画时, 当图片较多或者较大时可能引起&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-transition过渡动画&quot;&gt;三. Transition(过渡动画)&lt;/h2&gt;

&lt;p&gt;过渡动画其实是用于控制&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;的出场效果, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;之间的切换效果等&lt;/p&gt;

&lt;h3 id=&quot;31-layoutanimation&quot;&gt;3.1 LayoutAnimation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;实现格式如下:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 位置为&lt;code class=&quot;highlighter-rouge&quot;&gt;/res/anim/anim_layout.xml&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;layoutAnimation&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:android=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:delay=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0.5&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:animationOrder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;[normal | reverse | random]&quot;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;android:animation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@anim/anim_item&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:delay&lt;/code&gt;: 子元素延迟多少时间执行动画; 比如子元素入场动画时间周期为&lt;code class=&quot;highlighter-rouge&quot;&gt;300ms&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;0.5&lt;/code&gt;表示每个每个子元素都需要延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;150ms&lt;/code&gt;才能播放入场动画, 总体来说, 第一个子元素延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;150ms&lt;/code&gt;开始播放动画, 第二个子元素延迟&lt;code class=&quot;highlighter-rouge&quot;&gt;300ms&lt;/code&gt;开始播放动画, 以此类推&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;android:animationOrder&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;normal&lt;/code&gt;表示顺序显示, 即排在前面的子元素先开始动画; &lt;code class=&quot;highlighter-rouge&quot;&gt;reverse&lt;/code&gt;表示逆向显示; &lt;code class=&quot;highlighter-rouge&quot;&gt;random&lt;/code&gt;表示随机显示&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当定义好&lt;code class=&quot;highlighter-rouge&quot;&gt;layoutAnimation&lt;/code&gt;之后, 在布局文件中就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;android:layoutAnimation=&quot;@anim/anim_layout&quot;&lt;/code&gt;来指定入场动画了~&lt;/p&gt;

&lt;p&gt;代码实现, 格式如下: 即通过&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutAnimationController&lt;/code&gt;实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ListView listView = findViewById(R.id.list);
Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item);
LayoutAnimationController controller = new LayoutAnimationController(animation);
controller.setDelay(0.5f);
controller.setOrder(LayoutAnimationController.ORDER_NORMAL);
listView.setLayoutAnimation(controller);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-activity的切换效果&quot;&gt;3.2 Activity的切换效果&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;当启动一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的时候, 可以按照如下方式为其添加自定义的切换效果:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent intent = new Intent(this, AnimActivity.class);
startActivity(intent);
overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;退出时, 可以如下添加切换效果:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Override
    public void finish() {
        super.finish();
        overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出, 都是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;overridePendingTransition()&lt;/code&gt;来指定切换动画, 同时需要注意的是这个方法必须在&lt;code class=&quot;highlighter-rouge&quot;&gt;startActivity(intent)&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;finish()&lt;/code&gt;之后被调用才能生效&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;Fragment&lt;/code&gt;添加切换动画: 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentTransaction.setCustomAnimations()&lt;/code&gt;来添加切换动画; 需要注意的是该动画必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画, 不能用属性动画(因为属性动画在&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;引入, &lt;code class=&quot;highlighter-rouge&quot;&gt;Fragment&lt;/code&gt;也是&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;才引入的)&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-属性动画&quot;&gt;四. 属性动画&lt;/h2&gt;

&lt;p&gt;属性动画是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;API 11&lt;/code&gt;)开始引入的; 属性动画可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;xml&lt;/code&gt;实现, 也可以用代码实现, 但是一般都是用代码实现&lt;/p&gt;

&lt;h3 id=&quot;41-基本使用&quot;&gt;4.1 基本使用&lt;/h3&gt;

&lt;h4 id=&quot;411-viewpropertyanimator&quot;&gt;4.1.1 ViewPropertyAnimator&lt;/h4&gt;

&lt;p&gt;操作&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;属性值, 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;View.animate()&lt;/code&gt;来获取一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;对象, 然后就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;来操作该对象的属性值了~  可以操作的属性值参见下图(图片来源, 参见文末参考链接):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Animation/ViewPropertyAnimator属性动画.png&quot; alt=&quot;ViewPropertyAnimator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用示例如&lt;code class=&quot;highlighter-rouge&quot;&gt;View.animate().setDuration(500).alpha(0.5);&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;412-objectanimator&quot;&gt;4.1.2 ObjectAnimator&lt;/h4&gt;

&lt;p&gt;也是针对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的特定属性, 同时还要求该属性提供了对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法, 基本使用如下; 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;是通过属性的&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法来不断改变属性值的, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法是一定需要的, 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法只是用于获取动画开始的初始值的, 如果明确指定了初始值的话, 也可以提供&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法(如果没有提供&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法, 同时又没有指定初始值的话, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;; 如果没有&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法, 不会&lt;code class=&quot;highlighter-rouge&quot;&gt;Crash&lt;/code&gt;, 只是没有效果而已)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ObjectAnimator animator = ObjectAnimator.ofFloat(view, &quot;alpha&quot;, 0, 65);
animator.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果一个属性没有&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;方法的话, 解决方法有以下三种:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果有权限的话, 自己给对象加上&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用一个类来包装原始对象, 间接为其提供&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采用&lt;code class=&quot;highlighter-rouge&quot;&gt;ValueAnimator&lt;/code&gt;, 监听动画过程, 自己实现属性改变&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;42-插值器&quot;&gt;4.2 插值器&lt;/h3&gt;

&lt;p&gt;所谓插值器就是属性改变的速度, 系统提供了如下插值器:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AccelerateDecelerateInterpolator&lt;/td&gt;
      &lt;td&gt;LinearInterpolator&lt;/td&gt;
      &lt;td&gt;AccelerateInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DecelerateInterpolator&lt;/td&gt;
      &lt;td&gt;AnticipateInterpolator&lt;/td&gt;
      &lt;td&gt;OvershootInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AnticipateOvershootInterpolator&lt;/td&gt;
      &lt;td&gt;BounceInterpolator&lt;/td&gt;
      &lt;td&gt;CycleInterpolator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PathInterpolator&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutLinearInInterpolator&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutSlowInInterpolator&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearOutSlowInInterpolator&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutLinearInInterpolator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;FastOutSlowInInterpolator&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinearOutSlowInInterpolator&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 5.0(API 21)&lt;/code&gt;引入的三个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Interpolator&lt;/code&gt;模型, 并把它们加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;support v4&lt;/code&gt;包中&lt;/p&gt;

&lt;p&gt;关于各种插值器的讲解, 可以参见&lt;a href=&quot;https://hencoder.com/ui-1-6/&quot;&gt;博客&lt;/a&gt;, 该博客讲的比较详细, 此处不再赘述~&lt;/p&gt;

&lt;h3 id=&quot;43-估值器&quot;&gt;4.3 估值器&lt;/h3&gt;

&lt;p&gt;估值器即&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeEvaluator&lt;/code&gt;, 作用是根据当前属性改变的百分比来计算改变后的属性值, 用于协助插值器实现非线性运动; 系统提供了如下估值器:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IntEvaluator&lt;/td&gt;
      &lt;td&gt;IntArrayEvaluator&lt;/td&gt;
      &lt;td&gt;FloatEvaluator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FloatArrayEvaluator&lt;/td&gt;
      &lt;td&gt;ArgbEvaluator&lt;/td&gt;
      &lt;td&gt;PointFEvaluator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RectEvaluator&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果要对其他类型做动画(非&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Color&lt;/code&gt;), 那么需要自定义类型估值算法, 即继承&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeEvaluator&lt;/code&gt;自己实现其&lt;code class=&quot;highlighter-rouge&quot;&gt;evaluate()&lt;/code&gt;方法即可&lt;/p&gt;

&lt;p&gt;估值器基本使用如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ObjectAnimator anim = ObjectAnimator.ofObject(view, &quot;alpha&quot;, new FloatEvaluator(), 0, 1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;44-监听器&quot;&gt;4.4 监听器&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;设置监听器的方法如下表:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ViewPropertyAnimator&lt;/td&gt;
      &lt;td&gt;setListener()&lt;/td&gt;
      &lt;td&gt;setUpdateListener()&lt;/td&gt;
      &lt;td&gt;withStartAction()&lt;/td&gt;
      &lt;td&gt;withEndAction()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ObjectAnimator&lt;/td&gt;
      &lt;td&gt;addListener()&lt;/td&gt;
      &lt;td&gt;addUpdateListener()&lt;/td&gt;
      &lt;td&gt;addPauseListener()&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setUpdateListener()&lt;/code&gt;来设置监听器, 移除监听器可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setListener(null)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setUpdateListener(null)&lt;/code&gt;来移除; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;独有的&lt;code class=&quot;highlighter-rouge&quot;&gt;withStartAction()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt; 方法, 可以设置&lt;strong&gt;一次性&lt;/strong&gt;(动画结束后就自动弃掉了, 即一次有效)的动画开始或结束的监听&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;则是用&lt;code class=&quot;highlighter-rouge&quot;&gt;addListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addUpdateListener()&lt;/code&gt;来添加一个或多个监听器, 移除监听器则是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;removeListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;removeUpdateListener()&lt;/code&gt;来指定移除对象; &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectAnimator&lt;/code&gt;支持使用&lt;code class=&quot;highlighter-rouge&quot;&gt;pause()&lt;/code&gt;方法暂停, 所以它还多了一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;addPauseListener()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;removePauseListener()&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator.withStartAction/EndAction()&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;的独有方法, 它们和&lt;code class=&quot;highlighter-rouge&quot;&gt;set/addListener()&lt;/code&gt;中回调的 &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationStart()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;相比起来的不同主要有两点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;withStartAction()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt;是一次性的, 在动画执行结束后就自动弃掉了, 就算之后再重用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt; 来做别的动画, 用它们设置的回调也不会再被调用; 而&lt;code class=&quot;highlighter-rouge&quot;&gt;set/addListener()&lt;/code&gt;所设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener&lt;/code&gt;是持续有效的, 当动画重复执行时, 回调总会被调用&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;withEndAction()&lt;/code&gt;设置的回调只有在动画正常结束时才会被调用, 而在动画被取消时不会被执行; 这点和&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener.onAnimationEnd()&lt;/code&gt; 的行为是不一致的&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;监听器方法有:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;AnimatorListener&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;onAnimationStart()&lt;/td&gt;
      &lt;td&gt;onAnimationEnd()&lt;/td&gt;
      &lt;td&gt;onAnimationCancel()&lt;/td&gt;
      &lt;td&gt;onAnimationRepeat()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 即使动画通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cancle()&lt;/code&gt;方法取消, &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;也会被调用; 所以当动画被取消时, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;AnimatorListener&lt;/code&gt;, 那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationCancel()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;都会被调用; &lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationCancel()&lt;/code&gt;会先于&lt;code class=&quot;highlighter-rouge&quot;&gt;onAnimationEnd()&lt;/code&gt;被调用; 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;不支持重复, 所以这个方法对&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewPropertyAnimator&lt;/code&gt;相当于无效&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-动画注意事项&quot;&gt;五. 动画注意事项&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;避免使用帧动画, 易造成&lt;code class=&quot;highlighter-rouge&quot;&gt;OOM&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动画需要考虑暂停和取消; 属性动画中有一类无线循环的动画, 这类动画在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;退出时要及时停止, 否则将导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;无法释放从而造成内存泄露; 通过验证后发现&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画无此问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画之后可能会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;无法隐藏的现象, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;setVisibility(View.GONE)&lt;/code&gt;失效了, 此时可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;view.clearAnimation()&lt;/code&gt;来清除&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;以前系统, 不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画还是属性动画, 都只是作用于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;内容(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Android 3.0&lt;/code&gt;以前, 属性动画底层其实也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画实现的), 新位置无法触发单击事件; 从&lt;code class=&quot;highlighter-rouge&quot;&gt;3.0&lt;/code&gt;开始, 属性动画的单击事件触发位置为移动后的位置, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;动画仍然在原位置&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考&quot;&gt;六. 参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;«Android开发艺术探索»&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://hencoder.com/ui-1-6/&quot;&gt;属性动画 Property Animation&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 04 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/04/Android%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/04/Android%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Java类文件结构与类加载机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第六章第七章以及其他博客的总结, 权做笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-类文件结构&quot;&gt;一. 类文件结构&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件是一组以&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节为基础单位的二进制流, 当遇到需要占据&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节进行存储&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式采用一种类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型: 无符号数和表; 无符号数是基本数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;u1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u4&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u8&lt;/code&gt;来分别代表&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个字节,&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个字节, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节和&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节的无符号数, 无符号数可以用来描述数字, 索引引用, 数量值或者按照&lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;编码构成字符串值; 表由多个无符号数或者其他表作为数据项构成的复合数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;_info&lt;/code&gt;结尾&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中没有分隔符, 所以哪个字节代表什么含义, 长度是多少, 先后顺序如何, 都被严格限定且不允许改变&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式见下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;数量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u4&lt;/td&gt;
      &lt;td&gt;magic&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;minor_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;major_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;constant_pool_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cp_info&lt;/td&gt;
      &lt;td&gt;constant_pool&lt;/td&gt;
      &lt;td&gt;constant_pool_count-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;access_flags&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;this_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;super_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;field_info&lt;/td&gt;
      &lt;td&gt;fields&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;method_info&lt;/td&gt;
      &lt;td&gt;methods&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attribute_info&lt;/td&gt;
      &lt;td&gt;attributes&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;11-简介&quot;&gt;1.1 简介&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;魔数&lt;/strong&gt;: 每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件头&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节称为魔数, 唯一作用是确定该文件是否是一个能被虚拟机接受的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;: 紧接着魔数的四个字节存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件的版本号: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个字节是次版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor Version&lt;/code&gt;), 第&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节是主版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Major Version&lt;/code&gt;); 虚拟机必须拒绝执行超过其版本号的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;常量池&lt;/strong&gt;: 紧接着主版本号之后的是常量池入口, 是一个表类型数据项; &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中只有常量池的容量计数是从&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;开始的; 常量池中主要存放两大类常量: 字面量和符号引用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;字面量: 如: 文本字符串, 声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的常量值等&lt;/li&gt;
    &lt;li&gt;符号引用: 类和接口的全限定名; 字段的名称和描述符; 方法的名称和描述符&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;访问标志&lt;/strong&gt;: 常量池结束之后, 紧接着的两个字节代表访问标志; 用于表示一些类或者接口的层次信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;类索引, 父类索引和接口索引集合&lt;/strong&gt;: 用于确定类的继承关系; 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;之外, 所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类都有父类, 因此除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;外, 所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的父类索引都不为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;字段表&lt;/strong&gt;: 描述接口或者类中声明的变量; 字段包括类级变量以及实例级变量, 但不包括方法内部声明的局部变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;方法表&lt;/strong&gt;: 包括访问标志, 名称索引, 描述符索引, 属性表集合; 如果父类方法在子类中没有被重写, 方法表集合中就不会出现来自父类的方法信息, 但是, 同样的, 有可能会出现由编译器自动添加的方法, 最典型的便是类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;方法和实例构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;属性表&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机运行时会忽略掉它不认识的属性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-常见问题&quot;&gt;1.2 常见问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中方法, 字段等都需要引用&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量来描述名称, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量的最大长度也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中方法, 字段名的最大长度; &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;类型能表达的最大值是&lt;code class=&quot;highlighter-rouge&quot;&gt;65535&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-虚拟机类加载机制&quot;&gt;二. 虚拟机类加载机制&lt;/h2&gt;

&lt;h3 id=&quot;21-类加载的时机&quot;&gt;2.1 类加载的时机&lt;/h3&gt;

&lt;p&gt;类从被加载到虚拟机内存中开始, 到卸载出内存为止, 其生命周期如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/类的生命周期.png&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, 加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, 解析阶段则不一定: 在某些情况下, 可以在初始化阶段之后再&lt;strong&gt;开始&lt;/strong&gt;(注意, 是开始, 而不是&lt;em&gt;进行&lt;/em&gt;或者&lt;em&gt;完成&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;遇到以下五种情况必须立即对类进行&lt;em&gt;初始化&lt;/em&gt;(而加载, 验证, 准备自然要在这之前完成):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getstatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;putstatic&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;invokestatic&lt;/code&gt;这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条字节码指令时, 如果类没有初始化, 需要出发初始化; 生成这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条指令的常见&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;代码场景是: 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字实例化对象的时候, 读取或设置一个类的静态字段的时候(注意: 被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰, 已在编译期把结果放入常量池的静态字段除外(由此可见, 添加&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰可以避免不必要的类加载)), 以及调用一个类的静态方法的时候&lt;/li&gt;
    &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;包的方法对类进行反射调用的时候&lt;/li&gt;
    &lt;li&gt;当初始化一个类, 如果发现其父类没有初始化, 则需先初始化其父类&lt;/li&gt;
    &lt;li&gt;虚拟机启动时, 用户需要指定一个要执行的主类(&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;所在的类), 虚拟机会先初始化这个主类&lt;/li&gt;
    &lt;li&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.7&lt;/code&gt;的动态语言支持(比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Groovy&lt;/code&gt;等)时, 如果一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例最后的解析结果&lt;code class=&quot;highlighter-rouge&quot;&gt;REF_getStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_putStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_invokeStatic&lt;/code&gt;的方法句柄, 并且这个方法句柄所对应的类没有进行过初始化, 则需先触发其初始化&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;22-主动引用与被动引用&quot;&gt;2.2 主动引用与被动引用&lt;/h3&gt;

&lt;h4 id=&quot;221-构造函数-代码块-静态代码块的执行时机&quot;&gt;2.2.1 构造函数, 代码块, 静态代码块的执行时机&lt;/h4&gt;

&lt;p&gt;考虑下列代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Practice {

    static {
        System.out.println(&quot;Practice static code block&quot;);
    }

    {
        System.out.println(&quot;Practice code block&quot;);
    }

    public Practice() {
        System.out.println(&quot;Practice constructor&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Practice&lt;/code&gt;对象时, 输出如下; 说明三者的执行顺序是: 静态代码块 –&amp;gt; 代码块 –&amp;gt; 构造函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Practice static code block
Practice code block
Practice constructor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于三者的执行时机与作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;静态代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;用于给类初始化, 随着类的加载而执行, 只执行一次&lt;/li&gt;
    &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前执行&lt;/li&gt;
    &lt;li&gt;一个类可以有多个静态代码块&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;实例对象相关, 给所有对象进行统一初始化(因为构造函数可以重载)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;初始化实例&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;222-被动引用示例&quot;&gt;2.2.2 被动引用示例&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面所说的触发初始化的五个场景对应叫做主动引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;通过子类引用父类的静态字段, 不会导致子类初始化: 对于静态字段, 只有直接定义这个字段的类才会被初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);  // 不会初始化子类~
    }
}

class SuperClass {
    static {
        System.out.println(&quot;SuperClass init&quot;);
    }

    public static int value = 123;
}

class SubClass extends SuperClass{
    static {
        System.out.println(&quot;Child init&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 后文为节省篇幅, 将重用这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;SuperClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SubClass&lt;/code&gt;, 而不再重写~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过数组定义来引用类, 不会触发此类的初始化: 虚拟机会为数组自动生成一个直接继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的子类; &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中对数组的访问比&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;更安全, 是因为这个类封装了数组元素的访问方法, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;直接翻译为数组指针的移动&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[0];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;常量在编译阶段会存入被调用类的常量池中, 本质上并没有直接引用到常量的类, 因此不会出发定义常量的类的初始化: 在编译阶段经过常量传播优化, 已经将次&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World&lt;/code&gt;常量存储到了&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类的常量池中了, 以后&lt;code class=&quot;highlighter-rouge&quot;&gt;Initialization&lt;/code&gt;对常量&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstClass.HELLOWORLD&lt;/code&gt;的引用都被转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类对自身常量池的引用了~&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.CONST);
    }
}

class ConstClass {
    static {
        System.out.println(&quot;ConstClass init&quot;);
    }

    public static final String HELLOWORLD=&quot;Hello World&quot;; // 注意这里不能从static来理解, 因为即使有static, 但是没有final的话仍然会触发ConstClass的初始化~
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-类的加载过程&quot;&gt;2.3 类的加载过程&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;结合前面的图咯~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-加载&quot;&gt;2.3.1 加载&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内存中生成一个代表这个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象(该&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象并没有明确规定是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;HotSpot&lt;/code&gt;虚拟机而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象比较特殊, 它虽然是对象, 但是存在于方法区中), 作为方法区这个类的各种数据的访问入口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;232--验证&quot;&gt;2.3.2  验证&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;文件格式验证:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否以魔数&lt;code class=&quot;highlighter-rouge&quot;&gt;0xCAFEBABE&lt;/code&gt;开头&lt;/li&gt;
    &lt;li&gt;主, 次版本号是否在当前虚拟机处理范围之内&lt;/li&gt;
    &lt;li&gt;常量池的常量中是否有不被支持的类型
….&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;元数据验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否有父类&lt;/li&gt;
    &lt;li&gt;是否继承了不允许被继承的父类(被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的父类)&lt;/li&gt;
    &lt;li&gt;如果这个类不是抽象类, 是否实现其父类或接口中要求实现的所有方法&lt;/li&gt;
    &lt;li&gt;是否非法覆盖(&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;方法), 重载是否正确
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;字节码验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;对类的方法体进行校验分析, 保证被校验的类在运行时不会危害虚拟机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;符号引用验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;符号引用中通过字符串描述的全限定名是否能找到对应的父类&lt;/li&gt;
    &lt;li&gt;符号引用中的类, 字段, 方法的访问性是否可以被当前类访问&lt;/li&gt;
    &lt;li&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;233-准备&quot;&gt;2.3.3 准备&lt;/h4&gt;

&lt;p&gt;正式为类变量分配内存并为其设置初始值&lt;/p&gt;

&lt;h4 id=&quot;234-解析&quot;&gt;2.3.4 解析&lt;/h4&gt;

&lt;p&gt;将常量池中的符号引用替换为直接引用&lt;/p&gt;

&lt;h4 id=&quot;235-初始化&quot;&gt;2.3.5 初始化&lt;/h4&gt;

&lt;p&gt;真正开始执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序代码(字节码)或者说初始化阶段是执行类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程&lt;/p&gt;

&lt;h5 id=&quot;235-1-类构造器方法&quot;&gt;2.3.5-1 类构造器&lt;clinit&gt;()方法&lt;/clinit&gt;&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;代码块)中的语句合并产生的; 静态语句块只能访问到定义在静态语句块之前的变量, 定义在它之后的变量, 在前面的静态语句块可以赋值, 但是不能访问, 如下代码&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Temp {
    static {
        value = 2;
//        System.out.println(value); // 不能访问
    }

    static int value = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法与构造函数(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;)不同, 虚拟机会保证子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法执行之前, 父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法已经执行完毕; 因此在虚拟机中第一个被执行的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的类肯定是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法先于子类的执行, 也就意味着父类中的静态语句块要先于子类的变量赋值操作; 注意如下代码;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SuperClass {
    public static int A = 1;
    static {
        A = 2;
    }
}

class SubClass extends SuperClass{
    public static int B = A; // 注意这里的B应该为2, 而不是1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法对于类或接口来说不是必需的, 如果一个类没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接口中不能有静态语句块, 但是可以有变量的初始化赋值操作, 因此接口与类一样也会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法; 但接口与类不同的是, 执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法不需要先执行父接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法, 只有当父接口中定义的变量使用时, 父接口才会初始化; 另外, 接口的实现类在初始化时也一样不会执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机会保证一个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法在多线程环境中被正确的加锁, 同步; 只能有一个线程去执行&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-类加载器&quot;&gt;2.4 类加载器&lt;/h3&gt;

&lt;p&gt;任意一个类, 都是由加载它的类加载器和这个类本身一同确立其在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中的唯一性; 更通俗一些是: 比较两个类是否&lt;em&gt;相等&lt;/em&gt;, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来自同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件, 被同一个虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等(这里所谓的相等, 包括代表&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isAssignableFrom()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInstance()&lt;/code&gt;方法的返回结果, 以及使用&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;关键字做对象所属关系判断等情况); 如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.io.InputStream;

public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = new ClassLoader() {
            @Override
            public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;
                    InputStream inputStream = getClass().getResourceAsStream(fileName);
                    if (inputStream == null) {
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name, bytes, 0, bytes.length);
                } catch (IOException e) {
                }
                return null;
            }
        };

        Object obj = loader.loadClass(&quot;Practice&quot;).newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof Practice); // 及时是Practice实例, 但是这里仍然返回false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-双亲委派模型&quot;&gt;2.5 双亲委派模型&lt;/h3&gt;

&lt;h4 id=&quot;251-类加载器分类&quot;&gt;2.5.1 类加载器分类&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Bootstrap ClassLoader&lt;/code&gt;): &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现, 虚拟机自身一部分&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Extension ClassLoader&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用程序类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application ClassLoader&lt;/code&gt;): 如果没有定义自己的类加载器, 则为程序中默认的类加载器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;252-双亲委派模型含义&quot;&gt;2.5.2 双亲委派模型含义&lt;/h4&gt;

&lt;p&gt;如下图; 双亲委派模型要求除了顶层的启动类加载器外, 其余的类加载器都应当有自己的父类加载器;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/双亲委派模型.png&quot; alt=&quot;双亲委派模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此; 因此所有的加载请求最终都应该传送到顶层的启动类加载器中, 只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时, 子加载器才会尝试自己去加载&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/02/JVM%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/02/JVM%E4%B9%8B%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java垃圾收集器与内存分配策略</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文为«深入理解Java虚拟机»第三章以及部分博客内容总结, 权作个人笔记~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自: http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-对象是否死亡&quot;&gt;一. 对象是否死亡&lt;/h2&gt;

&lt;p&gt;进行垃圾收集首先需要的就是判断对象是否死亡, 也就是是否可以清除收集, 下面将讲解判断对象是否死亡的方法&lt;/p&gt;

&lt;h3 id=&quot;11-引用计数算法&quot;&gt;1.1 引用计数算法&lt;/h3&gt;

&lt;h4 id=&quot;111-原理&quot;&gt;1.1.1 原理&lt;/h4&gt;

&lt;p&gt;给对象添加一个引用计数, 每当有一个地方引用它, 计数器值就加&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 当引用失效时, 计数器值就减&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 任何时刻计数器值为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的对象就是不可能再被使用的&lt;/p&gt;

&lt;h4 id=&quot;112-优缺点&quot;&gt;1.1.2 优缺点&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;: 实现简单, 效率高&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;: 无法解决循环引用的问题, 如下;&lt;/p&gt;

&lt;p&gt;主流&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有使用引用计数来管理内存的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ReferenceCountingGC {

    public Object instance = null;
    private final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB]; // 占用内存, 以便GC日志中看清楚是否被回收过

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-可达性分析算法&quot;&gt;1.2 可达性分析算法&lt;/h3&gt;

&lt;h4 id=&quot;121-原理&quot;&gt;1.2.1 原理&lt;/h4&gt;

&lt;p&gt;通过一系列成为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象作为起始点, 从这些节点开始往下搜索, 搜索走过的路径称为引用链, 当一个对象到&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;没有任何引用链相连时, 则证明此对象是不可引用的; 如下图(&lt;a href=&quot;https://llag9810.github.io/2017/12/04/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;图片来自&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/GcRoot.png&quot; alt=&quot;GC Root&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可作为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中类静态属性引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中常量引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地方法栈中&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法)引用的变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用可达性分析算法时, 至少需要经过两次标记过程才能宣告一个对象真正死亡: 如果对象在进行可达性分析后发现没有与&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;相连接的引用链, 那它会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 当对象没有覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法时, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法已经被虚拟机调用过, 虚拟机将这两种情况都视为没有必要执行(也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法最多执行一次, 这点需要注意~);
如果这个对象被判定为有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 那么这个对象将会放置在一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;F-Queue&lt;/code&gt;的队列中, 并在稍后由一个由虚拟机自动建立, 低优先级的&lt;code class=&quot;highlighter-rouge&quot;&gt;Finalizer&lt;/code&gt;线程去执行它, 但并不承诺会等待&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法运行结束(这里也需要注意, 这是为了防止&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中出现耗时操作甚至死循环); 在&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中对象可以使自己再次加入引用链中, 逃脱&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; &lt;strong&gt;但是不建议使用该方法来逃脱GC&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FinalizeEscapeGC {
    public static FinalizeEscapeGC finalizeEscapeGC = null;

    int count = 0;

    public void isAlive() {
        System.out.println(&quot;Yes, I am alive :) &quot;);
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed&quot;);
        FinalizeEscapeGC.finalizeEscapeGC = this; // 再次进入引用链
        // 经过验证, 虚拟机不会等待finalize()执行完毕
//        while (true) {
//            System.out.println(count++);
//        }
    }

    public static void main(String[] args) throws InterruptedException {
        finalizeEscapeGC = new FinalizeEscapeGC();
        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }

        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述程序运行结果为: 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;确实被调用了, 而且只被调用了一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;finalize method executed
Yes, I am alive :)
No, I am dead :(
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-再谈引用&quot;&gt;1.3 再谈引用&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;以前, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;引用很传统: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;类型的数据中存储的数值代表的是另一块内存的起始地址, 就称这块内存代表着一个引用&lt;/p&gt;

&lt;p&gt;但是实际我们希望的是: 当内存空间还足够时, 能够保留在内存中; 当内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃某些对象&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;之后, 扩充了引用概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 以下引用强度递减&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;强引用: 类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Object obj = new Object()&lt;/code&gt;的引用; 这类引用永远不会被垃圾收集器回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软引用: 有用但非必需的对象; 在系统将要发生内存溢出之前, 将回收这部分对象, 如果回收之后内存仍然不够, 才会内存溢出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;弱引用: 无论当前内存是否足够都会回收掉只被弱引用关联的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚引用: 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过一个虚引用来取得对象实例; 为一个对象设置虚引用关联的唯一目的是能在这个对象被收集器回收之前收到一个系统通知&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;14-方法区回收&quot;&gt;1.4 方法区回收&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;的主要区域是堆, 但是方法区也会进行&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; 方法区的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;主要是废弃常量和无用的类&lt;/p&gt;

&lt;p&gt;废弃常量好理解, 和堆中对象回收一样, 没有引用即回收&lt;/p&gt;

&lt;p&gt;无用类需要满足条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;该类的所有实例都已经被回收, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中不存在该类的任何实例&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载该类的&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;已经被回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;该类对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-垃圾收集算法&quot;&gt;二. 垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&quot;21-标记-清除算法mark-sweep&quot;&gt;2.1 标记-清除算法(Mark-Sweep)&lt;/h3&gt;

&lt;h4 id=&quot;211-原理&quot;&gt;2.1.1 原理&lt;/h4&gt;

&lt;p&gt;先标记, 后回收咯&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记清除算法.png&quot; alt=&quot;标记清除算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;212-优缺点&quot;&gt;2.1.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标记和清除的效率都不高&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;产生大量不连续的内存碎片&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-复制算法&quot;&gt;2.2 复制算法&lt;/h3&gt;

&lt;p&gt;多用于新生代&lt;/p&gt;

&lt;h4 id=&quot;221-原理&quot;&gt;2.2.1 原理&lt;/h4&gt;

&lt;p&gt;将内存分成相等的两块, 每次只使用其中一块, 当这一块用完了, 就将还存活的对象复制到另一块, 然后把使用过的内存空间一次清掉&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/复制算法.png&quot; alt=&quot;复制算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;222-优缺点&quot;&gt;2.2.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;效率高, 无碎片&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每次可使用内存减半&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;23-标记-整理算法&quot;&gt;2.3 标记-整理算法&lt;/h3&gt;

&lt;p&gt;多用于老年代&lt;/p&gt;

&lt;h4 id=&quot;231-原理&quot;&gt;2.3.1 原理&lt;/h4&gt;

&lt;p&gt;让所有存活对象都向一端移动, 然后清理掉端边界以外的内存&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记整理算法.png&quot; alt=&quot;标记整理算法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-分代收集算法&quot;&gt;2.4 分代收集算法&lt;/h3&gt;

&lt;h4 id=&quot;241-分代&quot;&gt;2.4.1 分代&lt;/h4&gt;

&lt;p&gt;分代的依据是: 不同对象的生命周期不同; 因此不同对象可以采用不同的回收方式, 以便提高回收效率; 因为如果每次都对整个堆进行回收遍历的话, 对于生命周期较长的对象而言, 实际上有很多次回收都是不必要和没用的&lt;/p&gt;

&lt;p&gt;分代:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/分代.png&quot; alt=&quot;分代&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分为年轻代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Young Generation&lt;/code&gt;), 老年代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Old Generation&lt;/code&gt;)和永久代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Permanent Generation&lt;/code&gt;); 永久代主要存放的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的类信息, 与垃圾收集要收集的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象关系不大; 年轻代和老年代的划分是对垃圾收集影响比较大的&lt;/p&gt;

&lt;h4 id=&quot;242-原理&quot;&gt;2.4.2 原理&lt;/h4&gt;

&lt;p&gt;新生代采用复制算法, 有老年代作空间担保; 老年代中因为对象存活率高, 没有额外空间对它进行分配担保, 就必须使用&lt;strong&gt;标记-清理&lt;/strong&gt;或者&lt;strong&gt;标记-整理&lt;/strong&gt;算法&lt;/p&gt;

&lt;p&gt;关于分代收集算法更详细信息, 可以参见博客: http://hllvm.group.iteye.com/group/wiki/2863-JVM&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-内存分配与回收策略&quot;&gt;三. 内存分配与回收策略&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对象优先在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;分配, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;没有足够空间时, 将发起一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;指发生在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;, 较为频繁, 但是速度也快; &lt;code class=&quot;highlighter-rouge&quot;&gt;Major GC&lt;/code&gt;指的是发生在老年代的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;指的是发生在整个堆空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;, 包括老年代和新生代)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大对象直接进入老年代, 这是为了防止在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;和两个&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区之间发生大量的内存复制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;长期存活的对象直接进入老年代; 虚拟机给每个对象定义一个年龄计数器, 如果对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;区出生并经过第一&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;后仍然存活, 并且能被&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区容纳, 将被移到&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中, 并且对象年龄设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中没度过一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;, 年龄就增&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 当其年龄达到一定程度(默认&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;岁), 则移入老年代&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态对象年龄判定, 如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间中相同年龄所有对象大小的总和大于&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 而不必等到年龄达到阈值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间分配担保: 因为新生代采用复制算法, 可能会出现复制空间不足的情况, 老年代可以为新生代作内存空间担保&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四-others&quot;&gt;四. Others&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里提一些其他的要点~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时会发生&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop the World&lt;/code&gt;, 由此可以联想, 也有可能由于&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;造成的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;白屏~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全点和安全区: 引用关系不变; &lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;只有在程序执行达到安全点或者安全区的时候才能进行; 如何让所有线程都跑到最近的安全点? 有两种方法: 抢先式中断(&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时, 首先把所有线程全部中断, 如果发现有线程不在安全点上, 则恢复该线程, 让它跑到安全点)和主动式中断(&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时, 不直接对线程中断, 仅仅简单地设置一个标志, 各个线程执行时主动去轮询该标志, 发现该标志为真时就自己中断挂起)(多采用主动式中断)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-参考链接&quot;&gt;五. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之常用工具</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将要讲解的是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中常用的一些工具类&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-canvas&quot;&gt;一. Canvas&lt;/h2&gt;

&lt;p&gt;drawXXX: 绘制相关&lt;/p&gt;

&lt;p&gt;clipXXX: 裁剪; 使用裁剪的时候, 通常需要配合save()和restore()一起使用, 否则之后所有的绘制都会被裁剪
范围裁切有两个方法： clipRect() 和 clipPath()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;几何变换(平移, 旋转, 伸缩等):&lt;/p&gt;

&lt;p&gt;几何变换的使用大概分为三类：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 Canvas 来做常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Matrix 来做常见和不常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Camera 来做三维变换。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Matrix; 或者自带的translate(), rotate(), scale(), skew()(错切); 
需要注意的是, Canvas自带的几何变换是倒序的, 比如: 如果translate()在rotate()前面, 则实际执行顺序是先rotate(), 再translate(); 
Canvas自带的几何变换内部其实也是使用的Matrix
Matrix可以自定义执行顺序, 通常Matrix的方法都是成对的, 比如: preTranslate()(往前插入)和postTranslate()(往后插入)
Camare可以用于辅助Matrix计算; 比如: 如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onDraw(Canvas canvas) {
    canvas.save();

    camare.save();
    camare.rotateX(30);
    canvas.translate(centerX, centerY); // 注意这里的顺序要倒着, 因为上面说了, Canvas几何变换的顺序是倒着的
    camare.applyToCanvas(canvas); // 同时, 由于camare执行旋转操作的时候, 是以原点为中心的, 所以, 如果这里不配合canvas的平移操作来使用的话, 最终图像是歪的; 但是camare又不支持设置中心, 所以就只能先将图像平移到原点, camare作用完之后再平移回原来的位置; 注意, 虽然Camare也有translate()方法, 但是Camare的变换是会带着整个三维坐标系一起的, 而且它在变换结束之后才会做投影, 而不是一旋转完就立即投影到Canvas上去, 这样如果用Camare做移动,
    那么绘制出来的结果就完全不是预期的样子了(这里的解释不是很懂)
    canvas.translate(-centerX, -centerY);
    camare.restore();

    canvas.restore();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Camare坐标系: 使用的是三维坐标系, 原点也是View左上角; x轴右正左负, y轴上正下负(注意y轴不一样咯, 和View坐标系相反), z轴垂直于View, 内正外负(朝屏幕里面为正, 朝屏幕外面为负); 还包含了一个虚拟的Camare对象, 即一个虚拟的相机, 默认在z轴负向, 即View坐标原点的正上方
Camare的旋转方向没有规律, 见Download文件夹下照片
Camare也是可以沿着x, y, z轴平移的, 比如沿着z轴平移, 就相当于将物体远离或者靠近相机, 即起到放大缩小的作用, 但是由于这种情况也可以直接使用Canvas的scale()等来做到, 所以实际开发中一般都用Canvas自带的方法来实现
Camare还可以通过setLocation()来设置虚拟相机的位置, 这种的使用情况是, 比如进行旋转时会造成物体投影太大(因为相机离物体太近), 此时可以通过setLocation()来设置相机位置远离物体, 使投影缩小; 一般使用时都是沿着z轴移动Camare, 不常见沿着x, y轴移动的
Camare变换的时候也需要save()和restore()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;重写其他方法体现遮盖(联系draw过程, 如: 绘制前景, 绘制背景等)&lt;/p&gt;

&lt;p&gt;drawColor: 可以用于填充背景或者设置半透明蒙版&lt;/p&gt;

&lt;h2 id=&quot;二-paint&quot;&gt;二. Paint&lt;/h2&gt;

&lt;p&gt;关于Paint, 请参见: https://hencoder.com/ui-1-2/&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;颜色: 
setColor()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;setShader(): 着色器, 着色器设置的是一个颜色方案，或者说是一套着色规则; 当设置了 Shader 之后，Paint 在绘制图形和文字时就不使用 setColor/ARGB() 设置的颜色了，而是使用  Shader 的方案中的颜色。LinearGradient RadialGradient SweepGradient BitmapShader ComposeShader&lt;/p&gt;

&lt;p&gt;setColorFilter(): ColorFilter; 共有三个子类：LightingColorFilter PorterDuffColorFilter 和 ColorMatrixColorFilter&lt;/p&gt;

&lt;p&gt;setXfermode(): Xfermode 指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色; 唯一子类: PorterDuffXfermode&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抗锯齿、填充/轮廓、线条宽度等&lt;/p&gt;

&lt;p&gt;setAntiAlias()&lt;/p&gt;

&lt;p&gt;setStyle()&lt;/p&gt;

&lt;p&gt;线条形状: setStrokeWidth(float width),  setStrokeCap(Paint.Cap cap), setStrokeJoin(Paint.Join join),  setStrokeMiter(float miter)&lt;/p&gt;

&lt;p&gt;色彩优化: setDither(boolean dither) 和  setFilterBitmap(boolean filter)&lt;/p&gt;

&lt;p&gt;setPathEffect(): PathEffect 分为两类，单一效果的 CornerPathEffect DiscretePathEffect DashPathEffect PathDashPathEffect ，和组合效果的 SumPathEffect ComposePathEffect&lt;/p&gt;

&lt;p&gt;什么是硬件加速: https://developer.android.com/guide/topics/graphics/hardware-accel&lt;/p&gt;

&lt;p&gt;setShadowLayer(): 在绘制层下方添加效果
setMaskFilter(): 在绘制层上方添加效果; BlurMaskFilter 和 EmbossMaskFilter&lt;/p&gt;

&lt;p&gt;获取绘制的 Path&lt;/p&gt;

&lt;h3 id=&quot;drawtext相关&quot;&gt;drawText()相关&lt;/h3&gt;

&lt;h2 id=&quot;三-动画&quot;&gt;三. 动画&lt;/h2&gt;

&lt;p&gt;动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，比较简单
Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式
还有一类动画是 Transition。 Transition 这个词的本意是转换，在 Android 里指的是切换界面时的动画效果&lt;/p&gt;

&lt;p&gt;一个动画需要考虑取消&lt;/p&gt;

&lt;p&gt;以下介绍属性动画:&lt;/p&gt;

&lt;p&gt;ViewPropertyAnimator: imageView.animate().translationX(500); 默认动画时长300ms, 默认插值器为AccelerateDecelerateInterpolator()(先加速后减速)
view.setTranslationX()等方法内部没有调用invalidate()来实现重绘, 而是直接使用了硬件加速实现重绘, 这样更加高效, 但是好像自定义绘制不能用, 只能使用invalidate(), 为什么?&lt;/p&gt;

&lt;p&gt;ObjectAnimator: 拼接出set方法名, 然后去调用set方法; 如果只是传入了一个值(ofXXX()有很多重载函数), 该值表示终止值, 但是起始值无法得到, 那么就还需要提供一个get方法来得到初始属性值&lt;/p&gt;

&lt;p&gt;Interpolator: AccelerateDecelerateInterpolator, LinearInterpolator, AccelerateInterpolator, DecelerateInterpolator, AnticipateInterpolator, OvershootInterpolator, AnticipateOvershootInterpolator, BounceInterpolator, CycleInterpolator, PathInterpolator
Android 5.0 （API 21）引入了三个新的 Interpolator 模型，并把它们加入了 support v4 包中: 
FastOutLinearInInterpolator, FastOutSlowInInterpolator, LinearOutSlowInInterpolator&lt;/p&gt;

&lt;p&gt;设置监听器: 
ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法, 要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除; ViewPropertyAnimator 则独有 withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听&lt;/p&gt;

&lt;p&gt;ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象; ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个 addPauseListener() / removePauseListener() 的支持&lt;/p&gt;

&lt;p&gt;AnimatorListener: onAnimationStart, onAnimationEnd, onAnimationCancel(当动画被通过 cancel() 方法取消时，这个方法被调用。
需要说明一下的是，就算动画被取消，onAnimationEnd() 也会被调用。所以当动画被取消时，如果设置了 AnimatorListener，那么 onAnimationCancel() 和 onAnimationEnd() 都会被调用。onAnimationCancel() 会先于 onAnimationEnd() 被调用。), onAnimationRepeat(ViewPropertyAnimator 不支持重复，所以这个方法对 ViewPropertyAnimator 相当于无效)&lt;/p&gt;

&lt;p&gt;ViewPropertyAnimator.withStartAction/EndAction(): ViewPropertyAnimator 的独有方法, 它们和 set/addListener() 中回调的 onAnimationStart() / onAnimationEnd() 相比起来的不同主要有两点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的  AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。&lt;/li&gt;
  &lt;li&gt;withEndAction() 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 AnimatorListener.onAnimationEnd() 的行为是不一致的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TypeEvaluator: 
在需要的时候, 还可以自定义TypeEvaluator来实现自己针对某一特定属性值来设计自己的算法
ObjectAnimator.setEvaluator()
ArgbEvaluator&lt;/p&gt;

&lt;p&gt;PropertyValuesHolder: 同一个动画中改变多个属性; ViewPropertyAnimator可以直接连用即可, 但是ObjectAnimator不能直接连用, 此时可以使用PropertyValuesHolder来同时在一个动画中改变多个属性&lt;/p&gt;

&lt;p&gt;AnimatorSet 多个动画配合执行; 还可以定义动画的执行顺序&lt;/p&gt;

&lt;p&gt;PropertyValuesHolders.ofKeyframe() 把同一个属性拆分&lt;/p&gt;

&lt;p&gt;「关于复杂的属性关系来做动画」，就这么三种：
使用 PropertyValuesHolder 来对多个属性同时做动画；
使用 AnimatorSet 来同时管理调配多个动画；
PropertyValuesHolder 的进阶使用：使用 PropertyValuesHolder.ofKeyframe() 来把一个属性拆分成多段，执行更加精细的属性动画。&lt;/p&gt;

&lt;p&gt;ValueAnimator 最基本的轮子; ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimator&lt;/p&gt;

&lt;h2 id=&quot;四-硬件加速&quot;&gt;四. 硬件加速&lt;/h2&gt;

&lt;p&gt;文档: https://developer.android.google.cn/guide/topics/graphics/hardware-accel&lt;/p&gt;

&lt;p&gt;在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些  Canvas.drawXXX() 变成实际的像素这件事&lt;/p&gt;

&lt;p&gt;在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的
而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作(在硬件加速开启时，CPU 做的事只是把绘制工作转换成 GPU 的操作，这个工作量相对来说是非常小的。)&lt;/p&gt;

&lt;p&gt;关闭硬件加速: view.setLayerType(LAYER_TYPE_SOFTWARE, null);&lt;/p&gt;

&lt;p&gt;View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU; 当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果&lt;/p&gt;

&lt;p&gt;在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View; (打开硬件加速: view.setLayerType(LAYER_TYPE_NONE, null);)&lt;/p&gt;

&lt;p&gt;如果是使用 ViewPropertyAnimator, 如下代码; 不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用 invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——
&lt;strong&gt;这种方式不适用于基于自定义属性绘制的动画&lt;/strong&gt;。一定记得这句话。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;view.animate()
        .rotationY(90)
        .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于设置了 View Layer 后，View 在初次绘制时以及每次  invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。&lt;/p&gt;

&lt;p&gt;setLayerType(): 
参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；
参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture（如果硬件加速关闭，那么行为和  VIEW_TYPE_SOFTWARE 一致）；
参数为 LAYER_TYPE_NONE 时，关闭 View Layer。&lt;/p&gt;

&lt;p&gt;View Layer 可以加速无 invalidate() 时的刷新效率，但对于需要调用  invalidate() 的刷新无法加速&lt;/p&gt;

&lt;h2 id=&quot;五-布局&quot;&gt;五. 布局&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://hencoder.com/ui-2-1/&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;onMeasure()测量完成之后通过setMeasuredDimension()来设置的测量尺寸只是该View的一个期望尺寸, 表示View觉得自己这么大比较合适, 之后它的父View就会根据这个期望尺寸再去判断(只是一个参考), 至于最终父View是允许子View就这么大, 还是要求再去测量一次, 还是说直接重新指派一个新的尺寸, 由父View决定, 最终会通过layout参数传递&lt;/p&gt;

&lt;p&gt;布局过程自定义方式:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;重写 onMeasure() 来修改已有的 View 的尺寸；&lt;/li&gt;
    &lt;li&gt;重写 onMeasure() 来全新定制自定义 View 的尺寸；&lt;/li&gt;
    &lt;li&gt;重写 onMeasure() 和 onLayout() 来全新定制自定义 ViewGroup 的内部布局&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;父View对子View的尺寸限制:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;这个限制怎么来的: 开发者对子View的要求&lt;/li&gt;
    &lt;li&gt;子View的onMeasure应该怎么做来让自己符合这个限制: 使用resolveSize()方法(resolveSize()方法内部其实就是通过三种mode的不同情况来返回是使用子View的测量值, 还是父View的限制值)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;全新定制自定义View:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;通过onMeasure()重新去计算(不用调用super.onMeasure()了)&lt;/li&gt;
    &lt;li&gt;将计算出来的结果通过resolveSize()过滤一遍, 使得其符合父View的限制, 之后再通过setMeasureDimension()来设置即可&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;onMeasure()的重写:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;调用每个子View的measure(), 让子View自我测量&lt;/li&gt;
    &lt;li&gt;根据子View给出的尺寸, 得出子View的位置, 并保存它们的尺寸和位置&lt;/li&gt;
    &lt;li&gt;根据子View的位置和尺寸计算出自己的尺寸, 并用setMeasureDimesion()保存&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于保存子View位置的两点说明:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;不是所有的Layout都需要保存子View的位置(因为有的Layout可以在布局阶段实时推出子View的位置, 比如LinearLayout)&lt;/li&gt;
    &lt;li&gt;有些时候对某些子View需要重复测量两次或多次才能得到正确的尺寸和位置&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/onMeasure模板.png&quot; alt=&quot;onMeasure模板&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/onLayout模板.png&quot; alt=&quot;onLayout模板&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7Draft/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7Draft/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
      <item>
        <title>Java内存区域与内存溢出异常</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第二章以及其他博客的阅读总结&lt;/p&gt;

&lt;p&gt;重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同时还需要明确的一点是各部分会产生的异常, 以及产生异常的原因&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自网络, 但是忘了出处, 侵删~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;p&gt;在开始讲解之前, 需要先明确关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;的一些基本概念&lt;/p&gt;

&lt;p&gt;我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是一个跨平台的语言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;跨平台的基本支撑其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;对操作系统底层细节的屏蔽, 相当于加了一个中间层(计算机中的任何问题都可以加一个中间层解决~), &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;不再像&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;等语言一样直接翻译为针对特殊平台的机器码, 而是翻译为字节码, 也即是我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 下图大概可以比较简明的概括了~; 字节码就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;世界中的汇编, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;则不是跨平台的, 只是不同平台的&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;都能识别和运行标准格式的字节码文件而已&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/Java编译.png&quot; alt=&quot;Java编译&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 我觉得下图已经可以比较准确的表达了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面要讲的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-运行时数据区&quot;&gt;二. 运行时数据区&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序的时候把它所管理的内存划分为若干个不同的数据区, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM内存区域.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-程序计数器&quot;&gt;2.1 程序计数器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;211-存储数据类型&quot;&gt;2.1.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;指向下一条需要执行的字节码指令; 如果线程正在执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法, 该计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法, 该计数器值则为空(&lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;212-异常情况&quot;&gt;2.1.2 异常情况&lt;/h4&gt;

&lt;p&gt;该区域是是唯一一个在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有规定任何&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;情况的区域&lt;/p&gt;

&lt;h3 id=&quot;22-java虚拟机栈&quot;&gt;2.2 Java虚拟机栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;221-存储数据类型&quot;&gt;2.2.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;描述&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法执行的内存模型, 每个方法调用就对应着一个栈帧的入栈和出栈; 一个栈帧里面存储了局部变量表, 操作数栈, 动态链接, 方法出口等信息&lt;/p&gt;

&lt;p&gt;局部变量表存储了编译器可知的各种基本数据类型, 对象引用, &lt;code class=&quot;highlighter-rouge&quot;&gt;returnAddress&lt;/code&gt;; 局部变量表的大小在编译期间即可确定, 运行期间大小不变&lt;/p&gt;

&lt;h4 id=&quot;222-异常情况&quot;&gt;2.2.2 异常情况&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;StackOverflowError&lt;/strong&gt;: 线程请求栈深度大于虚拟机允许深度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF sof = new JavaVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;Stack Length: &quot; + sof.stackLength);
            throw e;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;: 虚拟机栈动态扩展时无法申请到足够内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop();
                }
            }).start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 由于操作系统分配给每个进程的内存空间是有限制的, 所以如果是由于建立过多的线程导致内存溢出, 在不能减少线程数或者更换&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位虚拟机的情况下, 可以选择通过减少最大堆和减少栈容量来换取更多的线程&lt;/p&gt;

&lt;h3 id=&quot;23-本地方法栈&quot;&gt;2.3 本地方法栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-存储数据类型&quot;&gt;2.3.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;和虚拟机栈类似, 只是本地方法栈提供的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法服务&lt;/p&gt;

&lt;h4 id=&quot;232-异常情况&quot;&gt;2.3.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StackOverflowError&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-java堆&quot;&gt;2.4 Java堆&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;垃圾收集管理的主要区域&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;241-存储数据类型&quot;&gt;2.4.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;几乎所有的对象实例都在这里分配&lt;/p&gt;

&lt;h4 id=&quot;242-异常情况&quot;&gt;2.4.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMHeapOOM {

    static class HeapOOM {
    }

    public static void main(String[] args) {
        List&amp;lt;HeapOOM&amp;gt; list = new ArrayList();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-方法区&quot;&gt;2.5 方法区&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;该区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;251-存储数据类型&quot;&gt;2.5.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;存储已被虚拟机加载的类信息, 常量, 静态变量, 即使编译器编译后的代码等数据&lt;/p&gt;

&lt;h4 id=&quot;252-运行时常量池&quot;&gt;2.5.2 运行时常量池&lt;/h4&gt;

&lt;p&gt;运行时常量池是方法区的一部分, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK6&lt;/code&gt;之后, 常量池被放入了堆中;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中也有常量池部分, 即编译期生成的各种字面量和符号引用, 这部分将在类加载后进入方法区的运行时常量池中, 此外还会把翻译出来的直接引用也存储在运行时常量池中&lt;/p&gt;

&lt;p&gt;运行时常量池相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件常量池的另外一个最重要的特征是具备动态性, 即运行期间也可以将新的常量放入池中, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;intern()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String.intern()&lt;/code&gt;作用是: 如果字符串常量池中已经包含一个等于此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的字符串, 则返回代表池中这个字符串的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象; 否则, 将此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象包含的字符串添加到常量池中, 并且返回此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的引用&lt;/p&gt;

&lt;p&gt;同样, 收方法区的限制, 当常量池无法再申请到内存时会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;253-异常情况&quot;&gt;2.5.3 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;: 方法区无法满足内存分配需求&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;26-直接内存&quot;&gt;2.6 直接内存&lt;/h3&gt;

&lt;p&gt;直接内存不是虚拟机运行时数据区的一部分, 但是也被频繁使用, 如: 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.4&lt;/code&gt;中新加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;类, 引入了一种基于通道(&lt;code class=&quot;highlighter-rouge&quot;&gt;Chanel&lt;/code&gt;)和缓冲区(&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;方式, 它可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;函数库直接分配堆外内存, 然后通过一个存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirectByteBuffer&lt;/code&gt;对象作为这块内存的引用进行操作, 避免了在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;堆中来回复制数据, 提高性能&lt;/p&gt;

&lt;p&gt;同样会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-常见问题&quot;&gt;三. 常见问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 下文摘自文末参考链接, 权作个人笔记~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序运行永远都是在栈中进行的，因而参数传递时, 只存在传递基本类型和对象引用的问题, 不会直接传对象本身;  但是传引用的错觉是如何造成的呢? 在运行栈中, 基本类型和引用的处理是一样的, 都是传值, 所以, 如果是传引用的方法调用, 也同时可以理解为“传引用值”的传值调用, 即引用的处理跟基本类型是完全一样的; 但是当进入被调用方法时, 被传递的这个引用的值, 被程序解释(或者查找)到堆中的对象, 这个时候才对应到真正的对象; 如果此时进行修改; 修改的是引用对应的对象; 而不是引用本身; 即: 修改的是堆中的数据; 所以这个修改是可以保持的了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我产生的对象不多呀, 为什么还会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答: 你继承层次忒多了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;中产生的对象是先产生父类, 然后才产生子类, 明白不?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;错误分几种?
答: 分两种, 分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError:java heap size&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError: PermGen space&lt;/code&gt;, 两种都是内存溢出, &lt;code class=&quot;highlighter-rouge&quot;&gt;heap size&lt;/code&gt;是说申请不到新的内存了, 这个很常见，检查应用或调整堆内存大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;PermGenspace&lt;/code&gt;是因为永久存储区满了, 这个也很常见, 一般在热发布的环境中出现, 是因为每次发布应用系统都不重启, 久而久之永久存储区中的死对象太多导致新对象无法申请内存, 一般重新启动一下即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么不建议在程序中显式的生命&lt;code class=&quot;highlighter-rouge&quot;&gt;System.gc()&lt;/code&gt;?
答: 因为显式声明是做堆内存全扫描, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;, 是需要停止所有的活动的(&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop The World Collection&lt;/code&gt;), 你的应用能承受这个吗?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.importnew.com/1993.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.cnblogs.com/dolphin0520/p/3783345.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/2905-JVM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java之IO流</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中一个比较重要的模块–&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;流&lt;/p&gt;

&lt;p&gt;以下内容是对&lt;strong&gt;Java核心技术卷II&lt;/strong&gt;的总结, 权做个人笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java I/O&lt;/code&gt;流指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.io&lt;/code&gt;包和&lt;code class=&quot;highlighter-rouge&quot;&gt;java.nio&lt;/code&gt;包提供的各种操作文件和输入输出等的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 具体可以分为两大类: 一类是面向字节的, 一类是面向字符的; 面向字节的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;是以&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStream&lt;/code&gt;类为基类, 每次以一个字节为单位进行读写操作; 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt;为基类, 每次以两个字节为单位进行读写操作, 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;主要是针对文本操作设计的&lt;/p&gt;

&lt;p&gt;可以参见下图:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字节&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字节.png&quot; alt=&quot;面向字节&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字符&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字符.png&quot; alt=&quot;面向字符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: &lt;a href=&quot;https://blog.csdn.net/zhoupenglei/article/details/46312405&quot;&gt;图片来源&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-重要概念&quot;&gt;二. 重要概念&lt;/h2&gt;

&lt;h3 id=&quot;21-流嵌套&quot;&gt;2.1 流嵌套&lt;/h3&gt;

&lt;p&gt;即将不同功能的流嵌套起来, 过滤; 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中流默认是不被缓冲区缓存的, 也就是说每个&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;的调用都会请求操作系统再分发一个字节, 相比之下, 请求一个数据块并将其置于缓冲区中会显得更加高效, 如果我们想使用缓冲机制, 以及用于文件输入方法, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;            BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;file&quot;));&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-glob模式匹配&quot;&gt;2.2 Glob模式匹配&lt;/h3&gt;

&lt;p&gt;即使用正则筛选文件, 如筛选文件后缀名为&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;的文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;), &quot;*.java&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Glob&lt;/code&gt;模式见下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模式&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;匹配路径组成部分中0个或多个字符&lt;/td&gt;
      &lt;td&gt;*.java匹配当前目录中的所有Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;**&lt;/td&gt;
      &lt;td&gt;匹配跨目录边界的0个或多个字符&lt;/td&gt;
      &lt;td&gt;**.java匹配在所有子目录中的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;匹配一个字符&lt;/td&gt;
      &lt;td&gt;????.java匹配所有四个字符的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[…]&lt;/td&gt;
      &lt;td&gt;匹配一个字符集合&lt;/td&gt;
      &lt;td&gt;Test[0-9A-F].java匹配Testx.java, 其中x是一个十六进制数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;{…}&lt;/td&gt;
      &lt;td&gt;匹配由逗号隔开的多个可选项之一&lt;/td&gt;
      &lt;td&gt;*.{java, class}匹配所有的Java文件和类class文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;转移上述任意模式中的字符&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;*&lt;/em&gt;匹配所有文件名中包含*的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;23-常用工具类&quot;&gt;2.3 常用工具类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Files&lt;/strong&gt;: 使得读写文件和操作文件及文件夹变得简单; 旧的&lt;code class=&quot;highlighter-rouge&quot;&gt;File&lt;/code&gt;类中有一个方法可以用来获取一个目录下的所有文件构成的数组, 但是当目录中包含大量文件时, 这个方法的性能非常低, &lt;code class=&quot;highlighter-rouge&quot;&gt;Files&lt;/code&gt;类设计了一个方法可以产生&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;对象, 如下示例代码:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;));
Iterator&amp;lt;Path&amp;gt; iterator = entries.iterator();
for (Path path : entries) {
    System.out.println(path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Paths&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths&lt;/code&gt;可以用来构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Path&lt;/code&gt;对象: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths.get(args)&lt;/code&gt;, 可以接收一个或多个字符串, 并将它们用默认文件系统分隔符连接起来&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-内存映射文件&quot;&gt;2.4 内存映射文件&lt;/h3&gt;

&lt;p&gt;大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分”映射”到内存中, 然后这个文件就可以当做是内存数组一样的访问, 中比传统的文件操作要快得多; 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;25-易忘类&quot;&gt;2.5 易忘类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStreamReader&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStreamWriter&lt;/code&gt;: 可以指定编码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintWriter&lt;/code&gt;: 以文本格式写出数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccessFile&lt;/code&gt;: 在任何位置查找或写入数据; 可以用于实现断点续传&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DataInputStream&lt;/code&gt;: 读取数字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectOutputStream&lt;/code&gt;: 读取对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;26-文件操作处理效率&quot;&gt;2.6 文件操作处理效率&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;普通输入流&lt;/td&gt;
      &lt;td&gt;110s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;带缓冲的输入流&lt;/td&gt;
      &lt;td&gt;9.9s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;随机方访问文件&lt;/td&gt;
      &lt;td&gt;162s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存映射文件&lt;/td&gt;
      &lt;td&gt;7.2s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View绘制流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之绘制流程&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的绘制流程分为三大步: &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;即测量, 测量&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;即布局, 按照一定的规则排布&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;即绘制, 绘制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的外形; 这三步是和我们自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;息息相关的, 熟悉和掌握这三大流程, 我们才能随心所欲的定制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; 本文也将从这三个方面入手, 结合源码讲解&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制的整体流程, 如下图;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View绘制流程.png&quot; alt=&quot;View绘制流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 图片来自: https://www.jianshu.com/p/dc0b039e7c4f&lt;/p&gt;

&lt;p&gt;可以看出, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;三大流程直接相关的是从&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的; 大致流程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performTraversals() {
    ...
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
    performLayout(lp, mWidth, mHeight);
    ...
    performDraw();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-measure过程&quot;&gt;二. measure过程&lt;/h2&gt;

&lt;p&gt;在开始讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之前, 我们需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程的理解还是很重要的&lt;/p&gt;

&lt;h3 id=&quot;21-measurespec&quot;&gt;2.1 MeasureSpec&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的值, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;的位组合; 高&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;, 低&lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 这样设计其实是为了节约空间; 关于二者如何组合, 可以参见以下代码; 可以看出, 其实就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MODE_MASK&lt;/code&gt;掩码以及位操作实现将两个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型整合为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;; 当然, 要分别提取这两个值的话, 也可以很简单的用位操作实现, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &amp;lt;&amp;lt; MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size &amp;amp; ~MODE_MASK) | (mode &amp;amp; MODE_MASK); // MODE_MASK  = 0x3 &amp;lt;&amp;lt; 30; 
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;即测量模式, 一共有三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;: 父容器不对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;有任何限制, 要多大给多大, 这种情况一般用于系统内部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;: 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和具体数值这两种模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;: 父容器指定了一个可用大小即&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小不能大于该值, 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;的类型区别可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的确定受&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;的影响, 但是也要分情况: 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;RootView&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;来说, 由于其没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由窗口尺寸和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定; 对于普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;来说, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由父容器传递的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定&lt;/p&gt;

&lt;p&gt;普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;创建规则见下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;childLayoutParams&lt;/strong&gt; \ &lt;strong&gt;parentSpecMode&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;dp/px&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;match_parent&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;wrap_content&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自«Android开发艺术探索»&lt;/p&gt;

&lt;p&gt;上面表格中展现的规则需要好好理解:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸是明确的值时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_height&lt;/code&gt;有确定的值, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;是什么, &lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;都保持规定尺寸不变; 这点比较好理解, 因为明确指定&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸之后, 我们肯定希望显示的也是指定尺寸&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;时, 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是确定尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸也能确定, 也就是父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, parentSize&lt;/code&gt;也可以理解; 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸不确定, 此时父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;只知道一个最大尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;, 也只能知道一个最大尺寸, 而且该最大尺寸不应该超过&lt;code class=&quot;highlighter-rouge&quot;&gt;parentSize&lt;/code&gt;, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;, 即尺寸大小不确定的话, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是具有确定尺寸还是尺寸不确定, 反正&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸始终是不确定的, 所以此时应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;, 而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸也不应该超过父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 故综上为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-decorview的measure过程&quot;&gt;2.2 DecorView的measure过程&lt;/h3&gt;

&lt;p&gt;我们知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;是整个&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;树的&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;, 我们首先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的测量过程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getRootMeasureSpec()&lt;/code&gt;来获取&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 如下; 结合上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则可以理解&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;MATCH_PARENT&lt;/code&gt;, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以其尺寸就为窗口尺寸, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;WRAP_CONTENT&lt;/code&gt;, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;尺寸不确定, 最大尺寸不应该超过窗口尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, windowSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;明确规定了自己的尺寸, 那么就不受窗口尺寸的影响, 为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, rootDimension&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建好&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;之后, 就直接传入了&lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;中, &lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;的代码如下; 可以看出, 接下来就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;进行测量, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的, 不可重写, 所以应该追溯到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;(继承链为: &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeausre()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;不是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的,
所以我们应该去分析的是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        if (mView == null) {
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的在&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;中将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;进行处理和判断之后, 调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;super.onMeasure()&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;; 如下, 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;方法中处理了&lt;code class=&quot;highlighter-rouge&quot;&gt;Margin&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;)和&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;getPaddingXXX&lt;/code&gt;), 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;中会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;child.measure()&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递(即递归测量), 这样就将测量工作传递到了子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DecorView.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    ...
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    ...
}

// FrameLayout.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int count = getChildCount();
        for (int i = 0; i &amp;lt; count; i++) {
            final View child = getChildAt(i);
            if (mMeasureAllChildren || child.getVisibility() != GONE) {
                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                maxWidth = Math.max(maxWidth,
                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                maxHeight = Math.max(maxHeight,
                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                childState = combineMeasuredStates(childState, child.getMeasuredState());
                if (measureMatchParentChildren) {
                    if (lp.width == LayoutParams.MATCH_PARENT ||
                            lp.height == LayoutParams.MATCH_PARENT) {
                        mMatchParentChildren.add(child);
                    }
                }
            }
        }

        // Account for padding too
        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
        ...
}

// FrameLayout.measureChildWithMargins()
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
            ....
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程分为&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量过程&lt;/p&gt;

&lt;h3 id=&quot;23-viewgroup的measure过程&quot;&gt;2.3 ViewGroup的measure过程&lt;/h3&gt;

&lt;p&gt;我们来看子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时的测量过程; 其实对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;有不同的布局规则, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearLayout&lt;/code&gt;, 有竖直布局和水平布局两种, 而这两种不同的布局测量方式也不同; 所以我们这里只是简单的看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;对子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的通用测量方式&lt;/p&gt;

&lt;p&gt;代码如下; 测量逻辑比较简单, 也是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递, 实现递归测量, 不做细讲啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i &amp;lt; size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
}


protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();
            
        // 获取child的MeasureSpec, 同时考虑Padding
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 递归调用, 又回到了这里
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的一点是子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getChildMeasureSpec()&lt;/code&gt;为例, 如下; 其构造规则除了考虑了&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;以外, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构造规则表是相同的, 可以结合代码注释再次理解该表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        case MeasureSpec.EXACTLY: // 如果父View尺寸确定
            if (childDimension &amp;gt;= 0) { // childDimension &amp;gt;= 0, 表示的是子View的layout_xxx设置了具体的数值, 因为wrap_content = -2
                                       // match_parent = -1
                resultSize = childDimension; // 那么集合MeasureSpec的构造规则及对应解释, 这里应该为childDimension, EXACTLY
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 同时父View尺寸也确定
                resultSize = size;  // 说明子View尺寸确定, 且为父View尺寸
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸确定
                resultSize = size;  // 说明子View尺寸不确定, 最大不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.AT_MOST: // 如果父View尺寸不确定
            if (childDimension &amp;gt;= 0) {
                resultSize = childDimension; // 如果子View的layout_xxx设置了明确的值
                resultMode = MeasureSpec.EXACTLY; // 那么子View有确定尺寸, 即为设置的值
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 但是父View的尺寸不定
                resultSize = size; // 那么子View的尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸不定
                resultSize = size; // 那么子View尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.UNSPECIFIED:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-view的measure过程&quot;&gt;2.4 View的measure过程&lt;/h3&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;啦~, 只是一个单纯的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;控件而已; 其默认测量规则如下; 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getSuggestedMinimumWidth()&lt;/code&gt;为例, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;android:minWidth&lt;/code&gt;属性, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 如果设置了背景, 则返回背景宽度和指定&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;中的最大值; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;则是返回默认尺寸, 我们只需关心&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;两种情况即可(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;UNSPECIFIED&lt;/code&gt;一般用于系统, 不常用), 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对于这两种情况默认都是返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即传入的尺寸,
我们上面说了&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;模式, &lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和指定数值情况, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;将这两种情况都默认返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;可用空间, 很明显, 这对于&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;是不支持的(因为此时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;), 所以在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 需要自己根据逻辑实现&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的情况, 具体实现可以参见&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ImageView&lt;/code&gt;等对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// 这里以Width为例
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}

public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, 最终我们确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的尺寸之后, 还需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;正真设置和作用到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;上; 需要注意的是, 此时只是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高, 可能不是实际宽高, 实际宽高在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中才能确定, 出现测量宽高和实际宽高不相等的原因 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中改变了&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;实际布局的位置尺寸等造成的, 但是一般情况下二者都是相等的&lt;/p&gt;

&lt;h3 id=&quot;25-自定义view时measure过程注意事项&quot;&gt;2.5 自定义View时measure过程注意事项&lt;/h3&gt;

&lt;p&gt;到这里, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制过程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程就已经讲解完了; 但是笔者还想提一下在实际使用, 即自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 还需要注意哪些方面; 这里需要提前声明的是, 下面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包含&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;, 只是单纯的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;需要自己实现对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要自己处理&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;的情况, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;还需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记住使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;使测量尺寸生效, 否则会抛异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-layout过程&quot;&gt;三. layout过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程会确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;最终的位置和尺寸, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程才是真正实现不同布局的关键; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的传递是从&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;开始往下传递&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;中则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());&lt;/code&gt;, 前面我们已经说过了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;,
但是这里我们并不去分析&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 因为这是针对某一具体布局而言的; 我们这里选择具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法如下; 可以看出其调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;中, 可以看出调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 同时还需要注意一点就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法是由&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的, 这也就意味着自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的时候, 不能重写&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;是一个抽象方法, 也就是说我们必须自己去是实现; 其实这也很好理解, 因为对于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 我们需要实现自己的布局,
这里实现逻辑其实就是写在&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;中即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewGroup.layout()
public final void layout(int l, int t, int r, int b) {
    ...
    super.layout(l, t, r, b);
    ...
}

// View.layout()
public void layout(int l, int t, int r, int b) {
    ...
    boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    ...
    onLayout(changed, l, t, r, b);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 还需要注意一点的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法中还调用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setFrame()&lt;/code&gt;, 该方法的作用其实是设置&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mRight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mTop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mBottom&lt;/code&gt;的值; 这里反应的其实是上文说过的一句话, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程中确定测量宽高, 实际宽高需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中确定; 这里就是记录&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的实际宽高; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredHeight()&lt;/code&gt;来获取, 这在&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之后即可得到; 实际宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getHeight()&lt;/code&gt;来得到,
这在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程之后可以获取; 至于二者的区别, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;为例, 如下; 可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;获取的其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;获取的则是实际宽高(因为是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的右边界减去左边界); 上面已经说过了测量宽高和实际宽高的区别, 这里就不再赘述啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final int getMeasuredWidth() {
    return mMeasuredWidth &amp;amp; MEASURED_SIZE_MASK;
}

public final int getWidth() {
    return mRight - mLeft;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程比较简单, 也是一个递归调用的过程, 至于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时主要是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的设计, 需要考虑的还是要&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的影响啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-draw过程&quot;&gt;四. draw过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;过程其实就是其&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 最终会调用到&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;(实际上调用栈是: &lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;performDraw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;drawSoftware()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时官方并不建议去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 而是建议重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;去实现自己的逻辑, &lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中实际上是一个空实现; 我们这里先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;的实现逻辑&lt;/p&gt;

&lt;p&gt;官方文档注释中已经说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;过程的实现逻辑, 如下; 可以看出, 主要绘制逻辑为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绘制背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制内容(即自己)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制装饰, 如滚动条等前景&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;步和第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;步一般会跳过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// View.draw()
public void draw(Canvas canvas) {
        ...
        /*
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
        ...
         // Step 1, draw the background, if needed
         if (!dirtyOpaque) {
             drawBackground(canvas);
         }
         // skip step 2 &amp;amp; 5 if possible (common case)
         // Step 3, draw the content
         if (!dirtyOpaque) 
            onDraw(canvas);
         // Step 4, draw the children
         dispatchDraw(canvas);
         // Step 6, draw decorations (foreground, scrollbars)
         onDrawForeground(canvas);
         ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道, 绘制内容这一步是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;, 即我们自己自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时需要实现的内容; 另外, 这里需要注意的一点是绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchDraw()&lt;/code&gt;去传递绘制绘制过程, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 一般用于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;中其实现如下; 其实就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后依次调用子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法绘制出子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void dispatchDraw(Canvas canvas) {
    ...
    for (int i = 0; i &amp;lt; childrenCount; i++) {
        ...
        more |= drawChild(canvas, transientChild, drawingTime); // 在drawChild()中调用child.draw(canvas, this, drawingTime)将绘制过程传递
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的整个绘制流程就讲解完成啦~, 当然这对于我们随心所欲的实现炫酷的自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;还是第一步理论基础, 真正要做到还是需要靠自己多动手去画咯~&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View事件分发机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之事件分发机制&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的触摸事件分发是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列中的一个重难点, 主要需要掌握的是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的传递规则和处理规则, 这是自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中冲突处理的理论来源~&lt;/p&gt;

&lt;p&gt;触摸事件分发的处理主要是对&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;封装了用户的一系列行为, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指刚触摸屏幕), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指在屏幕上滑动), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;(手指抬起)等; 以及事件发生的坐标(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getX()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getY()&lt;/code&gt;可以得到)等&lt;/p&gt;

&lt;p&gt;在开始讲解之前需要明确的一些概念是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个事件序列: 指的是一次完整的触摸过程, 即从&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指触摸屏幕)开始, 到中间的一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指滑动), 最后到&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;为止(手指抬起); 总结起来就是&lt;code class=&quot;highlighter-rouge&quot;&gt;down...move...move..up&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触摸事件的分发其实是一个从上到下不断递归传递和拦截的过程; 一个大致的传递流程是: &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 当然如果向下传递但是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;又没有消耗的话, 又会逐层返回, 最终将没有消耗的&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-事件分发之源&quot;&gt;二. 事件分发之源&lt;/h2&gt;

&lt;p&gt;触摸事件产生和分发的源头是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中处理的, 即在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;中; 如下; 处理思路也很简单, 只是单纯的向下分发而已, 如果事件没有得到处理, 那么最终就交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理; 另外, 这里还为用户提供了一个监听和拦截事件的方法, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;onUserInteraction()&lt;/code&gt;, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中是一个空实现, 可以重写该方法在事件向下传递之前进行特殊拦截和处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();  // 自定义事件拦截
        }
        if (getWindow().superDispatchTouchEvent(ev)) {  // 通过Window向下分发事件
            return true;
        }
        return onTouchEvent(ev);  // 如果事件最终没有被处理, 那么交给Activity自己的onTouchEvent()来处理
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow&lt;/code&gt;, 这里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow.superDispatchTouchEvent()&lt;/code&gt;传递实际上是只是简单调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor.superDispatchTouchEvent(event)&lt;/code&gt;, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;superDispatchTouchEvent()&lt;/code&gt;方法中, 也只是简单的将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行分发(即&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;); 到这里就将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了, 也是事件分发处理中最主要的一部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-viewgroup分发事件&quot;&gt;三. ViewGroup分发事件&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;中对事件的分发处理过程比较长, 实际上大致分成了三个部分来处理&lt;/p&gt;

&lt;h3 id=&quot;31-事件拦截&quot;&gt;3.1 事件拦截&lt;/h3&gt;

&lt;p&gt;首先, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;会判断是否进行事件拦截, 如下; 从后面将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的条件可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截, 那么该事件序列将不再向下分发; 这里还需要注意的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;判断是否进行事件拦截的条件一个是为&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget != null&lt;/code&gt;时; 也就是说一个事件序列的在开始时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;(当然, 还有一个影响因素是&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 我们稍后讲解); 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的赋值是在后面分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 如果有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值;&lt;/p&gt;

&lt;p&gt;上面是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截的基本思路, 简单总结起来就是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截(&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;), 那么同一事件序列将不再向下分发(因为之后的&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;到来时, 由于之前&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时进行了事件拦截, &lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;没有机会赋值, 所以仍然为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 故直接走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;语句, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;intercepted = true&lt;/code&gt;);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值, 即不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 此时仍然会继续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;判断是否进行事件拦截, 需要注意的是此时仍然在同一事件序列中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 也没有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;仍为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 即走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, 交由&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不处理事件时, &lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;才只会调用一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // ViewGroup是否进行事件拦截
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            if (!canceled &amp;amp;&amp;amp; !intercepted) { // 如果拦截事件, 将不再分发给子View
                // 事件分发给子View
                ....
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 上面还讲了, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;, 这里还有一个影响因素是标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 该标志位是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;requestDisallowInterceptTouchEvent()&lt;/code&gt;设置的, 作用是在子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中强制父&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 但是该标志位不能影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;, 因为在一个事件序列开始之前会先进行状态重置, 如下; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;resetTouchState()&lt;/code&gt;中会将该标志位重置, 所以就不会影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState(); // 状态重置
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-事件分发&quot;&gt;3.2 事件分发&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截的话, 会将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理; 事件分发的主要代码如下; 逻辑也比较简单, 就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;进行将事件传递给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        ...
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &amp;lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign); // 设置mFirstTouchTarget的值
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                        ...
                    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续来看&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;的处理过程, 如下; 从上面的代码中我们可以看出, 将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;非空, 所以应该调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 这样就将事件传递到子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中去了; 这里关于子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;处理在后文继续讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        ...
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event); // child非null
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event); // 调用child.dispatchTouchEvent(event)

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面我们说过, 如果子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 将会去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的值, 该值的设置其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;中, 也就是说, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 就会去调用该函数, 也就证明了我们前面所说的; 我们来看&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;, 如下; 可以看出这里实际上相当于一个单链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget; 
        mFirstTouchTarget = target; // 设置mFirstTouchTarget
        return target;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-viewgroup处理事件&quot;&gt;3.3 ViewGroup处理事件&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;将进行事件处理, 如下; 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件处理也是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;, 只是传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 那么从上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;代码中我们可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;调用的应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;进行事件处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 调用的其实都是&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;, 所以接下来我们要看的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中对事件的处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-view事件处理&quot;&gt;四. View事件处理&lt;/h2&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中没有&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;方法来进行事件拦截; 我们这里关注的, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截之后对事件的处理以及子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理; 因为从前面我们已经说了, 不管是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件)还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent()&lt;/code&gt;(子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理事件), 其实都是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;; 所以二者对事件的处理实际上是一样的, 同时需要注意的是, 这一节不包括事件的分发了,
事件分发在上一节中已经讲解完啦~&lt;/p&gt;

&lt;p&gt;触摸事件的处理主要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;的处理优先级&lt;/p&gt;

&lt;p&gt;主要代码如下; 可以看出先处理的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;View.setOnTouchListener()&lt;/code&gt;)的话, 再去处理&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;,  所以&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的优先级比&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;高; 同时还要注意的一点是, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的话, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;将不再调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
            &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
            &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {  // OnTouchListener
        result = true;
    }
    if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { // onTouchEvent
        result = true;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick()&lt;/code&gt;其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;中处理的; 如下; &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;是在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中触发的, 可以看出, 要触发&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;需要的条件是: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是可以点击的(&lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;), 这里的可点击包括了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLICKABLE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LONG_CLICKABLE&lt;/code&gt;, 注意&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;enable&lt;/code&gt;属性不影响&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;的返回值, 只要它可点击, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;就会处理该点击事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                    if (!focusTaken) {
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) {
                            mPerformClick = new PerformClick();
                        }
                        if (!post(mPerformClick)) {
                            performClickInternal();
                        }
                    }
                }
                ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;进行处理, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;会判断, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 则会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的事件分发和处理流程就分析结束啦~; 我们最开始讲&lt;strong&gt;事件分发之源&lt;/strong&gt;时讲&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;对事件的传递的时候, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;getWindow().superDispatchTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的话, 就最终将事件交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理, 这种情况其实对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;都不进行事件处理, 那么就逐层回传咯~&lt;/p&gt;

&lt;p&gt;当然理论学习完了, 就应该实际测试一下, 这里笔者写了一个测试的&lt;code class=&quot;highlighter-rouge&quot;&gt;Demo&lt;/code&gt;, &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/touch/TouchActivity.java&quot;&gt;参见Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后将上述流程总结为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View事件分发.png&quot; alt=&quot;View事件分发机制&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
  </channel>
</rss>
