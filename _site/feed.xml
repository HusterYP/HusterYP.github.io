<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 04 Sep 2018 20:03:54 +0800</pubDate>
    <lastBuildDate>Tue, 04 Sep 2018 20:03:54 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>图片缓存之Picasso源码分析</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片缓存系列之&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;在开始之前, 我想先贴两张比较具有概括性的流程图&lt;/p&gt;

&lt;p&gt;下面这张是对&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;核心交互类的概括, 来自&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso.png&quot; alt=&quot;Picasso&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面这张是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;下载一张图片的时候的执行流程图, 来自&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso执行流程图.png&quot; alt=&quot;picasso流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 笔者在看&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码的时候, 发现其执行流程和上图有些不符, 主要是没有最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;Downloader&lt;/code&gt;, 下载过程完全交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去做, 应该是不同版本造成的; (本文对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码版本为&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso:2.71828&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中比较重要的类在上面第一张图片已经列出, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;; 下面分别总述一下其作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;: 该类是我们使用的起点, 是图片下载, 图片转换, 图片缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;; 其提供的静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;, 用于接收用户配置, 一般而言, 我们都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的一个全局实例(单例);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;: 顾名思义, 就是一个调度中转站, 用于分发请求(下载请求, 暂停请求, 恢复请求等), 传递数据(数据成功返回时进行分发绑定), 错误处理分发等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;: 这是一个抽象类, 提供了数据处理的公共抽象; &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;默认实现的有&lt;code class=&quot;highlighter-rouge&quot;&gt;AssetRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceDrawableRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContentStreamRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContactsPhotoRequestHandler&lt;/code&gt;; 分别对应于不同的处理场景和模式, 其中最重要和最常见的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;了; 当然, 也可以自定义实现该类, 用于处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;所没有涵盖的特殊情况(需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso.Builder.addRequestHandler(RequestHandler)&lt;/code&gt;注册)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面, 笔者将主要分析网络请求这一部分, 包括: 一条&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;被处理的完整流程,  暂停,恢复和取消请求机制, 缓存机制; 当然, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;还处理了很多其他情况, 如程序监控部分, 图片处理部分等, 但这些不是最主要的, 本文不再赘述&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-url处理流程&quot;&gt;二. URL处理流程&lt;/h2&gt;

&lt;p&gt;开始之前, 需要先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的典型使用, 如下; 各部分的作用都已经标注清楚了, 下面将对每一个过程进行讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     PicassoProvider.get() // 单例, 用于得到一个全局唯一Picasso实例
        .load(url) // 加载url
        .placeholder(R.drawable.placeholder) // 设置图片加载过程中的占位图片
        .error(R.drawable.error) // 设置出错后的占位图片
        .fit() // 图片处理部分, 表示将图片适应ImageView大小
        .tag(context) // 设置tag, 用于暂停, 恢复, 取消请求时使用
        .into(view); // 加载成功后设置到哪个View中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoProvider.get()&lt;/code&gt;是实现的一个单例模式, 如下; 该模式比较常见, 不多讲&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Picasso get() {
    if (instance == null) {
      synchronized (PicassoProvider.class) {
        if (instance == null) {
          Context autoContext = PicassoContentProvider.context;
          if (autoContext == null) {
            throw new NullPointerException(&quot;context == null&quot;);
          }
          instance = new Picasso.Builder(autoContext).build();
        }
      }
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面我们可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的实例是通过其静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;进行&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;的, 这也是一种典型的设计模式–&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;模式; 该模式对于有很多参数要设置时是很方便的, 这里没有进行额外的参数设置, 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部的默认参数(比如: 默认缓存大小, 使用自带&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;等进行请求处理等)&lt;/p&gt;

&lt;p&gt;之后的过程是将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;加载进去, 然后将该&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt;实例, 返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestCreator&lt;/code&gt;实例, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;into&lt;/code&gt;的时候, 进行异步请求图片; 当然, 在之前, 还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;placeholder()&lt;/code&gt;的过程, 该过程上面说了就是设置一个请求过程中的占位图片, 其内部做的也很简单, 只是将&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt;保留下来, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;中进行统一的逻辑处理&lt;/p&gt;

&lt;p&gt;接下来, 主要的处理逻辑都指向了&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;函数, 下面我们来详细看其逻辑; 如下, 先设置占位图片, 然后将请求封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;实例提交到线程池中处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void into(@NonNull ImageView target, @Nullable Callback callback) {
    ...
    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable()); // 设置占位图片
      }
      return;
    }
    ...
    Action action = new ImageViewAction(picasso, wrapper, request, callback);
    picasso.enqueueAndSubmit(action); // 提交请求
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.enqueueAndSubmit()&lt;/code&gt;又只是单纯的去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;中将任务分配给&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void submit(Action action) {
    dispatcher.dispatchSubmit(action);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行消息传递的, 该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherHandler&lt;/code&gt;, 我们直接去看其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;就好;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void handleMessage(final Message msg) {
    case REQUEST_SUBMIT: {
          Action action = (Action) msg.obj;
          dispatcher.performSubmit(action);
          break;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performSubmit()&lt;/code&gt;中进行处理, 将请求再次封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 之后提交给线程池进行异步加载, 即下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;service.submit()&lt;/code&gt;, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoExecutorService&lt;/code&gt;, 继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;, 默认开了&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个线程, 当然, 这部分与网络请求相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部也进行了判断, 比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;Wifi&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;2G&lt;/code&gt;环境下采用不同的请求策略, 感兴趣的话可以自己跟着走一遍, 这里的主要目的是看一个网络请求的完整处理过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void performSubmit(Action action, boolean dismissFailed) {
        ...
        hunter = forRequest(action.getPicasso(), this, cache, stats, action);
        hunter.future = service.submit(hunter);
        ...
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们上面说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 线程池执行的时候, 就是去执行其&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中, 有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;, 其作用是将请求得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;返回, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;是一个阻塞耗时方法, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;异步运行, 所以也没有问题; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;中, 又是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;的一个实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去处理的, 处理过程也是常规的图片下载过程, 如下;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    result = hunt();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void load(@NonNull Picasso picasso, @NonNull final Request request, @NonNull
  final Callback callback) {
    ...
    ResponseBody body = response.body();
    ...
    Bitmap bitmap = decodeStream(body.source(), request);
    callback.onSuccess(new Result(bitmap, loadedFrom));
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在图片接受完成之后, 再一步步函数返回, 封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;, 回传至&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行通知图片接受成功还是失败; 最终会在&lt;code class=&quot;highlighter-rouge&quot;&gt;deliver()&lt;/code&gt;中调用主线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;通知进行处理;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    if (result.getBitmap() == null &amp;amp;&amp;amp; result.getDrawable() == null) {
        dispatcher.dispatchFailed(this);
    } else {
        dispatcher.dispatchComplete(this);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void deliver(BitmapHunter hunter) {
    ...
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;的处理逻辑在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;类中, 很明显, 到这里之后就是将图片设置到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final Handler HANDLER = new Handler(Looper.getMainLooper()) {
    @Override public void handleMessage(Message msg) {
      switch (msg.what) {
        case HUNTER_COMPLETE: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          hunter.picasso.complete(hunter);
          break;
        }
        ...
      }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 从网络请求图片的一个完整过程就讲完了, 当然, 中间还涉及很多代码细节和处理, 最好自己跟着流程再一遍 ~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-暂停-恢复-取消请求处理&quot;&gt;三. 暂停, 恢复, 取消请求处理&lt;/h2&gt;

&lt;p&gt;暂停请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;; 恢复请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 取消请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;; 一般来说, 这些的使用场景是, 考虑当我们从网络加载图片填充到&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;的时候, 如果我们在用户不断滑动过程中不暂停请求的话, 那么就会造成加载的延迟和卡顿(因为在不断滑动过程中会产生许多网络请求); 一般比较通用的解决方法是给&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;GridScrollListener&lt;/code&gt;), 监听滑动过程, 在滑动过程中暂停请求, 停止滑动时恢复请求即可&lt;/p&gt;

&lt;p&gt;那么暂停, 恢复, 取消请求的实现机制又是如何的呢, 下面我们将一一分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31-暂停请求&quot;&gt;3.1 暂停请求&lt;/h3&gt;

&lt;p&gt;我们直接看&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;做了什么, 如下; 其直接交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行请求分发, 这也符合我们上面总述的时候讲的&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;的功能; 之后&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;仍然通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行事件分发, 如下; 而其对&lt;code class=&quot;highlighter-rouge&quot;&gt;TAG_PAUSE&lt;/code&gt;事件的处理则是直接转交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.performPauseTag(tag);&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void pauseTag(@NonNull Object tag) {
    checkNotNull(tag, &quot;tag == null&quot;);
    dispatcher.dispatchPauseTag(tag);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchPauseTag(Object tag) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performPauseTag()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedActions&lt;/code&gt;中, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performPauseTag(Object tag) {
    // Trying to pause a tag that is already paused.
    if (!pausedTags.add(tag)) { // 如果已经添加, 则直接返回
      return;
    }

    // Go through all active hunters and detach/pause the requests
    // that have the paused tag. // 否则, 遍历BitmapHunter, 将对应tag保存下来
    for (Iterator&amp;lt;BitmapHunter&amp;gt; it = hunterMap.values().iterator(); it.hasNext();) {
        ...
        pausedActions.put(single.getTarget(), single);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们什么时候会用到该&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;呢, 就是在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;分发请求的时候, 这里先去判断在&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中是否有对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;记录, 如果有的话, 就不进行请求分发, 那么自然也就不会去下载图片了 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performSubmit(Action action, boolean dismissFailed) {
    if (pausedTags.contains(action.getTag())) {
      pausedActions.put(action.getTarget(), action);
      ...
      return;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32--恢复请求&quot;&gt;3.2  恢复请求&lt;/h3&gt;

&lt;p&gt;恢复请求使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 恢复请求的过程和暂停请求的过程差不多, 前面都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;直接进行请求分发, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;去发送消息, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;进行处理; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;中, 一个是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中移除, 另一个是将原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;(封装了请求等信息)通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;传递, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;REQUEST_BATCH_RESUME&lt;/code&gt;的处理, 则是对每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeAction()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performResumeTag(Object tag) {
    // Trying to resume a tag that is not paused.
    if (!pausedTags.remove(tag)) {
      return;
    }

    List&amp;lt;Action&amp;gt; batch = null;
    for (Iterator&amp;lt;Action&amp;gt; i = pausedActions.values().iterator(); i.hasNext();) {
      Action action = i.next();
      if (action.getTag().equals(tag)) {
        if (batch == null) {
          batch = new ArrayList&amp;lt;&amp;gt;();
        }
        batch.add(action);
        i.remove();
      }
    }

    if (batch != null) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;resumeAction()&lt;/code&gt;中, 其实就是将请求交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueAndSubmit()&lt;/code&gt;, 而该过程在上面我们分析一个&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;的完整请求过程的时候, 已经看到过该函数了; 接下来的过程就不赘述了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void resumeAction(Action action) {
    ...
    enqueueAndSubmit(action);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-取消请求&quot;&gt;3.3 取消请求&lt;/h3&gt;

&lt;p&gt;取消请求用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;, 该函数一共有三个重载函数, 但是最终都是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelExistingRequest()&lt;/code&gt;处理, 接下来的过程和上面的过程差不多, &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.dispatchCancel()&lt;/code&gt;分发消息, 然后交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;传递消息, 最终调用&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;处理请求; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;移除就好了, 前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 所以将其移除之后, 自然就取消请求啦 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performCancel(Action action) {
    String key = action.getKey();
    BitmapHunter hunter = hunterMap.get(key);
    if (hunter != null) {
      hunter.detach(action);
      if (hunter.cancel()) {
        hunterMap.remove(key);
        ...
      }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;34-小结&quot;&gt;3.4 小结&lt;/h3&gt;

&lt;p&gt;到这里, 暂停, 恢复, 取消请求的过程我们已经有了比较详细的了解, 当然, 对于一个图片加载库来说, 这些接口也都是必备的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-缓存&quot;&gt;四. 缓存&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的缓存也分为内存缓存和磁盘缓存, 内存缓存基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;可以自行配置缓存大小等, 磁盘缓存依赖与&lt;code class=&quot;highlighter-rouge&quot;&gt;Http&lt;/code&gt;缓存, 不可配置&lt;/p&gt;

&lt;p&gt;至于内存缓存部分, 逻辑很常规, 在&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;中已经比较详细的讲过&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;的源码了, 可以参照该博客; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认使用的内存缓存最大容量是可用内存的&lt;code class=&quot;highlighter-rouge&quot;&gt;15%&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;磁盘缓存, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;去实现, 而没有明确的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;去缓存; 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;okhttp3.Cache&lt;/code&gt;, 该类中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;用于磁盘缓存; &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的缓存策略可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;, 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;OKHttp&lt;/code&gt;的缓存策略会单独抽取一篇博客出来;
这里只是简单提一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认的磁盘缓存策略, 即使用存储容量的&lt;code class=&quot;highlighter-rouge&quot;&gt;2%&lt;/code&gt;, 但是不多于&lt;code class=&quot;highlighter-rouge&quot;&gt;50M&lt;/code&gt;不少于&lt;code class=&quot;highlighter-rouge&quot;&gt;5M&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pciasso&lt;/code&gt;的主要源码就分析到这里, 最后还想贴一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的总体特性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;轻量级的图片加载库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自带监控功能, 可以检测&lt;code class=&quot;highlighter-rouge&quot;&gt;cache hit/内存大小&lt;/code&gt;等等数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片预加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程并发数依网络状态变化而变化, 优先级调度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片变换, 图片压缩, 自适应&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;易扩展&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是一个优秀的图片加载库, 其也具备了一个图片加载库应该具有的模块:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;请求分发模块。负责封装请求,对请求进行优先级排序,并按照类型进行分发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存模块。通常包括一个二级的缓存，内存缓存、磁盘缓存。并预置多种缓存策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载模块。负责下载网络图片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监控模块。负责监控缓存命中率、内存占用、加载图片平均耗时等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片处理模块。负责对图片进行压缩、变换等处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地资源加载模块。负责加载本地资源，如assert、drawable、sdcard等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示模块。负责将图片输出显示。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考链接&quot;&gt;六. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/&quot;&gt;Picasso源代码分析&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>图片三级缓存之内存缓存和磁盘缓存</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要分析&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中图片三级缓存中的前两级缓存, 即内存缓存(&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;)和磁盘缓存(&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;), 分析其源码实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-lrucache&quot;&gt;一. LruCache&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;常用作内存缓存, 也就是第一级缓存&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;内部使用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实例, 所以在继续往下看之前, 建议先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的特性, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;, 该文章有讲解如何将&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;用作内存缓存以及&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的一些基本分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 其依据是&lt;strong&gt;如果数据最近被访问过, 那么其将来被访问的几率也更大&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;逻辑其实比较简单, 大致逻辑就是: 设定最大阈值(&lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;), 当我们缓存一个新值的时候, 去判断是否超过该阈值, 如果超过了, 则移除最久未使用的缓存(这是利用的&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的特性, 可以参考上面的链接); 这是&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;的一个大致流程与思路, 接下来我们会详细讲解一些较为细节的地方&lt;/p&gt;

&lt;p&gt;先来看其构造函数: &lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;只有一个构造函数, 需要传递一个最大的缓存阈值; 同时需要注意的是, 这里构造&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的时候, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;标志位设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;了, 使得&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;通过访问顺序来构造双向链表, 这在我们讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;源码的时候重点分析过, 这里不再赘述 !&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public LruCache(int maxSize) {
        if (maxSize &amp;lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &amp;lt;= 0&quot;);
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap&amp;lt;K, V&amp;gt;(0, 0.75f, true);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, &lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;还允许重新设置该阈值, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;trimToSize()&lt;/code&gt;函数实现, 如下; 实现思路也很简单, 就是通过遍历当前缓存值, 然后不断删除最久未使用的缓存, 直到缓存量在阈值之下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     public void trimToSize(int maxSize) {
        while (true) {
            K key;
            V value;
            synchronized (this) {
                ...
                if (size &amp;lt;= maxSize || map.isEmpty()) {
                    break;
                }

                Map.Entry&amp;lt;K, V&amp;gt; toEvict = map.entrySet().iterator().next();
                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);
                size -= safeSizeOf(key, value);
                evictionCount++;
            }

            entryRemoved(true, key, value, null);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在我们平时使用的时候, 需要重点关注的有两个方法, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeOf()&lt;/code&gt;, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;entryRemoved()&lt;/code&gt;; 这两个方法通常都会根据实际需要重写; 两个方法也很简单, 下面分别讲解&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeOf()&lt;/code&gt;: 返回一个缓存条目的大小, 注意应该和&lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;在一个量级(以便正确比较); 其默认返回&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 单纯的表示缓存的条目数量, 代码很简单(只是&lt;code class=&quot;highlighter-rouge&quot;&gt;return 1&lt;/code&gt;而已), 这里就不贴啦 ~&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;entryRemoved()&lt;/code&gt;: 该方法有点意思, 默认是一个空方法, 没有做任何处理; 在发生&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;缓存冲突的时候(&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;重复, 冲突)和删除缓存条目的时候会调用(通过传入参数&lt;code class=&quot;highlighter-rouge&quot;&gt;evicted&lt;/code&gt;标志, &lt;code class=&quot;highlighter-rouge&quot;&gt;evicted == true&lt;/code&gt;表示为&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;是被删除的, &lt;code class=&quot;highlighter-rouge&quot;&gt;evicted == false&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;冲突被挤出来的)&lt;/p&gt;

&lt;p&gt;一般我们重写该方法是为了做一些旧数据的回收清理等特殊工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-disklrucache&quot;&gt;二. DiskLruCache&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;常用作磁盘缓存, 也就是第二级缓存; 虽然其没有纳入&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;的官方&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 但是受到了&lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;的官方推荐; 源代码可以从&lt;a href=&quot;https://github.com/JakeWharton/DiskLruCache&quot;&gt;Github&lt;/a&gt;下载&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的基本思路是, 将文件缓存到磁盘上, 设定最大的缓存阈值, 超过该值的时候, 会在后台去清除旧缓存&lt;/p&gt;

&lt;p&gt;需要注意的是, 这里旧文件的清除是在后台线程完成的(实际上是开了一个线程池去做该工作), 有时候缓存的文件总量会暂时超过最大阈值, 所以对缓存容量比较敏感的程序应该设置保守的缓存阈值&lt;/p&gt;

&lt;p&gt;先来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的构造函数; 其只有一个构造函数, 如下; 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;directory&lt;/code&gt;表示缓存目录; &lt;code class=&quot;highlighter-rouge&quot;&gt;appVersion&lt;/code&gt;表示应用版本号, 当该值改变时, &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;会清除所有缓存, 默认需要从网上拉取新数据; &lt;code class=&quot;highlighter-rouge&quot;&gt;valueCount&lt;/code&gt;表示的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;可以对应多少个文件, 通常都传入&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;即可, 该值通常用于表示将一个大文件分成多个小文件存放, 存放的规则是, &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;后面加上自增的索引(如&lt;code class=&quot;highlighter-rouge&quot;&gt;key1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;key2&lt;/code&gt;等)(当然, 这些都是内部处理细节, 具体使用的时候可以不用管); &lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;表示的是缓存阈值(&lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
    this.directory = directory;
    this.appVersion = appVersion;
    this.journalFile = new File(directory, JOURNAL_FILE);
    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
    this.valueCount = valueCount;
    this.maxSize = maxSize;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的文件缓存依赖于日志文件, 即存储在同一文件夹下的名为&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;的文件, 在该文件中, 存储了每个文件缓存的信息;  在开始之前, 需要先了解一下该文件的格式, 因为后面会去读取该日志文件, 做判断; 关于该文件格式, 可以参考&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/28863651&quot;&gt;Android DiskLruCache完全解析，硬盘缓存的最佳方案&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          libcore.io.DiskLruCache
          1
          100
          2
     
          CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
          DIRTY 335c4c6028171cfddfbaae1a9c313c52
          CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
          REMOVE 335c4c6028171cfddfbaae1a9c313c52
          DIRTY 1ab96a171faeeee38496d8b330771a7a
          CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
          READ 335c4c6028171cfddfbaae1a9c313c52
          READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;中, 有三个重要的内部类, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;, 用于文件写入; 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;, 表示一个文件信息节点; 还有一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Snapshot&lt;/code&gt;, 表示文件节点的快照, 其实就是为了防止数据更改, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;信息做了一层封装&lt;/p&gt;

&lt;p&gt;其中, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;成员变量, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;成员变量, 这是为了考虑在多线程中使用的时候, 通过判断携带的是不是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;来判断是否是在同一个线程中操作同一个文件; 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;不允许多个线程去操作同一个文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Editor {
    private final Entry entry;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final class Entry {
    ...
    private Editor currentEditor;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 这里还需要关注的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;是如何判断哪些文件是旧文件; 这里我们发现了一个熟悉的身影, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;
private final LinkedHashMap&amp;lt;String, Entry&amp;gt; lruEntries = new LinkedHashMap&amp;lt;String, Entry&amp;gt;(0, 0.75f, true);&lt;/code&gt;, 前面我们知道了&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的访问特性来实现旧文件的判断和移除, 这里其实也是一样, 只不过这里存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;; 这也是前面日志文件&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;的作用&lt;/p&gt;

&lt;p&gt;在初始化的时候, 会先去&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;日志文件读取键值信息, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;readJournal()&lt;/code&gt;中不断的去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;文件, 然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;readJournalLine()&lt;/code&gt;构建信息, 存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;中; 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;值或者判断旧文件去移除的时候, 就直接去查询&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;中的值就好了; 至于判断旧文件的原理, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;一样, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void readJournal() throws IOException {
    ...
    while (true) {
        try {
          readJournalLine(reader.readLine());
          lineCount++;
        } catch (EOFException endOfJournal) {
          break;
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void readJournalLine(String line) throws IOException {
    ...
    Entry entry = lruEntries.get(key);
    if (entry == null) {
      entry = new Entry(key);
      lruEntries.put(key, entry);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-总结&quot;&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;到这里, 我们对内存缓存和磁盘缓存所需要使用到的两个类有了较为详细的了解, 之后该动手自己实践啦 !&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之LinkedHashMap</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识; 本文将主要讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的实现原理和处理细节&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 所以需要先对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;有一个基本的认识, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;元素遍历无序, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;元素遍历有序以外, 具有&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的大多数特点; 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;内部还有一个双向链表, 用于记录元素顺序(这也是保证其遍历有序的原因), 具体有两种顺序,  一个是插入顺序, 一个访问顺序; 同时, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;还可以用来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法(&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 即最近最少使用算法); 本文将主要分析&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的两个大方面: 一个是遍历有序, 另一个是用于&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的特性&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-遍历有序&quot;&gt;二. 遍历有序&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;遍历有序, 主要是因为其在&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的基础上, 增加了一个双向链表, 按照元素的插入顺序或者访问顺序, 将数据重新组织成一个双向链表; 根据标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;final boolean accessOrder;&lt;/code&gt;来决定是按照插入顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;insertion-order&lt;/code&gt;, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder = false&lt;/code&gt;)还是访问顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;access-order&lt;/code&gt;, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder = true&lt;/code&gt;)来组织&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;改写了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的节点, 如下; 在其中增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;before&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;after&lt;/code&gt;域用于帮助组织双向链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
        Entry&amp;lt;K,V&amp;gt; before, after;
        Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, value, next);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;值的指定只能在创建&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的时候, 也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;并没有提供明确的&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;方法来改变该值(一旦在构造函数中指定, 就无法改变); &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;提供了如下构造函数可以用于指定&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;的值, 其余构造函数中, &lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;都默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, 即默认以&lt;code class=&quot;highlighter-rouge&quot;&gt;insertion-order&lt;/code&gt;的顺序组织双向链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;重写了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;newNode()&lt;/code&gt;函数, &lt;code class=&quot;highlighter-rouge&quot;&gt;newNode()&lt;/code&gt;在进行元素插入的时候会被&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap.putVal()&lt;/code&gt;调用, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;用自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;节点替换&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;节点的同时, 进行双向链表的构建, 使得程序改动最小&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Node&amp;lt;K,V&amp;gt; newNode(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; e) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
            new LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);
        linkNodeLast(p); // 将节点插入到双向链表的末尾
        return p;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于&lt;code class=&quot;highlighter-rouge&quot;&gt;linkNodeLast()&lt;/code&gt;函数, 即将节点插入到双向链表的末尾, 该方法比较简单, 这里就不再贴源码啦 !&lt;/p&gt;

&lt;p&gt;那么当我们指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的时候, 即以元素访问顺序来组织双向链表的时候, 其实就只是在获取元素的时候, 将被访问的元素移动到链表末尾; 如下; 那么链表表头的元素就是最近没有被访问的元素, 这也是我们实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的依据(稍后会细讲)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder) // 如果指定为按照元素访问顺序组织元素
            afterNodeAccess(e); // 将元素移动到链表末尾
        return e.value;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { // move node to last
        // 省略具体细节
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里, 我们对&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;遍历有序的原因有了较为详细的了解; 接下来要讲的是&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的一个应用, 即用于实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的特性&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-lru算法&quot;&gt;三. LRU算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 其依据是&lt;strong&gt;如果数据最近被访问过, 那么其将来被访问的几率也更大&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;(内存缓存)内部就是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实现的&lt;/p&gt;

&lt;p&gt;前面我们讲了, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即按照元素访问顺序组织数据的时候, 会在&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;方法中将被访问的元素移动到链表的末尾, 那么链表首部的元素就是最久没有访问的, 所以, 当要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;的时候, 必须将&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外, 还需要我们自己去定义&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;的实现规则, 即自己定义什么时候应该移除最久没有使用的元素; 此时我们需要去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;函数, &lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;是在我们插入一个元素完毕之后, 回调&lt;code class=&quot;highlighter-rouge&quot;&gt;afterNodeInsertion()&lt;/code&gt;中调用的, 如下; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;默认返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, 所以需要我们自己去定义规则&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; first;
        if (evict &amp;amp;&amp;amp; (first = head) != null &amp;amp;&amp;amp; removeEldestEntry(first)) { // 插入元素之后, 判断是否需要移除最久没有访问的元素
            K key = first.key;
            removeNode(hash(key), key, null, false, true); // 移除链表首部的元素
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于自定义规则, 比如: 约定最多在内存中缓存多少个元素, 超过该阈值之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即将旧元素移除; 或者, 规定缓存占用多少内存, 当达到该阈值之后, 即进行旧元素移除; 当然, 这些都是后话, 具体的&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法, 可以根据实际需求来定&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-总结&quot;&gt;四. 总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 总体上比较简单, 主要掌握上文说的两个主要特点即可, 不再赘述 !&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之Set</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;的实现类, 即常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-hashset&quot;&gt;一. HashSet&lt;/h2&gt;

&lt;p&gt;没有重复元素, 允许null&lt;/p&gt;

&lt;p&gt;内部通过HashMap实现&lt;/p&gt;

&lt;p&gt;关于负载因子理解:
Iterating over this set requires time proportional to the sum of the HashSet instance’s size (the number of elements) plus the “capacity” of the backing HashMap instance (the number of buckets). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.&lt;/p&gt;

&lt;p&gt;不保证Set的遍历顺序, 不保证元素的存储数据, 
一下方法提供常量时间: add, remove, contains and size
非同步, 可以使用Collections.synchronizedSet(new HashSet(…));
Iterator遍历的时候, 多线程抛出异常&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;(遍历过程中修改数据, 但是可以使用Iterator自己提供的remove()方法, 该方法不会造成异常)&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之List</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;的实现类, 即常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-arraylist&quot;&gt;一. ArrayList&lt;/h2&gt;

&lt;h3 id=&quot;11-特点概述&quot;&gt;1.1 特点概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里先将结论给出, 稍后会挑重难点详细讲解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动态数组: &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;是一个动态数组, 所谓的动态数组, 就是使用时不必担心扩容问题(会自动扩容, 其实现原理其实也是通过创建一个更大的数组来进行数据拷贝, 关于扩容规则稍后会细讲);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持随机访问: 既然是基于数组实现的, 那么其当然也就具备了数组的随机访问特点, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccess&lt;/code&gt;接口来标识&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;是否支持随机访问(该接口实际上没有方法, 只是为了在使用某些算法时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof RandomAccess&lt;/code&gt;去判断作用对象是否支持随机访问, 如果支持的话, 就可以使用某些特定算法)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持序列化: 实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程不安全: 多线程使用时可能会出现问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-动态数组&quot;&gt;1.2 动态数组&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;的默认初始容量为&lt;strong&gt;10&lt;/strong&gt;, 其提供了三个构造函数, 分别是: &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList(int initialCapacity)&lt;/code&gt;(支持指定初始容量); &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList()&lt;/code&gt;(无参构造函数); &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList(Collection&amp;lt;? extends E&amp;gt; c)&lt;/code&gt;(支持从已有数据集创建)&lt;/p&gt;

&lt;p&gt;我们最常见的用法是: &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&amp;lt;T&amp;gt; arr = new ArrayList();&lt;/code&gt;; 因此我们先来看其无参构造函数, 如下;  其中&lt;code class=&quot;highlighter-rouge&quot;&gt;elementData&lt;/code&gt;就是用于存储数据的数组; &lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt;是一个初始长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的数组, 这样设计的原因也是为了节约空间(因为没必要一开始就占用内存空间, 合理的做法应该是在具体需要使用的时候再去分配)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是使用无参构造函数进行创建的话, 那么在第一次使用&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;进行数据添加的时候会进行第一次扩容, 也就是扩展到默认初始容量(10); 见下面代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // 此时size为0
        elementData[size++] = e;
        return true;
    }

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 这里相等进入
            return Math.max(DEFAULT_CAPACITY, minCapacity); // 返回默认初始容量
        }
        return minCapacity;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那如果并非是第一次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;操作呢, 其扩容规则又如何; 这里的代码也比较简单, 在下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;grow()&lt;/code&gt;函数中; 逻辑比较简单, 扩容规则是, 增加当前数组长度的&lt;strong&gt;50%&lt;/strong&gt;; 那么是不是每次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作的时候都会进行扩容呢, 肯定不是的, 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;会造成溢出时才会进行扩容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void grow(int minCapacity) {
        int oldCapacity = elementData.length; // 注意这里用来判断的是数组的长度, 而不是当前数据个数
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1); // 扩容50%
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-随机访问&quot;&gt;1.3 随机访问&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;由于内部使用数组实现, 所以能够支持快速的索引定位, 但是数组的连续空间在带来增加和索引查找便利的同时, 也使得删除元素变得相对耗时, 所以在实际使用的时候, 需要根据需求特点来合理选择&lt;/p&gt;

&lt;h3 id=&quot;14-iterator遍历&quot;&gt;1.4 Iterator遍历&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;支持普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历, 也自己实现了一个特殊的&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;遍历&lt;/p&gt;

&lt;h4 id=&quot;14-1-iterator遍历的效率&quot;&gt;1.4-1 Iterator遍历的效率&lt;/h4&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历, &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环遍历和&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;遍历的效率分析, 可以参见文末&lt;strong&gt;参考链接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里只是单纯的讲一下结论:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环遍历的效率比另外两种高, 因为其支持随机访问; &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环适合访问顺序存储结构, 可以根据下标快速获取指定元素(即支持随机访问)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;适合访问链式存储结构(如在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;中其访问效率就比&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;高), 因为迭代器是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Pre()&lt;/code&gt;来定位的, 但它也可以访问顺序存储结构的集合(&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;的使用效率其实和&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;差不多)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;最大的一个好处是, 可以随时修改或者删除集合内部的元素, 并且是在不需要知道元素和集合的类型的情况下进行的(当需要对不同的容器实现同样的遍历方式时, 迭代器是最好的选择)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;14-2-iterator和listiterator&quot;&gt;1.4-2 Iterator和ListIterator&lt;/h4&gt;

&lt;p&gt;二者最大的区别就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;支持双向的遍历, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;只是常规的从头到尾的遍历&lt;/p&gt;

&lt;h3 id=&quot;15-线程不安全&quot;&gt;1.5 线程不安全&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;不是一个线程安全的集合, 如果要在多线程的情况下使用, 可以考虑用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedList(List l)&lt;/code&gt;函数返回一个线程安全的&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;类, 也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;concurrent&lt;/code&gt;并发包下的&lt;code class=&quot;highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;类或者遗留的&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历的过程中, 如果用户&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;了元素的话, 会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;异常, 其实这也是一种保护机制, 具体代码如下; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;modCount&lt;/code&gt;是每次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法都会自增的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public E next() {
            checkForComodification();
            ...
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

        int expectedModCount = ArrayList.this.modCount;  // 这个值在初始化Iterator时就确定了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-linkedlist&quot;&gt;二. LinkedList&lt;/h2&gt;

&lt;h3 id=&quot;21-特点概述&quot;&gt;2.1 特点概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;老规矩, 先给出总的结论!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;特殊数据结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;可以被用作特殊的数据结构, 如: 双向链表, 堆栈, 队列或者双端队列等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;序列化: 实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程不安全: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;不支持线程同步, 当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;去遍历的时候, 在多线程时, 可能会出现问题(抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;异常)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-特殊数据结构&quot;&gt;2.2 特殊数据结构&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;内部是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;为节点连接起来的一个链表, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;节点的组织方式(如下), 其实也可以看出, 其有两个指针, 一个指向前驱, 一个指向后继, 那么很自然的, 其就支持双向的遍历, 同时, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;对外提供了丰富的接口, 让我们可以根据自己的需要, 去选择将其视为哪种数据结构来使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;

        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;一样, 我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;来方便的实现双向的遍历, 同时其还提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;addFirst()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addLast()&lt;/code&gt;方法, 以及明确的&lt;code class=&quot;highlighter-rouge&quot;&gt;push()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pop()&lt;/code&gt;方法, 那么我们就可以根据自己的组织方式将其视为双向链表或者堆栈等来使用, 当然, 其还有许多其他有用接口, 具体使用时再去查看即可, 这里不做多讲&lt;/p&gt;

&lt;h3 id=&quot;23-线程不安全&quot;&gt;2.3 线程不安全&lt;/h3&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;一样, 其也没有实现线程同步, 所以在多线程时, 也要慎用; 当然, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedList(new LinkedList(...))&lt;/code&gt;来进行包装, 成为一个线程安全的&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面讲了&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;遍历的过程中, 如果对数据进行了修改, 那么会抛出异常, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;也有同样的问题, 原因也一样, 这里不再赘述&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-总结&quot;&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;到这里, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;有关的两个常用实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;就讲解完了, 重点在于掌握每种实现的特点, 在实际使用的时候再去具体选择, 总的来说, 这两种实现都比较简单, 涉及到的算法也不难; 需要回顾的话, 翻到前面去看每种实现的概述即可!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/aoguren/p/4771589.html&quot;&gt;Iterator和for效率分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之HashMap</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识; 本文将主要讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的实现原理和处理细节&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;我们知道&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;存储的是一组键值对, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;底层实际上就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;数组, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值, 映射到对应的数组位置, 这样存取都采用相同的规则, 利用数组的快速索引, 实现理想状态下的&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;时间定位; 但是其中也有很多处理细节, 比如一个最常见的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;冲突处理, 本文将主要介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的三大方面, 包括: &lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;规则, 扩容规则, 解决冲突&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-hash规则&quot;&gt;二. Hash规则&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;规则就是如何将一个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;映射到对应的数组索引位置; 首先来看如何得到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;值; 如下&lt;code class=&quot;highlighter-rouge&quot;&gt;hash()&lt;/code&gt;函数, 该函数也叫扰动函数, 扰动函数做 的事情是将&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值的高位与低位做异或运算(以&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位计算, &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;正好是&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;的一半)(这里说明一下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;是无符号右移, 高位补0), 这样做的目的是为了混合高低位的信息, 使得取余计算索引值的时候, 不仅仅只是低位起作用, 减少冲突发生的可能性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里需要联系索引值的计算来理解, 如下, 取存放一个键值对为例, 索引值的计算式子为&lt;code class=&quot;highlighter-rouge&quot;&gt;(n - 1) &amp;amp; hash&lt;/code&gt;(注意该式实际上等价于&lt;code class=&quot;highlighter-rouge&quot;&gt;hash % n&lt;/code&gt;, 即为了保证在有效索引范围内, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;取余, 只是这里为了提高效率, 使用位运算代替了模运算, 关于优化程序性能, 可以&lt;a href=&quot;https://husteryp.github.io/2018/08/24/Details/&quot;&gt;参见博客&lt;/a&gt;), 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;是数组的长度, 因为在&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中, 数组长度始终取的是&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂, 所以这里&lt;code class=&quot;highlighter-rouge&quot;&gt;n - 1&lt;/code&gt;就相当于是一个掩码(全&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 比如默认初始长度&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, 减一后为&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;, 二进制为&lt;code class=&quot;highlighter-rouge&quot;&gt;1111&lt;/code&gt;), 高位补&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 进行与运算时, 就相当于只取了低位, 本来理想状态下, 如果数组长度足够大的话, 其实不需要扰动函数也可以, 因为数组长度足够大, 相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;值足够大, 那么取的有效位也就足够大, 发生冲突的概率也就相对降低了; 但是实际情况是,
需要在空间利用率, 时间消耗和冲突频率之间取一个折中值, 空间上是不可能达到理想情况的, 那么这时候就需要一个扰动函数, 将高位的影响保留下来, 减少冲突, 因为如果只看低位的话, 冲突发生的频率还是很高的;&lt;/p&gt;

&lt;p&gt;当然, 如果这里你还是没有弄清楚的话, 可以参见&lt;a href=&quot;https://www.zhihu.com/question/20733617&quot;&gt;HashMap中的hash原理&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)  // 计算索引, 即 (n - 1) &amp;amp; hash
            tab[i] = newNode(hash, key, value, null);
        ...
     }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此外, 这里还想额外补充一点的是关于对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;方法和&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中每一种数据类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;方法都必须和&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法一致, 也就是说, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;a.equals(b)&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;a.hashCode()&lt;/code&gt;必然和&lt;code class=&quot;highlighter-rouge&quot;&gt;b.hashCode()&lt;/code&gt;相等; 相反, 如果两个对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;不同, 我们就知道该两个对象不同, 但是如果两个对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;相等, 这两个对象也可能不同, 此时还需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;去判断&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-扩容规则&quot;&gt;三. 扩容规则&lt;/h2&gt;

&lt;p&gt;讲扩容规则之前, 需要先看一下最开始的地方, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的构造函数;  但是在此之前, 我想先介绍一下&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的几个重要成员变量和概念:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;transient Node&amp;lt;K,V&amp;gt;[] table;&lt;/code&gt;: 这个就是&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的底层实现数组, 比较好理解&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int threshold;&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;的意思是&lt;strong&gt;阈值&lt;/strong&gt;, 标志当&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;表内元素数量超过该值时, 会发生扩容(&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;final float loadFactor;&lt;/code&gt;: 加载因子, 用于计算&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;threshold = table.length * loadFactor&lt;/code&gt;; 合理的加载因子可以在空间和冲突频率上取的较好的折中(提高空间利用率, 同时减少冲突发生,  减少扩容次数), 默认加载因子为&lt;code class=&quot;highlighter-rouge&quot;&gt;0.75&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来看&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的构造函数, 看其构造规则&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;有四个构造函数, 如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;传入初始容量与加载因子: 但是并不是说指定的初始容量是多少, 构造的&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;容量就是多少; &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的初始容量是取大于&lt;code class=&quot;highlighter-rouge&quot;&gt;initialCapacity&lt;/code&gt;的最小&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的数(比如传入&lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt;的话, 实际容量就会取&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;); 这里的作用主要在&lt;code class=&quot;highlighter-rouge&quot;&gt;tableSizeFor()&lt;/code&gt;函数中(如下); 这里之所以要取成&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂, 是为了方便用各种位运算代替算数运算, 提高效率(比如上面的用与运算代替取模运算)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public HashMap(int initialCapacity, float loadFactor) {
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) // 其中MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30;
            initialCapacity = MAXIMUM_CAPACITY; // 初始容量不能超过MAXIMUM_CAPACITY
        if (loadFactor &amp;lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
        this.loadFactor = loadFactor;
        this.threshold = tableSizeFor(initialCapacity);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 返回大于cap的最小的2的整数次幂的数
    static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 1;
        n |= n &amp;gt;&amp;gt;&amp;gt; 2;
        n |= n &amp;gt;&amp;gt;&amp;gt; 4;
        n |= n &amp;gt;&amp;gt;&amp;gt; 8;
        n |= n &amp;gt;&amp;gt;&amp;gt; 16;
        return (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;传入初始容量: 如下; 当只是指定初始容量时, 则使用默认装载因子&lt;code class=&quot;highlighter-rouge&quot;&gt;0.75&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f;&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public HashMap(int initialCapacity) {
        this(initialCapacity, DEFAULT_LOAD_FACTOR); // DEFAULT_LOAD_FACTOR = 0.75
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;默认构造函数: 都使用默认值, 其中装载因子默认&lt;code class=&quot;highlighter-rouge&quot;&gt;0.75&lt;/code&gt;, 初始容量默认&lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4&lt;/code&gt;(即&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;);&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public HashMap() {
        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;从已有数据构建: 使用默认装载因子; 同时通过传入数据数量进行构建&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) {
        this.loadFactor = DEFAULT_LOAD_FACTOR;
        putMapEntries(m, false);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述构造函数中, 使用默认值时, 都是只指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;loadFactor&lt;/code&gt;的默认值, 没有明确设定初始容量值, 那么该初始容量值又是在哪里指定的呢? 其实, 默认初始容量值是在&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;函数中指定的, 接下来马上讲解 !&lt;/p&gt;

&lt;p&gt;扩容, 由&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;函数作用; &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;函数比较长, 具体逻辑可以参见下面代码和注释来理解; 作用主要有两方面: 一个是初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;, 另一个是扩容, 即将&lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;大小增大一倍&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    final Node&amp;lt;K,V&amp;gt;[] resize() {
        Node&amp;lt;K,V&amp;gt;[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap &amp;gt; 0) {
            if (oldCap &amp;gt;= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            else if ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; // newCap = oldCap &amp;lt;&amp;lt; 1: 容量增大一倍
                     oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)
                newThr = oldThr &amp;lt;&amp;lt; 1; // 阈值增大一倍
        }
        else if (oldThr &amp;gt; 0) // 如果构造函数中设置了阈值, 那么就不会走下一步else, 即不会使用默认初始容量进行初始化
            newCap = oldThr;
        else {               // 如果oldCap == 0的话, 就需要进行初始化
            newCap = DEFAULT_INITIAL_CAPACITY; // 使用默认容量进行初始化
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); // 装载因子: threshold = length * loadFactor
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (float)MAXIMUM_CAPACITY ?
                      (int)ft : Integer.MAX_VALUE);
        }

        // 分配空间, 设置新阈值
        threshold = newThr; 
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
            Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])new Node[newCap];
        table = newTab;
        if (oldTab != null) {
            for (int j = 0; j &amp;lt; oldCap; ++j) {
                // 将旧值移动到新的位置
                ...
            }
        }
        return newTab;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;的时候进行了空间重新分配和数据的移动, 是一个相对比较耗时的操作, 所以应该合理设置初始容量和加载因子(一般都使用默认加载因子), 来减少扩容次数&lt;/p&gt;

&lt;p&gt;上面我们详细了解了一下扩容函数&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;的过程, 接下来要解决的是什么时候进行扩容; 其实这个问题, 我们直接看什么时候调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;即可; 调用关系主要分为两类, 如下; 可以很明显的看出, 当超出阈值的时候, 需要进行扩容; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;table&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 即尚未初始化的时候, 需要进行初始化; 其实这也对应了上面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;resize()&lt;/code&gt;函数的两个作用: 容量倍增和初始化&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if (s &amp;gt; threshold)
        resize();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-解决冲突&quot;&gt;四. 解决冲突&lt;/h2&gt;

&lt;p&gt;冲突的解决是&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中的一个重难点; 造成冲突的原因就是不同的键值对经过计算后得出相同的数组索引映射;&lt;/p&gt;

&lt;p&gt;在之前的版本中, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;采用&lt;strong&gt;数组+链表&lt;/strong&gt;实现, 即使用链表处理冲突, 同一&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值的节点都存储在一个链表里, 但是当链表中的元素较多, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值相等的元素较多时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;值依次查找的效率较低; 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.8&lt;/code&gt;中, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;采用&lt;strong&gt;数组+链表+红黑树&lt;/strong&gt;实现, 当链表长度超过转换阈值(默认转换阈值为&lt;code class=&quot;highlighter-rouge&quot;&gt;TREEIFY_THRESHOLD = 8;&lt;/code&gt;)时, 将链表转换为红黑树, 这样大大减少了查找时间(将&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;方法的性能从&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;提升到&lt;code class=&quot;highlighter-rouge&quot;&gt;O(logN)&lt;/code&gt;); 同样,
当&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;元素使得红黑树中元素个数小于&lt;code class=&quot;highlighter-rouge&quot;&gt;UNTREEIFY_THRESHOLD&lt;/code&gt;阈值时(默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;UNTREEIFY_THRESHOLD = 6&lt;/code&gt;), 将红黑树转换为链表&lt;/p&gt;

&lt;p&gt;要看如何解决冲突, 当然是在存放一个值的时候咯! 如下&lt;code class=&quot;highlighter-rouge&quot;&gt;putVal()&lt;/code&gt;; 逻辑比较简单, 结合注释过一遍即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;

        if ((tab = table) == null || (n = tab.length) == 0) // resize, 上面已经讲了, 不多说
            n = (tab = resize()).length;
        
        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null) // 没有发生冲突时, 直接存放即可
            tab[i] = newNode(hash, key, value, null);
        else { // 发生冲突
            Node&amp;lt;K,V&amp;gt; e; K k;
            if (p.hash == hash &amp;amp;&amp;amp;
                ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                e = p;
            else if (p instanceof TreeNode) // 如果本来就已经使用红黑树进行存储的了
                e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) { 
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // 超出阈值, 链表转换为红黑树
                            treeifyBin(tab, hash);
                        break;
                    }
                    // 如果键值对已经存在, 不能重复存放
                    if (e.hash == hash &amp;amp;&amp;amp;
                        ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                        break;
                    p = e;
                }
            }

            // 如果存在重复key, 那么进行value替换
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
        ...
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来主要看两种数据结构的组织方式&lt;/p&gt;

&lt;h3 id=&quot;41-链表&quot;&gt;4.1 链表&lt;/h3&gt;

&lt;p&gt;链表节点是&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;, 如下; 也是常规的单链表数据结构, 只是数据域多了一个键值(&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;); 比较简单, 没话说！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
        final int hash; // 软缓存
        final K key;
        V value;
        Node&amp;lt;K,V&amp;gt; next;

        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
        
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里需要提一个小的知识点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;软缓存&lt;/strong&gt;: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值计算起来很困难, 那么就可以将第一次计算出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值缓存起来(&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;就是这样的); &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;节点也使用了这种缓存&lt;/p&gt;

&lt;h3 id=&quot;42-红黑树&quot;&gt;4.2 红黑树&lt;/h3&gt;

&lt;p&gt;红黑树, 实际上也是一棵二叉查找树, 能够保证增加, 删除, 查找的最坏时间复杂度为&lt;code class=&quot;highlighter-rouge&quot;&gt;O(logN)&lt;/code&gt;; 红黑树的具体实现细节, 本文不做多讲, 一方面是该知识点也是一个很庞杂的体系, 一时半会也讲不透; 另一方面就是, 对于本文来说, 只需要了解红黑树的特点就可以了; 当然关于红黑树详细的资料, 可以&lt;a href=&quot;https://blog.csdn.net/v_JULY_v/article/details/6105630&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里, 我们简单看一下其节点组织方式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static final class TreeNode&amp;lt;K,V&amp;gt; extends LinkedHashMap.Entry&amp;lt;K,V&amp;gt; {
        TreeNode&amp;lt;K,V&amp;gt; parent;  // red-black tree links
        TreeNode&amp;lt;K,V&amp;gt; left; // 指向左节点指针
        TreeNode&amp;lt;K,V&amp;gt; right; // 指向右节点指针
        TreeNode&amp;lt;K,V&amp;gt; prev;    // 用于将红黑树转换为单链表时所用
        boolean red; // 红黑咯 !
        TreeNode(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, val, next);
        }

        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;相关的三大重难点就分析完了, 记忆的时候, 也可以从这三点出发, 虽然不必记忆具体的代码细节, 但是对于大致流程和设计思想还是要有印象的&lt;/p&gt;

&lt;p&gt;当然, 作为集合框架中的一员, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;还有一些其他特点, 如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;非同步: &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;不是线程安全的; 多线程中要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的话, 可以考虑使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedMap(new HashMap(...));&lt;/code&gt;来进行包装&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历抛异常: &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;; 这个和大多数集合一样; 也是在多线程中使用的时候可能出现的问题, 具体原因可以&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/&quot;&gt;Java集合框架之List&lt;/a&gt;中的分析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;支持&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 也支持&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;无序: 即遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;得到的数据顺序并不是最初其存放顺序, 因为会伴随这再&lt;code class=&quot;highlighter-rouge&quot;&gt;Hash&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外, 集合框架中还有一个叫&lt;code class=&quot;highlighter-rouge&quot;&gt;HashTable&lt;/code&gt;的, 这里简要贴一下他们之间的区别:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashTable&lt;/code&gt;是线程安全的, 且不允许&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashTable&lt;/code&gt;默认容量是&lt;code class=&quot;highlighter-rouge&quot;&gt;11&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashTable&lt;/code&gt;是直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode(key.hashCode())&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值, 不像&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;内部使用&lt;code class=&quot;highlighter-rouge&quot;&gt;static final int hash(Object key)&lt;/code&gt;扰动函数对&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode&lt;/code&gt;进行扰动后作为&lt;code class=&quot;highlighter-rouge&quot;&gt;hash&lt;/code&gt;值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashTable&lt;/code&gt;取哈希桶下标是直接用模运算&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; (因为其默认容量也不是&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;次方, 所以也无法用位运算替代模运算)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩容时, 新容量是原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;倍&lt;code class=&quot;highlighter-rouge&quot;&gt;+1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;int newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Dictionary&lt;/code&gt;的子类同时也实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;接口, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;接口的一个实现类&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考链接&quot;&gt;六. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/20733617&quot;&gt;HashMap中的hash原理&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架概述</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Java集合框架概述; 主要总述Java集合框架的设计理念, 组成和基本接口(及其区别等)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-设计理念&quot;&gt;一. 设计理念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在Java 2之前，Java是没有完整的集合框架的。它只有一些简单的可以自扩展的容器类，比如Vector，Stack，Hashtable等)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java集合其实就是一组对象的集合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;独立于实现细节, 方便重用, 保证向下兼容(即保留了&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt;等旧的API)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加强了API之间的互通信, 减少了新API的学习: 提供尽量统一的接口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-基本组成&quot;&gt;二. 基本组成&lt;/h2&gt;

&lt;h3 id=&quot;21-总述&quot;&gt;2.1 总述&lt;/h3&gt;

&lt;p&gt;Java集合框架主要分为三个部分: &lt;strong&gt;接口, 实现和算法&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;21-1-接口&quot;&gt;2.1-1 接口&lt;/h4&gt;

&lt;p&gt;接口指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;为起始的一系列公用接口&lt;/p&gt;

&lt;p&gt;实际上从&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;出发的并不是真正的集合, 只是其包含集合视图操作, 所以也将其归入集合框架中&lt;/p&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;出发的公用接口主要有以下几个, 也是这次会着重讲解和比较的; 当然, 下面的接口并不全面, 在后面会逐渐扩展和补充&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_Collection/Collection基本接口.png&quot; alt=&quot;集合框架基本接口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;出发的公用接口如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_Collection/Map基本接口.png&quot; alt=&quot;集合框架基本接口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然, 上述列举出来的子接口都是直接继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;, 对于其子接口的子接口, 这里并没有列出在这里(比如&lt;code class=&quot;highlighter-rouge&quot;&gt;NavigableMap&lt;/code&gt;接口是&lt;code class=&quot;highlighter-rouge&quot;&gt;SortedMap&lt;/code&gt;接口的子接口, 而不是直接继承&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;的, 所以这里并没有直接列出来)&lt;/p&gt;

&lt;h4 id=&quot;21-2-实现&quot;&gt;2.1-2 实现&lt;/h4&gt;

&lt;p&gt;实现指的是接口的实现类, 这里笔者在官网找到一张表, 如下, 很好的列出了平时重点所用的实现类&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Interface&lt;/th&gt;
      &lt;th&gt;Hash Table&lt;/th&gt;
      &lt;th&gt;Resizable Array&lt;/th&gt;
      &lt;th&gt;Balanced Tree&lt;/th&gt;
      &lt;th&gt;Linked List&lt;/th&gt;
      &lt;th&gt;Hash Table + Linked List&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Set&lt;/td&gt;
      &lt;td&gt;HashSet&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;TreeSet&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;LinkedHashSet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;List&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;ArrayList&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;LinkedList&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Deque&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;ArrayDeque&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;LinkedList&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Map&lt;/td&gt;
      &lt;td&gt;HashMap&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;TreeMap&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;LinkedHashMap&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然, 还应该包含Java 2以前几个旧API, 即: &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Hashtable&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;21-3-算法&quot;&gt;2.1-3 算法&lt;/h4&gt;

&lt;h5 id=&quot;1-算法&quot;&gt;(1). 算法&lt;/h5&gt;

&lt;p&gt;算法指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt;为主的提供的一系列对集合的操作, 参见下图, 列出了其提供的常用算法&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_Collection/Collections方法.png&quot; alt=&quot;集合框架基本接口&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面对上述方法进行一些简单解释&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort(List)&lt;/code&gt;: 使用归并排序, 保证&lt;code class=&quot;highlighter-rouge&quot;&gt;NlogN&lt;/code&gt;的时间复杂度和稳定性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;binarySearch(List, Object)&lt;/code&gt;: 在一个有序的&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;中使用二分查找&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reverse(List)&lt;/code&gt;: 逆转&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shuffle(List)&lt;/code&gt;: 将&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;中的元素随机重排&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fill(List, Object)&lt;/code&gt;: 使用指定值(&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;)覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;中所有元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;copy(List dest, List src)&lt;/code&gt;: 拷贝&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;min(Collection)&lt;/code&gt;: 返回最小值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;max(Collection)&lt;/code&gt;: 返回最大值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rotate(List list, int distance)&lt;/code&gt;: 将&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;中元素旋转指定&lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;replaceAll(List list, Object oldVal, Object newVal)&lt;/code&gt;: 将&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;中出现的所有&lt;code class=&quot;highlighter-rouge&quot;&gt;oldVal&lt;/code&gt;替换为&lt;code class=&quot;highlighter-rouge&quot;&gt;newVal&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;indexOfSubList(List source, List target)&lt;/code&gt;: 返回&lt;code class=&quot;highlighter-rouge&quot;&gt;source&lt;/code&gt;中与&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;匹配的第一个子项的首元素索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lastIndexOfSubList(List source, List target)&lt;/code&gt;: 返回最后一个匹配子项的首元素索引&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swap(List, int, int)&lt;/code&gt;: 交换指定位置的两个元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;frequency(Collection, Object)&lt;/code&gt;: 找出指定元素出现次数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;disjoint(Collection, Collection)&lt;/code&gt;: 判断两个集合是否包含相同元素(即集合是否相交)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addAll(Collection&amp;lt;? super T&amp;gt;, T...)&lt;/code&gt;: 将指定元素添加到指定集合中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;2-包装类&quot;&gt;(2). 包装类&lt;/h5&gt;

&lt;p&gt;当然, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt;提供的不仅仅是针对集合的算法, 其还提供了一系列对集合的包装类(即&lt;code class=&quot;highlighter-rouge&quot;&gt;Wrapper&lt;/code&gt;), 主要包括以下三大类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.unmodifiableInterface()&lt;/code&gt;: 返回一个不可修改的集合, 包括&lt;code class=&quot;highlighter-rouge&quot;&gt;UnmodifiableCollection&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UnmodifiableSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UnmodifiableList&lt;/code&gt;; 实现原理是在修改集合的操作上(如&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;等)抛出异常&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedInterface()&lt;/code&gt;: 返回一个线程安全的集合, 包括&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronizedCollection&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronizedSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronizedList&lt;/code&gt;; 实现原理是在需要同步的方法上添加&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;限制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.checkedInterface()&lt;/code&gt;: 返回一个类型检查的集合, 包括&lt;code class=&quot;highlighter-rouge&quot;&gt;CheckedCollection&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CheckedQueue&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CheckedSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;CheckedList&lt;/code&gt;; 实现原理是在&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;的时候进行类型检查, 如果是非法类型, 就抛出异常&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassCastException&lt;/code&gt;; 这里的类型检查实际上是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Class.isInstance()&lt;/code&gt;来检查的, 关于该方法和&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;运算符的区别, &lt;a href=&quot;https://blog.csdn.net/chao821/article/details/79739447&quot;&gt;参见博客&lt;/a&gt;; (大致上, 二者是等价的, 只是&lt;code class=&quot;highlighter-rouge&quot;&gt;isInstance()&lt;/code&gt;是在运行时才进行类型检查, 故可用于反射, 泛型;
但是&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;需要在编译时知道类的具体类型(重点理解在动态等价))&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些包装类的作用主要是满足平时一些特殊的需求, 比如同步, 不可修改等&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-基本接口&quot;&gt;三. 基本接口&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;在这一节, 主要讲解上面提到的几个基本接口, 这里不会涉及到其实现类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;31-collection&quot;&gt;3.1 Collection&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;是集合框架中一个最顶层的基本接口, 提供了一个数据集的基本描述, 在官方API中并没有提供其直接实现类, 而是在其基础上提供了进一步的限制接口, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;; 这样做的好处有:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;代码复用: 从面向对象的角度讲, 抽取出一个顶级接口, 有助于用户代码复用, 即编写一个接口, 实现不同传参(&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;的各种实现类), 实际上也是利用了多态(官方文档的解释是: 实现最大通用性)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;易于扩展: 符合面向对象的思想, 即将数据集抽象, 通过不同的需求对其实现不同方便的限制, 易于扩展; 同时减少新API学习成本&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;提供了数据操作的基本方法, 如&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;size()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;clear()&lt;/code&gt;等; 同时, 其还继承了&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;接口, 这个接口是用于使用迭代器遍历集合用的, 使用迭代器遍历集合的优点是我们不必知道集合的内部结果,集合的内部结构、状态由&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;来维持,   通过统一的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;来判断和获取下一个元素&lt;/p&gt;

&lt;h3 id=&quot;32-list&quot;&gt;3.2 List&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;上做的限制是, 元素有序(但并不是排序), 允许重复元素; 同时还将迭代器换成了&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;; 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;, 其允许双向的迭代, 以及元素插入(&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator.add()&lt;/code&gt;), 删除(&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator.remove()&lt;/code&gt;)和替换&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator.set()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK9&lt;/code&gt;中, 还提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;List.of()&lt;/code&gt;的静态方法, 用于返回一个不可变&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Immutable List&lt;/code&gt;)&lt;/p&gt;

&lt;h3 id=&quot;33-set&quot;&gt;3.3 Set&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;上做的限制是, 元素不重复, 至多一个null元素&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK9&lt;/code&gt;中, 还提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Set.of()&lt;/code&gt;的静态方法, 用于返回一个不可变的&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;34-queue&quot;&gt;3.4 Queue&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;上做的限制是, 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;提供的基本操作外, 还提供了一些额外的操作, 分为两类, 一个返回特定值, 另一个抛出异常, 见下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Throw Exception&lt;/th&gt;
      &lt;th&gt;Return Special Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Insert&lt;/td&gt;
      &lt;td&gt;add(e)&lt;/td&gt;
      &lt;td&gt;offer(e)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Remove&lt;/td&gt;
      &lt;td&gt;remove()&lt;/td&gt;
      &lt;td&gt;poll()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Examine&lt;/td&gt;
      &lt;td&gt;element()&lt;/td&gt;
      &lt;td&gt;peek()&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;35-map&quot;&gt;3.5 Map&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;本质上是一组键值对, &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;允许单独访问&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;keySet()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;), 也可以单独访问&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;values()&lt;/code&gt;方法返回&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Collection&lt;/code&gt;), 也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;entrySet()&lt;/code&gt;获取&lt;code class=&quot;highlighter-rouge&quot;&gt;key-value&lt;/code&gt;的对应关系&lt;/p&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/package-summary.html#CollectionsFramework&quot;&gt;官方文档–集合框架指南&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-reference.html&quot;&gt;集合框架的分类&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-designfaq.html&quot;&gt;集合框架设计理念答疑文档&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 26 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>MarkDown中使用数学公式</title>
        <description>&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;如何在MarkDown中使用数学公式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在MarkDown文章中插入下面代码(MathJax引擎)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;之后就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Latex&lt;/code&gt;语法来书写数学公式了; 需要注意的是, 每个数学公式都应该以&lt;code class=&quot;highlighter-rouge&quot;&gt;$$&lt;/code&gt;开头和结尾, 如下&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$$
a^{n}=\begin{equation}
\left\{
             \begin{array}{**lr**}
             a^{n/2}*a^{n/2}, &amp;amp; n为偶数 \\
             a^{(n-1)/2}*a^{(n-1)/2} &amp;amp; n为奇数 \\
             \end{array}
\right.
\end{equation}
$$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;显示结果为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
a^{n}=\begin{equation}
\left\{
             \begin{array}{**lr**}
             a^{n/2}*a^{n/2}, &amp; n为偶数 \\
             a^{(n-1)/2}*a^{(n-1)/2} &amp; n为奇数 \\
             \end{array}
\right.
\end{equation} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;参考链接&quot;&gt;参考链接&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xiahouzuoxin/article/details/26478179&quot;&gt;参考博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 25 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/25/MarkDown%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/25/MarkDown%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</guid>
        
        <category>MarkDown</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架</title>
        <description>&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/package-summary.html#CollectionsFramework&quot;&gt;官方文档–集合框架指南&lt;/a&gt;
&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-reference.html&quot;&gt;集合框架的分类&lt;/a&gt;
&lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-designfaq.html&quot;&gt;集合框架设计理念答疑文档&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;理解: &lt;code class=&quot;highlighter-rouge&quot;&gt;Collections that are not immutable are mutable&lt;/code&gt;: &lt;a href=&quot;https://stackoverflow.com/questions/8892350/immutable-vs-unmodifiable-collection&quot;&gt;参见StackOverFloaw回答&lt;/a&gt;
理解: &lt;a href=&quot;https://docs.oracle.com/javase/9/docs/api/java/util/doc-files/coll-overview.html&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Collections that do not support modification operations (such as add, remove and clear) are referred to as unmodifiable. Collections that are not unmodifiable are modifiable.
Collections that additionally guarantee that no change in the Collection object will be visible are referred to as immutable. Collections that are not immutable are mutable.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以结合&lt;code class=&quot;highlighter-rouge&quot;&gt;emptySet, emptyList and emptyMap - Return an immutable empty set, list, or map.&lt;/code&gt;来理解&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;RandomAccess: 标识能够在常量时间内定位元素(叫random access lists)&lt;/p&gt;

&lt;p&gt;Iterator: Iterable, ListIterator, Iterable
能够双向遍历线性表的新列表迭代器ListIterator
可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序, 此处应该和Collections的算法相联系&lt;/p&gt;

&lt;p&gt;AbstractCollection是提供Collection部分实现的抽象类; 集合框架中的Abstract的部分是集合接口的部分实现, 作用是有助于提供自定义实现(这些有: AbstractCollection, AbstractSet, AbstractList, AbstractSequentialList and AbstractMap)&lt;/p&gt;

&lt;p&gt;接口Deque，是一个扩展自Queue的双端队列
PriorityQueue类实现了一个优先队列&lt;/p&gt;

&lt;p&gt;在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;并发(Concurrent Collections): &lt;a href=&quot;&quot;&gt;参见文档&lt;/a&gt;https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/package-summary.html&lt;/p&gt;

&lt;p&gt;包括的接口: 
BlockingQueue
TransferQueue
BlockingDeque
ConcurrentMap
ConcurrentNavigableMap&lt;/p&gt;

&lt;p&gt;实现类
LinkedBlockingQueue
ArrayBlockingQueue
PriorityBlockingQueue
DelayQueue
SynchronousQueue
LinkedBlockingDeque
LinkedTransferQueue
CopyOnWriteArrayList
CopyOnWriteArraySet
ConcurrentSkipListSet
ConcurrentHashMap
ConcurrentSkipListMap&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Arrays&lt;/p&gt;
</description>
        <pubDate>Sat, 25 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/25/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/25/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
        
        
      </item>
    
      <item>
        <title>高质量代码</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;本文不会详细去讲解代码规范等东西, 只是浅谈对高质量代码的一些细节理解和注意事项总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;«剑指Offer»第三章要点总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h2 id=&quot;一-什么叫高质量代码&quot;&gt;一. 什么叫高质量代码&lt;/h2&gt;

&lt;h3 id=&quot;11-规范性&quot;&gt;1.1 规范性&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;从三个方面考虑: 书写, 布局, 命名&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;11-1-清晰的书写&quot;&gt;1.1-1 清晰的书写&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;能够辨识, 一般而言, 面试代码都比较短, 所以一般时间充足&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;11-2-清晰的布局&quot;&gt;1.1-2 清晰的布局&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;代码缩进, 空格等, 了解一下手打格式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;11-3-合理的命名&quot;&gt;1.1-3 合理的命名&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;命名需要有意义, 不要嫌函数名太长, 最好做到一眼能够猜出大致用途&lt;/li&gt;
  &lt;li&gt;比如命名: &lt;code class=&quot;highlighter-rouge&quot;&gt;BinaryTreeNode&lt;/code&gt;而不要用&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;, 相比较之下, 前者更明确&lt;/li&gt;
  &lt;li&gt;用完整的英文单词组合命名, 除了公认的缩写&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-完整性&quot;&gt;1.2 完整性&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;也从三个方面考虑: 基本功能, 边界值, 错误处理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;12-1-基本功能&quot;&gt;1.2-1 基本功能&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基本功能是首要考虑的, 基本功能出错是硬伤, hh&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-2-边界值&quot;&gt;1.2-2 边界值&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;边界值一般是较为看重的细节地方, 有一句话叫面向测试编程, 虽然不推荐, 但是在动手之前, 想好测试用例, 有助于书写出更鲁棒性的代码&lt;/li&gt;
  &lt;li&gt;比如: int等类型的范围限制, 输入数据的正负, 0等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;12-3-错误处理&quot;&gt;1.2-3 错误处理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主要指输入错误, 错误的处理方式有三种, 其优缺点参见下表&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;优点&lt;/th&gt;
      &lt;th&gt;缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;返回值&lt;/td&gt;
      &lt;td&gt;和系统API一致&lt;/td&gt;
      &lt;td&gt;不能方便的使用计算结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;全局变量&lt;/td&gt;
      &lt;td&gt;能够方便的使用计算结果&lt;/td&gt;
      &lt;td&gt;用户可能会忘记检查全局变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;异常&lt;/td&gt;
      &lt;td&gt;可以为不同的出错原因定义不同的异常类型, 逻辑清晰明了&lt;/td&gt;
      &lt;td&gt;有些语言不支持异常, 跑出异常对性能有负面影响&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;三种错误处理方式详解
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;返回值: 即通过函数返回值来识别是否出错和出错类型, 如: Win32 API&lt;/li&gt;
        &lt;li&gt;全局变量: 即设置一个全局变量, 用于标识是否出错, 函数正常返回计算结果&lt;/li&gt;
        &lt;li&gt;异常: try…catch…, 但是有些语言不支持&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 24 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/24/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/24/%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
  </channel>
</rss>
