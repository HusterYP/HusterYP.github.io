<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 02 Oct 2018 22:26:43 +0800</pubDate>
    <lastBuildDate>Tue, 02 Oct 2018 22:26:43 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Java类文件结构与类加载机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第六章第七章以及其他博客的总结, 权做笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-类文件结构&quot;&gt;一. 类文件结构&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件是一组以&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节为基础单位的二进制流, 当遇到需要占据&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节以上空间的数据项时, 则会按照高位在前的方式分割成若干个&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;位字节进行存储&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式采用一种类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言结构体的伪结构来存储数据, 这种伪结构中只有两种数据类型: 无符号数和表; 无符号数是基本数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;u1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u4&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;u8&lt;/code&gt;来分别代表&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;个字节,&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;个字节, &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节和&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节的无符号数, 无符号数可以用来描述数字, 索引引用, 数量值或者按照&lt;code class=&quot;highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt;编码构成字符串值; 表由多个无符号数或者其他表作为数据项构成的复合数据类型, 以&lt;code class=&quot;highlighter-rouge&quot;&gt;_info&lt;/code&gt;结尾&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中没有分隔符, 所以哪个字节代表什么含义, 长度是多少, 先后顺序如何, 都被严格限定且不允许改变&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件格式见下表&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;数量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;u4&lt;/td&gt;
      &lt;td&gt;magic&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;minor_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;major_version&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;constant_pool_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cp_info&lt;/td&gt;
      &lt;td&gt;constant_pool&lt;/td&gt;
      &lt;td&gt;constant_pool_count-1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;access_flags&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;this_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;super_class&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;interfaces&lt;/td&gt;
      &lt;td&gt;interfaces_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;field_info&lt;/td&gt;
      &lt;td&gt;fields&lt;/td&gt;
      &lt;td&gt;fields_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;method_info&lt;/td&gt;
      &lt;td&gt;methods&lt;/td&gt;
      &lt;td&gt;methods_count&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;u2&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attribute_info&lt;/td&gt;
      &lt;td&gt;attributes&lt;/td&gt;
      &lt;td&gt;attributes_count&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;11-简介&quot;&gt;1.1 简介&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;魔数&lt;/strong&gt;: 每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件头&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节称为魔数, 唯一作用是确定该文件是否是一个能被虚拟机接受的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;版本号&lt;/strong&gt;: 紧接着魔数的四个字节存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件的版本号: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;个字节是次版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor Version&lt;/code&gt;), 第&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;和第&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;个字节是主版本号(&lt;code class=&quot;highlighter-rouge&quot;&gt;Major Version&lt;/code&gt;); 虚拟机必须拒绝执行超过其版本号的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;常量池&lt;/strong&gt;: 紧接着主版本号之后的是常量池入口, 是一个表类型数据项; &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中只有常量池的容量计数是从&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;开始的; 常量池中主要存放两大类常量: 字面量和符号引用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;字面量: 如: 文本字符串, 声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的常量值等&lt;/li&gt;
    &lt;li&gt;符号引用: 类和接口的全限定名; 字段的名称和描述符; 方法的名称和描述符&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;访问标志&lt;/strong&gt;: 常量池结束之后, 紧接着的两个字节代表访问标志; 用于表示一些类或者接口的层次信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;类索引, 父类索引和接口索引集合&lt;/strong&gt;: 用于确定类的继承关系; 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;之外, 所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类都有父类, 因此除了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;外, 所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的父类索引都不为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;字段表&lt;/strong&gt;: 描述接口或者类中声明的变量; 字段包括类级变量以及实例级变量, 但不包括方法内部声明的局部变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;方法表&lt;/strong&gt;: 包括访问标志, 名称索引, 描述符索引, 属性表集合; 如果父类方法在子类中没有被重写, 方法表集合中就不会出现来自父类的方法信息, 但是, 同样的, 有可能会出现由编译器自动添加的方法, 最典型的便是类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;方法和实例构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;属性表&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机运行时会忽略掉它不认识的属性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-常见问题&quot;&gt;1.2 常见问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中方法, 字段等都需要引用&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量来描述名称, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;CONSTANT_Utf8_info&lt;/code&gt;型常量的最大长度也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中方法, 字段名的最大长度; &lt;code class=&quot;highlighter-rouge&quot;&gt;u2&lt;/code&gt;类型能表达的最大值是&lt;code class=&quot;highlighter-rouge&quot;&gt;65535&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序中如果定义了超过&lt;code class=&quot;highlighter-rouge&quot;&gt;64KB&lt;/code&gt;英文字符的变量或方法名, 将无法编译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-虚拟机类加载机制&quot;&gt;二. 虚拟机类加载机制&lt;/h2&gt;

&lt;h3 id=&quot;21-类加载的时机&quot;&gt;2.1 类加载的时机&lt;/h3&gt;

&lt;p&gt;类从被加载到虚拟机内存中开始, 到卸载出内存为止, 其生命周期如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/类的生命周期.png&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中, 加载, 验证, 准备, 初始化和卸载这五个阶段的顺序是确定的, 解析阶段则不一定: 在某些情况下, 可以在初始化阶段之后再&lt;strong&gt;开始&lt;/strong&gt;(注意, 是开始, 而不是&lt;em&gt;进行&lt;/em&gt;或者&lt;em&gt;完成&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;遇到以下五种情况必须立即对类进行&lt;em&gt;初始化&lt;/em&gt;(而加载, 验证, 准备自然要在这之前完成):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;getstatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;putstatic&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;invokestatic&lt;/code&gt;这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条字节码指令时, 如果类没有初始化, 需要出发初始化; 生成这&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;条指令的常见&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;代码场景是: 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;关键字实例化对象的时候, 读取或设置一个类的静态字段的时候(注意: 被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰, 已在编译期把结果放入常量池的静态字段除外(由此可见, 添加&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰可以避免不必要的类加载)), 以及调用一个类的静态方法的时候&lt;/li&gt;
    &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;包的方法对类进行反射调用的时候&lt;/li&gt;
    &lt;li&gt;当初始化一个类, 如果发现其父类没有初始化, 则需先初始化其父类&lt;/li&gt;
    &lt;li&gt;虚拟机启动时, 用户需要指定一个要执行的主类(&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;所在的类), 虚拟机会先初始化这个主类&lt;/li&gt;
    &lt;li&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.7&lt;/code&gt;的动态语言支持(比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Groovy&lt;/code&gt;等)时, 如果一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例最后的解析结果&lt;code class=&quot;highlighter-rouge&quot;&gt;REF_getStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_putStatic&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;REF_invokeStatic&lt;/code&gt;的方法句柄, 并且这个方法句柄所对应的类没有进行过初始化, 则需先触发其初始化&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;22-主动引用与被动引用&quot;&gt;2.2 主动引用与被动引用&lt;/h3&gt;

&lt;h4 id=&quot;221-构造函数-代码块-静态代码块的执行时机&quot;&gt;2.2.1 构造函数, 代码块, 静态代码块的执行时机&lt;/h4&gt;

&lt;p&gt;考虑下列代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Practice {

    static {
        System.out.println(&quot;Practice static code block&quot;);
    }

    {
        System.out.println(&quot;Practice code block&quot;);
    }

    public Practice() {
        System.out.println(&quot;Practice constructor&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;new&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Practice&lt;/code&gt;对象时, 输出如下; 说明三者的执行顺序是: 静态代码块 –&amp;gt; 代码块 –&amp;gt; 构造函数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Practice static code block
Practice code block
Practice constructor
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于三者的执行时机与作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;静态代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;用于给类初始化, 随着类的加载而执行, 只执行一次&lt;/li&gt;
    &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前执行&lt;/li&gt;
    &lt;li&gt;一个类可以有多个静态代码块&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;代码块&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;实例对象相关, 给所有对象进行统一初始化(因为构造函数可以重载)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;初始化实例&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;222-被动引用示例&quot;&gt;2.2.2 被动引用示例&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;前面所说的触发初始化的五个场景对应叫做主动引用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;通过子类引用父类的静态字段, 不会导致子类初始化: 对于静态字段, 只有直接定义这个字段的类才会被初始化&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);  // 不会初始化子类~
    }
}

class SuperClass {
    static {
        System.out.println(&quot;SuperClass init&quot;);
    }

    public static int value = 123;
}

class SubClass extends SuperClass{
    static {
        System.out.println(&quot;Child init&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 后文为节省篇幅, 将重用这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;SuperClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SubClass&lt;/code&gt;, 而不再重写~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通过数组定义来引用类, 不会触发此类的初始化: 虚拟机会为数组自动生成一个直接继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;的子类; &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中对数组的访问比&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;更安全, 是因为这个类封装了数组元素的访问方法, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;直接翻译为数组指针的移动&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[0];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;常量在编译阶段会存入被调用类的常量池中, 本质上并没有直接引用到常量的类, 因此不会出发定义常量的类的初始化: 在编译阶段经过常量传播优化, 已经将次&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World&lt;/code&gt;常量存储到了&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类的常量池中了, 以后&lt;code class=&quot;highlighter-rouge&quot;&gt;Initialization&lt;/code&gt;对常量&lt;code class=&quot;highlighter-rouge&quot;&gt;ConstClass.HELLOWORLD&lt;/code&gt;的引用都被转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;NotInitialization&lt;/code&gt;类对自身常量池的引用了~&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(ConstClass.CONST);
    }
}

class ConstClass {
    static {
        System.out.println(&quot;ConstClass init&quot;);
    }

    public static final String HELLOWORLD=&quot;Hello World&quot;; // 注意这里不能从static来理解, 因为即使有static, 但是没有final的话仍然会触发ConstClass的初始化~
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23-类的加载过程&quot;&gt;2.3 类的加载过程&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;结合前面的图咯~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-加载&quot;&gt;2.3.1 加载&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过一个类的全限定名来获取定义此类的二进制字节流&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内存中生成一个代表这个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象(该&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象并没有明确规定是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;HotSpot&lt;/code&gt;虚拟机而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象比较特殊, 它虽然是对象, 但是存在于方法区中), 作为方法区这个类的各种数据的访问入口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;232--验证&quot;&gt;2.3.2  验证&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;文件格式验证:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否以魔数&lt;code class=&quot;highlighter-rouge&quot;&gt;0xCAFEBABE&lt;/code&gt;开头&lt;/li&gt;
    &lt;li&gt;主, 次版本号是否在当前虚拟机处理范围之内&lt;/li&gt;
    &lt;li&gt;常量池的常量中是否有不被支持的类型
….&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;元数据验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;是否有父类&lt;/li&gt;
    &lt;li&gt;是否继承了不允许被继承的父类(被&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的父类)&lt;/li&gt;
    &lt;li&gt;如果这个类不是抽象类, 是否实现其父类或接口中要求实现的所有方法&lt;/li&gt;
    &lt;li&gt;是否非法覆盖(&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;方法), 重载是否正确
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;字节码验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;对类的方法体进行校验分析, 保证被校验的类在运行时不会危害虚拟机&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;符号引用验证&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;符号引用中通过字符串描述的全限定名是否能找到对应的父类&lt;/li&gt;
    &lt;li&gt;符号引用中的类, 字段, 方法的访问性是否可以被当前类访问&lt;/li&gt;
    &lt;li&gt;指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
…&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;233-准备&quot;&gt;2.3.3 准备&lt;/h4&gt;

&lt;p&gt;正式为类变量分配内存并为其设置初始值&lt;/p&gt;

&lt;h4 id=&quot;234-解析&quot;&gt;2.3.4 解析&lt;/h4&gt;

&lt;p&gt;将常量池中的符号引用替换为直接引用&lt;/p&gt;

&lt;h4 id=&quot;235-初始化&quot;&gt;2.3.5 初始化&lt;/h4&gt;

&lt;p&gt;真正开始执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序代码(字节码)或者说初始化阶段是执行类构造器&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程&lt;/p&gt;

&lt;h5 id=&quot;235-1-类构造器方法&quot;&gt;2.3.5-1 类构造器&lt;clinit&gt;()方法&lt;/clinit&gt;&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;代码块)中的语句合并产生的; 静态语句块只能访问到定义在静态语句块之前的变量, 定义在它之后的变量, 在前面的静态语句块可以赋值, 但是不能访问, 如下代码&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Temp {
    static {
        value = 2;
//        System.out.println(value); // 不能访问
    }

    static int value = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法与构造函数(&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;)不同, 虚拟机会保证子类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法执行之前, 父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法已经执行完毕; 因此在虚拟机中第一个被执行的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的类肯定是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;由于父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法先于子类的执行, 也就意味着父类中的静态语句块要先于子类的变量赋值操作; 注意如下代码;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SuperClass {
    public static int A = 1;
    static {
        A = 2;
    }
}

class SubClass extends SuperClass{
    public static int B = A; // 注意这里的B应该为2, 而不是1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法对于类或接口来说不是必需的, 如果一个类没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接口中不能有静态语句块, 但是可以有变量的初始化赋值操作, 因此接口与类一样也会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法; 但接口与类不同的是, 执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法不需要先执行父接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法, 只有当父接口中定义的变量使用时, 父接口才会初始化; 另外, 接口的实现类在初始化时也一样不会执行接口的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机会保证一个类的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法在多线程环境中被正确的加锁, 同步; 只能有一个线程去执行&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-类加载器&quot;&gt;2.4 类加载器&lt;/h3&gt;

&lt;p&gt;任意一个类, 都是由加载它的类加载器和这个类本身一同确立其在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中的唯一性; 更通俗一些是: 比较两个类是否&lt;em&gt;相等&lt;/em&gt;, 只有在这两个类是由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来自同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件, 被同一个虚拟机加载, 只要加载它们的类加载器不同, 那这两个类就必定不相等(这里所谓的相等, 包括代表&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isAssignableFrom()&lt;/code&gt;方法, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInstance()&lt;/code&gt;方法的返回结果, 以及使用&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt;关键字做对象所属关系判断等情况); 如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.IOException;
import java.io.InputStream;

public class ClassLoaderTest {
    public static void main(String[] args) throws Exception {
        ClassLoader loader = new ClassLoader() {
            @Override
            public Class&amp;lt;?&amp;gt; loadClass(String name) throws ClassNotFoundException {
                try {
                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;;
                    InputStream inputStream = getClass().getResourceAsStream(fileName);
                    if (inputStream == null) {
                        return super.loadClass(name);
                    }
                    byte[] bytes = new byte[inputStream.available()];
                    inputStream.read(bytes);
                    return defineClass(name, bytes, 0, bytes.length);
                } catch (IOException e) {
                }
                return null;
            }
        };

        Object obj = loader.loadClass(&quot;Practice&quot;).newInstance();
        System.out.println(obj.getClass());
        System.out.println(obj instanceof Practice); // 及时是Practice实例, 但是这里仍然返回false
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-双亲委派模型&quot;&gt;2.5 双亲委派模型&lt;/h3&gt;

&lt;h4 id=&quot;251-类加载器分类&quot;&gt;2.5.1 类加载器分类&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Bootstrap ClassLoader&lt;/code&gt;): &lt;code class=&quot;highlighter-rouge&quot;&gt;C++&lt;/code&gt;实现, 虚拟机自身一部分&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;扩展类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Extension ClassLoader&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用程序类加载器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application ClassLoader&lt;/code&gt;): 如果没有定义自己的类加载器, 则为程序中默认的类加载器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;252-双亲委派模型含义&quot;&gt;2.5.2 双亲委派模型含义&lt;/h4&gt;

&lt;p&gt;如下图; 双亲委派模型要求除了顶层的启动类加载器外, 其余的类加载器都应当有自己的父类加载器;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/双亲委派模型.png&quot; alt=&quot;双亲委派模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果一个类加载器收到了类加载的请求, 它首先不会自己去尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此; 因此所有的加载请求最终都应该传送到顶层的启动类加载器中, 只有当父类加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时, 子加载器才会尝试自己去加载&lt;/p&gt;

</description>
        <pubDate>Tue, 02 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/02/Java%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/02/Java%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java垃圾收集器与内存分配策略</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文为«深入理解Java虚拟机»第三章以及部分博客内容总结, 权作个人笔记~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自: http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-对象是否死亡&quot;&gt;一. 对象是否死亡&lt;/h2&gt;

&lt;p&gt;进行垃圾收集首先需要的就是判断对象是否死亡, 也就是是否可以清除收集, 下面将讲解判断对象是否死亡的方法&lt;/p&gt;

&lt;h3 id=&quot;11-引用计数算法&quot;&gt;1.1 引用计数算法&lt;/h3&gt;

&lt;h4 id=&quot;111-原理&quot;&gt;1.1.1 原理&lt;/h4&gt;

&lt;p&gt;给对象添加一个引用计数, 每当有一个地方引用它, 计数器值就加&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 当引用失效时, 计数器值就减&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 任何时刻计数器值为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的对象就是不可能再被使用的&lt;/p&gt;

&lt;h4 id=&quot;112-优缺点&quot;&gt;1.1.2 优缺点&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;: 实现简单, 效率高&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;: 无法解决循环引用的问题, 如下;&lt;/p&gt;

&lt;p&gt;主流&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有使用引用计数来管理内存的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ReferenceCountingGC {

    public Object instance = null;
    private final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB]; // 占用内存, 以便GC日志中看清楚是否被回收过

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-可达性分析算法&quot;&gt;1.2 可达性分析算法&lt;/h3&gt;

&lt;h4 id=&quot;121-原理&quot;&gt;1.2.1 原理&lt;/h4&gt;

&lt;p&gt;通过一系列成为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象作为起始点, 从这些节点开始往下搜索, 搜索走过的路径称为引用链, 当一个对象到&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;没有任何引用链相连时, 则证明此对象是不可引用的; 如下图(&lt;a href=&quot;https://llag9810.github.io/2017/12/04/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;图片来自&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/GcRoot.png&quot; alt=&quot;GC Root&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可作为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中类静态属性引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中常量引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地方法栈中&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法)引用的变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用可达性分析算法时, 至少需要经过两次标记过程才能宣告一个对象真正死亡: 如果对象在进行可达性分析后发现没有与&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;相连接的引用链, 那它会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 当对象没有覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法时, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法已经被虚拟机调用过, 虚拟机将这两种情况都视为没有必要执行(也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法最多执行一次, 这点需要注意~);
如果这个对象被判定为有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 那么这个对象将会放置在一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;F-Queue&lt;/code&gt;的队列中, 并在稍后由一个由虚拟机自动建立, 低优先级的&lt;code class=&quot;highlighter-rouge&quot;&gt;Finalizer&lt;/code&gt;线程去执行它, 但并不承诺会等待&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法运行结束(这里也需要注意, 这是为了防止&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中出现耗时操作甚至死循环); 在&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中对象可以使自己再次加入引用链中, 逃脱&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; &lt;strong&gt;但是不建议使用该方法来逃脱GC&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FinalizeEscapeGC {
    public static FinalizeEscapeGC finalizeEscapeGC = null;

    int count = 0;

    public void isAlive() {
        System.out.println(&quot;Yes, I am alive :) &quot;);
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed&quot;);
        FinalizeEscapeGC.finalizeEscapeGC = this; // 再次进入引用链
        // 经过验证, 虚拟机不会等待finalize()执行完毕
//        while (true) {
//            System.out.println(count++);
//        }
    }

    public static void main(String[] args) throws InterruptedException {
        finalizeEscapeGC = new FinalizeEscapeGC();
        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }

        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述程序运行结果为: 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;确实被调用了, 而且只被调用了一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;finalize method executed
Yes, I am alive :)
No, I am dead :(
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-再谈引用&quot;&gt;1.3 再谈引用&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;以前, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;引用很传统: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;类型的数据中存储的数值代表的是另一块内存的起始地址, 就称这块内存代表着一个引用&lt;/p&gt;

&lt;p&gt;但是实际我们希望的是: 当内存空间还足够时, 能够保留在内存中; 当内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃某些对象&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;之后, 扩充了引用概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 以下引用强度递减&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;强引用: 类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Object obj = new Object()&lt;/code&gt;的引用; 这类引用永远不会被垃圾收集器回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软引用: 有用但非必需的对象; 在系统将要发生内存溢出之前, 将回收这部分对象, 如果回收之后内存仍然不够, 才会内存溢出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;弱引用: 无论当前内存是否足够都会回收掉只被弱引用关联的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚引用: 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过一个虚引用来取得对象实例; 为一个对象设置虚引用关联的唯一目的是能在这个对象被收集器回收之前收到一个系统通知&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;14-方法区回收&quot;&gt;1.4 方法区回收&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;的主要区域是堆, 但是方法区也会进行&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; 方法区的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;主要是废弃常量和无用的类&lt;/p&gt;

&lt;p&gt;废弃常量好理解, 和堆中对象回收一样, 没有引用即回收&lt;/p&gt;

&lt;p&gt;无用类需要满足条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;该类的所有实例都已经被回收, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中不存在该类的任何实例&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载该类的&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;已经被回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;该类对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-垃圾收集算法&quot;&gt;二. 垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&quot;21-标记-清除算法mark-sweep&quot;&gt;2.1 标记-清除算法(Mark-Sweep)&lt;/h3&gt;

&lt;h4 id=&quot;211-原理&quot;&gt;2.1.1 原理&lt;/h4&gt;

&lt;p&gt;先标记, 后回收咯&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记清除算法.png&quot; alt=&quot;标记清除算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;212-优缺点&quot;&gt;2.1.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标记和清除的效率都不高&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;产生大量不连续的内存碎片&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-复制算法&quot;&gt;2.2 复制算法&lt;/h3&gt;

&lt;p&gt;多用于新生代&lt;/p&gt;

&lt;h4 id=&quot;221-原理&quot;&gt;2.2.1 原理&lt;/h4&gt;

&lt;p&gt;将内存分成相等的两块, 每次只使用其中一块, 当这一块用完了, 就将还存活的对象复制到另一块, 然后把使用过的内存空间一次清掉&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/复制算法.png&quot; alt=&quot;复制算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;222-优缺点&quot;&gt;2.2.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;效率高, 无碎片&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每次可使用内存减半&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;23-标记-整理算法&quot;&gt;2.3 标记-整理算法&lt;/h3&gt;

&lt;p&gt;多用于老年代&lt;/p&gt;

&lt;h4 id=&quot;231-原理&quot;&gt;2.3.1 原理&lt;/h4&gt;

&lt;p&gt;让所有存活对象都向一端移动, 然后清理掉端边界以外的内存&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记整理算法.png&quot; alt=&quot;标记整理算法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-分代收集算法&quot;&gt;2.4 分代收集算法&lt;/h3&gt;

&lt;h4 id=&quot;241-分代&quot;&gt;2.4.1 分代&lt;/h4&gt;

&lt;p&gt;分代的依据是: 不同对象的生命周期不同; 因此不同对象可以采用不同的回收方式, 以便提高回收效率; 因为如果每次都对整个堆进行回收遍历的话, 对于生命周期较长的对象而言, 实际上有很多次回收都是不必要和没用的&lt;/p&gt;

&lt;p&gt;分代:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/分代.png&quot; alt=&quot;分代&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分为年轻代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Young Generation&lt;/code&gt;), 老年代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Old Generation&lt;/code&gt;)和永久代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Permanent Generation&lt;/code&gt;); 永久代主要存放的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的类信息, 与垃圾收集要收集的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象关系不大; 年轻代和老年代的划分是对垃圾收集影响比较大的&lt;/p&gt;

&lt;h4 id=&quot;242-原理&quot;&gt;2.4.2 原理&lt;/h4&gt;

&lt;p&gt;新生代采用复制算法, 有老年代作空间担保; 老年代中因为对象存活率高, 没有额外空间对它进行分配担保, 就必须使用&lt;strong&gt;标记-清理&lt;/strong&gt;或者&lt;strong&gt;标记-整理&lt;/strong&gt;算法&lt;/p&gt;

&lt;p&gt;关于分代收集算法更详细信息, 可以参见博客: http://hllvm.group.iteye.com/group/wiki/2863-JVM&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-内存分配与回收策略&quot;&gt;三. 内存分配与回收策略&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对象优先在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;分配, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;没有足够空间时, 将发起一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;指发生在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;, 较为频繁, 但是速度也快; &lt;code class=&quot;highlighter-rouge&quot;&gt;Major GC&lt;/code&gt;指的是发生在老年代的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;指的是发生在整个堆空间的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;, 包括老年代和新生代)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大对象直接进入老年代, 这是为了防止在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;和两个&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区之间发生大量的内存复制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;长期存活的对象直接进入老年代; 虚拟机给每个对象定义一个年龄计数器, 如果对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;区出生并经过第一&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;后仍然存活, 并且能被&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区容纳, 将被移到&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中, 并且对象年龄设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中没度过一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;, 年龄就增&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 当其年龄达到一定程度(默认&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;岁), 则移入老年代&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态对象年龄判定, 如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间中相同年龄所有对象大小的总和大于&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 而不必等到年龄达到阈值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间分配担保: 因为新生代采用复制算法, 可能会出现复制空间不足的情况, 老年代可以为新生代作内存空间担保&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四-others&quot;&gt;四. Others&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里提一些其他的要点~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时会发生&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop the World&lt;/code&gt;, 由此可以联想, 也有可能由于&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;造成的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;白屏~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安全点和安全区: 引用关系不变; &lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;只有在程序执行达到安全点或者安全区的时候才能进行; 如何让所有线程都跑到最近的安全点? 有两种方法: 抢先式中断(&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时, 首先把所有线程全部中断, 如果发现有线程不在安全点上, 则恢复该线程, 让它跑到安全点)和主动式中断(&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;时, 不直接对线程中断, 仅仅简单地设置一个标志, 各个线程执行时主动去轮询该标志, 发现该标志为真时就自己中断挂起)(多采用主动式中断)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-参考链接&quot;&gt;五. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View常用工具</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将要讲解的是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中常用的一些工具类&lt;/p&gt;

&lt;p&gt;文中会部分涉及到对源码的讲解, 但是更多的还是倾向于应用~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;在开始讲解之前, 强烈推荐一个系列教程: &lt;a href=&quot;https://hencoder.com/ui-1-1/&quot;&gt;自定义View&lt;/a&gt;; 该教程对绘制过程的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;应用和讲解都很细致, 也有很多例子, 本文将不再重复该教程中已有的内容, 而是额外补充一些&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>自定义View之常用工具</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将要讲解的是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中常用的一些工具类&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-canvas&quot;&gt;一. Canvas&lt;/h2&gt;

&lt;p&gt;drawXXX: 绘制相关&lt;/p&gt;

&lt;p&gt;clipXXX: 裁剪; 使用裁剪的时候, 通常需要配合save()和restore()一起使用, 否则之后所有的绘制都会被裁剪
范围裁切有两个方法： clipRect() 和 clipPath()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;几何变换(平移, 旋转, 伸缩等):&lt;/p&gt;

&lt;p&gt;几何变换的使用大概分为三类：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 Canvas 来做常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Matrix 来做常见和不常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Camera 来做三维变换。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Matrix; 或者自带的translate(), rotate(), scale(), skew()(错切); 
需要注意的是, Canvas自带的几何变换是倒序的, 比如: 如果translate()在rotate()前面, 则实际执行顺序是先rotate(), 再translate(); 
Canvas自带的几何变换内部其实也是使用的Matrix
Matrix可以自定义执行顺序, 通常Matrix的方法都是成对的, 比如: preTranslate()(往前插入)和postTranslate()(往后插入)
Camare可以用于辅助Matrix计算; 比如: 如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onDraw(Canvas canvas) {
    canvas.save();

    camare.save();
    camare.rotateX(30);
    canvas.translate(centerX, centerY); // 注意这里的顺序要倒着, 因为上面说了, Canvas几何变换的顺序是倒着的
    camare.applyToCanvas(canvas); // 同时, 由于camare执行旋转操作的时候, 是以原点为中心的, 所以, 如果这里不配合canvas的平移操作来使用的话, 最终图像是歪的; 但是camare又不支持设置中心, 所以就只能先将图像平移到原点, camare作用完之后再平移回原来的位置; 注意, 虽然Camare也有translate()方法, 但是Camare的变换是会带着整个三维坐标系一起的, 而且它在变换结束之后才会做投影, 而不是一旋转完就立即投影到Canvas上去, 这样如果用Camare做移动,
    那么绘制出来的结果就完全不是预期的样子了(这里的解释不是很懂)
    canvas.translate(-centerX, -centerY);
    camare.restore();

    canvas.restore();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Camare坐标系: 使用的是三维坐标系, 原点也是View左上角; x轴右正左负, y轴上正下负(注意y轴不一样咯, 和View坐标系相反), z轴垂直于View, 内正外负(朝屏幕里面为正, 朝屏幕外面为负); 还包含了一个虚拟的Camare对象, 即一个虚拟的相机, 默认在z轴负向, 即View坐标原点的正上方
Camare的旋转方向没有规律, 见Download文件夹下照片
Camare也是可以沿着x, y, z轴平移的, 比如沿着z轴平移, 就相当于将物体远离或者靠近相机, 即起到放大缩小的作用, 但是由于这种情况也可以直接使用Canvas的scale()等来做到, 所以实际开发中一般都用Canvas自带的方法来实现
Camare还可以通过setLocation()来设置虚拟相机的位置, 这种的使用情况是, 比如进行旋转时会造成物体投影太大(因为相机离物体太近), 此时可以通过setLocation()来设置相机位置远离物体, 使投影缩小; 一般使用时都是沿着z轴移动Camare, 不常见沿着x, y轴移动的
Camare变换的时候也需要save()和restore()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;重写其他方法体现遮盖(联系draw过程, 如: 绘制前景, 绘制背景等)&lt;/p&gt;

&lt;p&gt;drawColor: 可以用于填充背景或者设置半透明蒙版&lt;/p&gt;

&lt;h2 id=&quot;二-paint&quot;&gt;二. Paint&lt;/h2&gt;

&lt;p&gt;关于Paint, 请参见: https://hencoder.com/ui-1-2/&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;颜色: 
setColor()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;setShader(): 着色器, 着色器设置的是一个颜色方案，或者说是一套着色规则; 当设置了 Shader 之后，Paint 在绘制图形和文字时就不使用 setColor/ARGB() 设置的颜色了，而是使用  Shader 的方案中的颜色。LinearGradient RadialGradient SweepGradient BitmapShader ComposeShader&lt;/p&gt;

&lt;p&gt;setColorFilter(): ColorFilter; 共有三个子类：LightingColorFilter PorterDuffColorFilter 和 ColorMatrixColorFilter&lt;/p&gt;

&lt;p&gt;setXfermode(): Xfermode 指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色; 唯一子类: PorterDuffXfermode&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抗锯齿、填充/轮廓、线条宽度等&lt;/p&gt;

&lt;p&gt;setAntiAlias()&lt;/p&gt;

&lt;p&gt;setStyle()&lt;/p&gt;

&lt;p&gt;线条形状: setStrokeWidth(float width),  setStrokeCap(Paint.Cap cap), setStrokeJoin(Paint.Join join),  setStrokeMiter(float miter)&lt;/p&gt;

&lt;p&gt;色彩优化: setDither(boolean dither) 和  setFilterBitmap(boolean filter)&lt;/p&gt;

&lt;p&gt;setPathEffect(): PathEffect 分为两类，单一效果的 CornerPathEffect DiscretePathEffect DashPathEffect PathDashPathEffect ，和组合效果的 SumPathEffect ComposePathEffect&lt;/p&gt;

&lt;p&gt;什么是硬件加速: https://developer.android.com/guide/topics/graphics/hardware-accel&lt;/p&gt;

&lt;p&gt;setShadowLayer(): 在绘制层下方添加效果
setMaskFilter(): 在绘制层上方添加效果; BlurMaskFilter 和 EmbossMaskFilter&lt;/p&gt;

&lt;p&gt;获取绘制的 Path&lt;/p&gt;

&lt;h3 id=&quot;drawtext相关&quot;&gt;drawText()相关&lt;/h3&gt;

&lt;h2 id=&quot;三-动画&quot;&gt;三. 动画&lt;/h2&gt;

&lt;p&gt;动画可以分为两类：Animation 和 Transition；其中 Animation 又可以再分为 View Animation 和 Property Animation 两类： View Animation 是纯粹基于 framework 的绘制转变，比较简单
Property Animation，属性动画，这是在 Android 3.0 开始引入的新的动画形式
还有一类动画是 Transition。 Transition 这个词的本意是转换，在 Android 里指的是切换界面时的动画效果&lt;/p&gt;

&lt;p&gt;一个动画需要考虑取消&lt;/p&gt;

&lt;p&gt;以下介绍属性动画:&lt;/p&gt;

&lt;p&gt;ViewPropertyAnimator: imageView.animate().translationX(500); 默认动画时长300ms, 默认插值器为AccelerateDecelerateInterpolator()(先加速后减速)
view.setTranslationX()等方法内部没有调用invalidate()来实现重绘, 而是直接使用了硬件加速实现重绘, 这样更加高效, 但是好像自定义绘制不能用, 只能使用invalidate(), 为什么?&lt;/p&gt;

&lt;p&gt;ObjectAnimator: 拼接出set方法名, 然后去调用set方法; 如果只是传入了一个值(ofXXX()有很多重载函数), 该值表示终止值, 但是起始值无法得到, 那么就还需要提供一个get方法来得到初始属性值&lt;/p&gt;

&lt;p&gt;Interpolator: AccelerateDecelerateInterpolator, LinearInterpolator, AccelerateInterpolator, DecelerateInterpolator, AnticipateInterpolator, OvershootInterpolator, AnticipateOvershootInterpolator, BounceInterpolator, CycleInterpolator, PathInterpolator
Android 5.0 （API 21）引入了三个新的 Interpolator 模型，并把它们加入了 support v4 包中: 
FastOutLinearInInterpolator, FastOutSlowInInterpolator, LinearOutSlowInInterpolator&lt;/p&gt;

&lt;p&gt;设置监听器: 
ViewPropertyAnimator 用的是 setListener() 和 setUpdateListener() 方法, 要移除监听器时通过 set[Update]Listener(null) 填 null 值来移除; ViewPropertyAnimator 则独有 withStartAction() 和 withEndAction() 方法，可以设置一次性的动画开始或结束的监听&lt;/p&gt;

&lt;p&gt;ObjectAnimator 则是用 addListener() 和 addUpdateListener() 来添加一个或多个监听器，移除监听器则是通过 remove[Update]Listener() 来指定移除对象; ObjectAnimator 支持使用 pause() 方法暂停，所以它还多了一个 addPauseListener() / removePauseListener() 的支持&lt;/p&gt;

&lt;p&gt;AnimatorListener: onAnimationStart, onAnimationEnd, onAnimationCancel(当动画被通过 cancel() 方法取消时，这个方法被调用。
需要说明一下的是，就算动画被取消，onAnimationEnd() 也会被调用。所以当动画被取消时，如果设置了 AnimatorListener，那么 onAnimationCancel() 和 onAnimationEnd() 都会被调用。onAnimationCancel() 会先于 onAnimationEnd() 被调用。), onAnimationRepeat(ViewPropertyAnimator 不支持重复，所以这个方法对 ViewPropertyAnimator 相当于无效)&lt;/p&gt;

&lt;p&gt;ViewPropertyAnimator.withStartAction/EndAction(): ViewPropertyAnimator 的独有方法, 它们和 set/addListener() 中回调的 onAnimationStart() / onAnimationEnd() 相比起来的不同主要有两点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;withStartAction() / withEndAction() 是一次性的，在动画执行结束后就自动弃掉了，就算之后再重用 ViewPropertyAnimator 来做别的动画，用它们设置的回调也不会再被调用。而 set/addListener() 所设置的  AnimatorListener 是持续有效的，当动画重复执行时，回调总会被调用。&lt;/li&gt;
  &lt;li&gt;withEndAction() 设置的回调只有在动画正常结束时才会被调用，而在动画被取消时不会被执行。这点和 AnimatorListener.onAnimationEnd() 的行为是不一致的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TypeEvaluator: 
在需要的时候, 还可以自定义TypeEvaluator来实现自己针对某一特定属性值来设计自己的算法
ObjectAnimator.setEvaluator()
ArgbEvaluator&lt;/p&gt;

&lt;p&gt;PropertyValuesHolder: 同一个动画中改变多个属性; ViewPropertyAnimator可以直接连用即可, 但是ObjectAnimator不能直接连用, 此时可以使用PropertyValuesHolder来同时在一个动画中改变多个属性&lt;/p&gt;

&lt;p&gt;AnimatorSet 多个动画配合执行; 还可以定义动画的执行顺序&lt;/p&gt;

&lt;p&gt;PropertyValuesHolders.ofKeyframe() 把同一个属性拆分&lt;/p&gt;

&lt;p&gt;「关于复杂的属性关系来做动画」，就这么三种：
使用 PropertyValuesHolder 来对多个属性同时做动画；
使用 AnimatorSet 来同时管理调配多个动画；
PropertyValuesHolder 的进阶使用：使用 PropertyValuesHolder.ofKeyframe() 来把一个属性拆分成多段，执行更加精细的属性动画。&lt;/p&gt;

&lt;p&gt;ValueAnimator 最基本的轮子; ValueAnimator 是 ObjectAnimator 的父类，实际上，ValueAnimator 就是一个不能指定目标对象版本的 ObjectAnimator&lt;/p&gt;

&lt;h2 id=&quot;四-硬件加速&quot;&gt;四. 硬件加速&lt;/h2&gt;

&lt;p&gt;文档: https://developer.android.google.cn/guide/topics/graphics/hardware-accel&lt;/p&gt;

&lt;p&gt;在 Android 里，硬件加速专指把 View 中绘制的计算工作交给 GPU 来处理。进一步地再明确一下，这个「绘制的计算工作」指的就是把绘制方法中的那些  Canvas.drawXXX() 变成实际的像素这件事&lt;/p&gt;

&lt;p&gt;在硬件加速关闭的时候，Canvas 绘制的工作方式是：把要绘制的内容写进一个 Bitmap，然后在之后的渲染过程中，这个 Bitmap 的像素内容被直接用于渲染到屏幕。这种绘制方式的主要计算工作在于把绘制操作转换为像素的过程（例如由一句 Canvas.drawCircle() 来获得一个具体的圆的像素信息），这个过程的计算是由 CPU 来完成的
而在硬件加速开启时，Canvas 的工作方式改变了：它只是把绘制的内容转换为 GPU 的操作保存了下来，然后就把它交给 GPU，最终由 GPU 来完成实际的显示工作(在硬件加速开启时，CPU 做的事只是把绘制工作转换成 GPU 的操作，这个工作量相对来说是非常小的。)&lt;/p&gt;

&lt;p&gt;关闭硬件加速: view.setLayerType(LAYER_TYPE_SOFTWARE, null);&lt;/p&gt;

&lt;p&gt;View Layer，又称为离屏缓冲（Off-screen Buffer），它的作用是单独启用一块地方来绘制这个 View ，而不是使用软件绘制的 Bitmap 或者通过硬件加速的 GPU; 当设置了 View Layer 的时候，它的绘制会被缓存下来，而且缓存的是最终的绘制结果&lt;/p&gt;

&lt;p&gt;在进行移动、旋转等（无需调用 invalidate()）的属性动画的时候开启 Hardware Layer 将会极大地提升动画的效率，因为在动画过程中 View 本身并没有发生改变，只是它的位置或角度改变了，而这种改变是可以由 GPU 通过简单计算就完成的，并不需要重绘整个 View; (打开硬件加速: view.setLayerType(LAYER_TYPE_NONE, null);)&lt;/p&gt;

&lt;p&gt;如果是使用 ViewPropertyAnimator, 如下代码; 不过一定要注意，只有你在对 translationX translationY rotation alpha 等无需调用 invalidate() 的属性做动画的时候，这种方法才适用，因为这种方法本身利用的就是当界面不发生时，缓存未更新所带来的时间的节省。所以简单地说——
&lt;strong&gt;这种方式不适用于基于自定义属性绘制的动画&lt;/strong&gt;。一定记得这句话。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;view.animate()
        .rotationY(90)
        .withLayer(); // withLayer() 可以自动完成上面这段代码的复杂操作
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于设置了 View Layer 后，View 在初次绘制时以及每次  invalidate() 后重绘时，需要进行两次的绘制工作（一次绘制到 Layer，一次从 Layer 绘制到显示屏），所以其实它的每次绘制的效率是被降低了的。所以一定要慎重使用 View Layer，在需要用到它的时候再去使用。&lt;/p&gt;

&lt;p&gt;setLayerType(): 
参数为 LAYER_TYPE_SOFTWARE 时，使用软件来绘制 View Layer，绘制到一个 Bitmap，并顺便关闭硬件加速；
参数为 LAYER_TYPE_HARDWARE 时，使用 GPU 来绘制 View Layer，绘制到一个 OpenGL texture（如果硬件加速关闭，那么行为和  VIEW_TYPE_SOFTWARE 一致）；
参数为 LAYER_TYPE_NONE 时，关闭 View Layer。&lt;/p&gt;

&lt;p&gt;View Layer 可以加速无 invalidate() 时的刷新效率，但对于需要调用  invalidate() 的刷新无法加速&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7Draft/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7Draft/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
      <item>
        <title>Java内存区域与内存溢出异常</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第二章以及其他博客的阅读总结&lt;/p&gt;

&lt;p&gt;重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同时还需要明确的一点是各部分会产生的异常, 以及产生异常的原因&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自网络, 但是忘了出处, 侵删~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;p&gt;在开始讲解之前, 需要先明确关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;的一些基本概念&lt;/p&gt;

&lt;p&gt;我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是一个跨平台的语言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;跨平台的基本支撑其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;对操作系统底层细节的屏蔽, 相当于加了一个中间层(计算机中的任何问题都可以加一个中间层解决~), &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;不再像&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;等语言一样直接翻译为针对特殊平台的机器码, 而是翻译为字节码, 也即是我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 下图大概可以比较简明的概括了~; 字节码就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;世界中的汇编, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;则不是跨平台的, 只是不同平台的&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;都能识别和运行标准格式的字节码文件而已&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/Java编译.png&quot; alt=&quot;Java编译&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 我觉得下图已经可以比较准确的表达了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面要讲的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-运行时数据区&quot;&gt;二. 运行时数据区&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序的时候把它所管理的内存划分为若干个不同的数据区, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM内存区域.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-程序计数器&quot;&gt;2.1 程序计数器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;211-存储数据类型&quot;&gt;2.1.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;指向下一条需要执行的字节码指令; 如果线程正在执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法, 该计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法, 该计数器值则为空(&lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;212-异常情况&quot;&gt;2.1.2 异常情况&lt;/h4&gt;

&lt;p&gt;该区域是是唯一一个在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有规定任何&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;情况的区域&lt;/p&gt;

&lt;h3 id=&quot;22-java虚拟机栈&quot;&gt;2.2 Java虚拟机栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;221-存储数据类型&quot;&gt;2.2.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;描述&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法执行的内存模型, 每个方法调用就对应着一个栈帧的入栈和出栈; 一个栈帧里面存储了局部变量表, 操作数栈, 动态链接, 方法出口等信息&lt;/p&gt;

&lt;p&gt;局部变量表存储了编译器可知的各种基本数据类型, 对象引用, &lt;code class=&quot;highlighter-rouge&quot;&gt;returnAddress&lt;/code&gt;; 局部变量表的大小在编译期间即可确定, 运行期间大小不变&lt;/p&gt;

&lt;h4 id=&quot;222-异常情况&quot;&gt;2.2.2 异常情况&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;StackOverflowError&lt;/strong&gt;: 线程请求栈深度大于虚拟机允许深度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF sof = new JavaVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;Stack Length: &quot; + sof.stackLength);
            throw e;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;: 虚拟机栈动态扩展时无法申请到足够内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop();
                }
            }).start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 由于操作系统分配给每个进程的内存空间是有限制的, 所以如果是由于建立过多的线程导致内存溢出, 在不能减少线程数或者更换&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位虚拟机的情况下, 可以选择通过减少最大堆和减少栈容量来换取更多的线程&lt;/p&gt;

&lt;h3 id=&quot;23-本地方法栈&quot;&gt;2.3 本地方法栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-存储数据类型&quot;&gt;2.3.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;和虚拟机栈类似, 只是本地方法栈提供的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法服务&lt;/p&gt;

&lt;h4 id=&quot;232-异常情况&quot;&gt;2.3.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StackOverflowError&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-java堆&quot;&gt;2.4 Java堆&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;垃圾收集管理的主要区域&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;241-存储数据类型&quot;&gt;2.4.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;几乎所有的对象实例都在这里分配&lt;/p&gt;

&lt;h4 id=&quot;242-异常情况&quot;&gt;2.4.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMHeapOOM {

    static class HeapOOM {
    }

    public static void main(String[] args) {
        List&amp;lt;HeapOOM&amp;gt; list = new ArrayList();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-方法区&quot;&gt;2.5 方法区&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;该区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;251-存储数据类型&quot;&gt;2.5.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;存储已被虚拟机加载的类信息, 常量, 静态变量, 即使编译器编译后的代码等数据&lt;/p&gt;

&lt;h4 id=&quot;252-运行时常量池&quot;&gt;2.5.2 运行时常量池&lt;/h4&gt;

&lt;p&gt;运行时常量池是方法区的一部分, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK6&lt;/code&gt;之后, 常量池被放入了堆中;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中也有常量池部分, 即编译期生成的各种字面量和符号引用, 这部分将在类加载后进入方法区的运行时常量池中, 此外还会把翻译出来的直接引用也存储在运行时常量池中&lt;/p&gt;

&lt;p&gt;运行时常量池相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件常量池的另外一个最重要的特征是具备动态性, 即运行期间也可以将新的常量放入池中, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;intern()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String.intern()&lt;/code&gt;作用是: 如果字符串常量池中已经包含一个等于此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的字符串, 则返回代表池中这个字符串的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象; 否则, 将此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象包含的字符串添加到常量池中, 并且返回此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的引用&lt;/p&gt;

&lt;p&gt;同样, 收方法区的限制, 当常量池无法再申请到内存时会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;253-异常情况&quot;&gt;2.5.3 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;: 方法区无法满足内存分配需求&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;26-直接内存&quot;&gt;2.6 直接内存&lt;/h3&gt;

&lt;p&gt;直接内存不是虚拟机运行时数据区的一部分, 但是也被频繁使用, 如: 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.4&lt;/code&gt;中新加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;类, 引入了一种基于通道(&lt;code class=&quot;highlighter-rouge&quot;&gt;Chanel&lt;/code&gt;)和缓冲区(&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;方式, 它可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;函数库直接分配堆外内存, 然后通过一个存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirectByteBuffer&lt;/code&gt;对象作为这块内存的引用进行操作, 避免了在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;堆中来回复制数据, 提高性能&lt;/p&gt;

&lt;p&gt;同样会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-常见问题&quot;&gt;三. 常见问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 下文摘自文末参考链接, 权作个人笔记~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序运行永远都是在栈中进行的，因而参数传递时, 只存在传递基本类型和对象引用的问题, 不会直接传对象本身;  但是传引用的错觉是如何造成的呢? 在运行栈中, 基本类型和引用的处理是一样的, 都是传值, 所以, 如果是传引用的方法调用, 也同时可以理解为“传引用值”的传值调用, 即引用的处理跟基本类型是完全一样的; 但是当进入被调用方法时, 被传递的这个引用的值, 被程序解释(或者查找)到堆中的对象, 这个时候才对应到真正的对象; 如果此时进行修改; 修改的是引用对应的对象; 而不是引用本身; 即: 修改的是堆中的数据; 所以这个修改是可以保持的了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我产生的对象不多呀, 为什么还会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答: 你继承层次忒多了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;中产生的对象是先产生父类, 然后才产生子类, 明白不?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;错误分几种?
答: 分两种, 分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError:java heap size&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError: PermGen space&lt;/code&gt;, 两种都是内存溢出, &lt;code class=&quot;highlighter-rouge&quot;&gt;heap size&lt;/code&gt;是说申请不到新的内存了, 这个很常见，检查应用或调整堆内存大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;PermGenspace&lt;/code&gt;是因为永久存储区满了, 这个也很常见, 一般在热发布的环境中出现, 是因为每次发布应用系统都不重启, 久而久之永久存储区中的死对象太多导致新对象无法申请内存, 一般重新启动一下即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么不建议在程序中显式的生命&lt;code class=&quot;highlighter-rouge&quot;&gt;System.gc()&lt;/code&gt;?
答: 因为显式声明是做堆内存全扫描, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;, 是需要停止所有的活动的(&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop The World Collection&lt;/code&gt;), 你的应用能承受这个吗?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.importnew.com/1993.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.cnblogs.com/dolphin0520/p/3783345.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/2905-JVM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java之IO流</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中一个比较重要的模块–&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;流&lt;/p&gt;

&lt;p&gt;以下内容是对&lt;strong&gt;Java核心技术卷II&lt;/strong&gt;的总结, 权做个人笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java I/O&lt;/code&gt;流指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.io&lt;/code&gt;包和&lt;code class=&quot;highlighter-rouge&quot;&gt;java.nio&lt;/code&gt;包提供的各种操作文件和输入输出等的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 具体可以分为两大类: 一类是面向字节的, 一类是面向字符的; 面向字节的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;是以&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStream&lt;/code&gt;类为基类, 每次以一个字节为单位进行读写操作; 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt;为基类, 每次以两个字节为单位进行读写操作, 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;主要是针对文本操作设计的&lt;/p&gt;

&lt;p&gt;可以参见下图:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字节&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字节.png&quot; alt=&quot;面向字节&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字符&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字符.png&quot; alt=&quot;面向字符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: &lt;a href=&quot;https://blog.csdn.net/zhoupenglei/article/details/46312405&quot;&gt;图片来源&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-重要概念&quot;&gt;二. 重要概念&lt;/h2&gt;

&lt;h3 id=&quot;21-流嵌套&quot;&gt;2.1 流嵌套&lt;/h3&gt;

&lt;p&gt;即将不同功能的流嵌套起来, 过滤; 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中流默认是不被缓冲区缓存的, 也就是说每个&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;的调用都会请求操作系统再分发一个字节, 相比之下, 请求一个数据块并将其置于缓冲区中会显得更加高效, 如果我们想使用缓冲机制, 以及用于文件输入方法, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;            BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;file&quot;));&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-glob模式匹配&quot;&gt;2.2 Glob模式匹配&lt;/h3&gt;

&lt;p&gt;即使用正则筛选文件, 如筛选文件后缀名为&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;的文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;), &quot;*.java&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Glob&lt;/code&gt;模式见下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模式&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;匹配路径组成部分中0个或多个字符&lt;/td&gt;
      &lt;td&gt;*.java匹配当前目录中的所有Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;**&lt;/td&gt;
      &lt;td&gt;匹配跨目录边界的0个或多个字符&lt;/td&gt;
      &lt;td&gt;**.java匹配在所有子目录中的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;匹配一个字符&lt;/td&gt;
      &lt;td&gt;????.java匹配所有四个字符的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[…]&lt;/td&gt;
      &lt;td&gt;匹配一个字符集合&lt;/td&gt;
      &lt;td&gt;Test[0-9A-F].java匹配Testx.java, 其中x是一个十六进制数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;{…}&lt;/td&gt;
      &lt;td&gt;匹配由逗号隔开的多个可选项之一&lt;/td&gt;
      &lt;td&gt;*.{java, class}匹配所有的Java文件和类class文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;转移上述任意模式中的字符&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;*&lt;/em&gt;匹配所有文件名中包含*的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;23-常用工具类&quot;&gt;2.3 常用工具类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Files&lt;/strong&gt;: 使得读写文件和操作文件及文件夹变得简单; 旧的&lt;code class=&quot;highlighter-rouge&quot;&gt;File&lt;/code&gt;类中有一个方法可以用来获取一个目录下的所有文件构成的数组, 但是当目录中包含大量文件时, 这个方法的性能非常低, &lt;code class=&quot;highlighter-rouge&quot;&gt;Files&lt;/code&gt;类设计了一个方法可以产生&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;对象, 如下示例代码:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;));
Iterator&amp;lt;Path&amp;gt; iterator = entries.iterator();
for (Path path : entries) {
    System.out.println(path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Paths&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths&lt;/code&gt;可以用来构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Path&lt;/code&gt;对象: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths.get(args)&lt;/code&gt;, 可以接收一个或多个字符串, 并将它们用默认文件系统分隔符连接起来&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-内存映射文件&quot;&gt;2.4 内存映射文件&lt;/h3&gt;

&lt;p&gt;大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分”映射”到内存中, 然后这个文件就可以当做是内存数组一样的访问, 中比传统的文件操作要快得多; 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;25-易忘类&quot;&gt;2.5 易忘类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStreamReader&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStreamWriter&lt;/code&gt;: 可以指定编码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintWriter&lt;/code&gt;: 以文本格式写出数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccessFile&lt;/code&gt;: 在任何位置查找或写入数据; 可以用于实现断点续传&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DataInputStream&lt;/code&gt;: 读取数字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectOutputStream&lt;/code&gt;: 读取对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;26-文件操作处理效率&quot;&gt;2.6 文件操作处理效率&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;普通输入流&lt;/td&gt;
      &lt;td&gt;110s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;带缓冲的输入流&lt;/td&gt;
      &lt;td&gt;9.9s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;随机方访问文件&lt;/td&gt;
      &lt;td&gt;162s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存映射文件&lt;/td&gt;
      &lt;td&gt;7.2s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View绘制流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之绘制流程&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的绘制流程分为三大步: &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;即测量, 测量&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;即布局, 按照一定的规则排布&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;即绘制, 绘制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的外形; 这三步是和我们自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;息息相关的, 熟悉和掌握这三大流程, 我们才能随心所欲的定制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; 本文也将从这三个方面入手, 结合源码讲解&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制的整体流程, 如下图;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View绘制流程.png&quot; alt=&quot;View绘制流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 图片来自: https://www.jianshu.com/p/dc0b039e7c4f&lt;/p&gt;

&lt;p&gt;可以看出, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;三大流程直接相关的是从&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的; 大致流程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performTraversals() {
    ...
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
    performLayout(lp, mWidth, mHeight);
    ...
    performDraw();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-measure过程&quot;&gt;二. measure过程&lt;/h2&gt;

&lt;p&gt;在开始讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之前, 我们需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程的理解还是很重要的&lt;/p&gt;

&lt;h3 id=&quot;21-measurespec&quot;&gt;2.1 MeasureSpec&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的值, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;的位组合; 高&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;, 低&lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 这样设计其实是为了节约空间; 关于二者如何组合, 可以参见以下代码; 可以看出, 其实就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MODE_MASK&lt;/code&gt;掩码以及位操作实现将两个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型整合为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;; 当然, 要分别提取这两个值的话, 也可以很简单的用位操作实现, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &amp;lt;&amp;lt; MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size &amp;amp; ~MODE_MASK) | (mode &amp;amp; MODE_MASK); // MODE_MASK  = 0x3 &amp;lt;&amp;lt; 30; 
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;即测量模式, 一共有三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;: 父容器不对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;有任何限制, 要多大给多大, 这种情况一般用于系统内部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;: 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和具体数值这两种模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;: 父容器指定了一个可用大小即&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小不能大于该值, 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;的类型区别可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的确定受&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;的影响, 但是也要分情况: 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;RootView&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;来说, 由于其没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由窗口尺寸和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定; 对于普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;来说, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由父容器传递的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定&lt;/p&gt;

&lt;p&gt;普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;创建规则见下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;childLayoutParams&lt;/strong&gt; \ &lt;strong&gt;parentSpecMode&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;dp/px&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;match_parent&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;wrap_content&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自«Android开发艺术探索»&lt;/p&gt;

&lt;p&gt;上面表格中展现的规则需要好好理解:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸是明确的值时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_height&lt;/code&gt;有确定的值, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;是什么, &lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;都保持规定尺寸不变; 这点比较好理解, 因为明确指定&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸之后, 我们肯定希望显示的也是指定尺寸&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;时, 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是确定尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸也能确定, 也就是父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, parentSize&lt;/code&gt;也可以理解; 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸不确定, 此时父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;只知道一个最大尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;, 也只能知道一个最大尺寸, 而且该最大尺寸不应该超过&lt;code class=&quot;highlighter-rouge&quot;&gt;parentSize&lt;/code&gt;, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;, 即尺寸大小不确定的话, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是具有确定尺寸还是尺寸不确定, 反正&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸始终是不确定的, 所以此时应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;, 而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸也不应该超过父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 故综上为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-decorview的measure过程&quot;&gt;2.2 DecorView的measure过程&lt;/h3&gt;

&lt;p&gt;我们知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;是整个&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;树的&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;, 我们首先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的测量过程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getRootMeasureSpec()&lt;/code&gt;来获取&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 如下; 结合上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则可以理解&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;MATCH_PARENT&lt;/code&gt;, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以其尺寸就为窗口尺寸, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;WRAP_CONTENT&lt;/code&gt;, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;尺寸不确定, 最大尺寸不应该超过窗口尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, windowSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;明确规定了自己的尺寸, 那么就不受窗口尺寸的影响, 为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, rootDimension&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建好&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;之后, 就直接传入了&lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;中, &lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;的代码如下; 可以看出, 接下来就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;进行测量, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的, 不可重写, 所以应该追溯到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;(继承链为: &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeausre()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;不是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的,
所以我们应该去分析的是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        if (mView == null) {
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的在&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;中将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;进行处理和判断之后, 调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;super.onMeasure()&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;; 如下, 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;方法中处理了&lt;code class=&quot;highlighter-rouge&quot;&gt;Margin&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;)和&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;getPaddingXXX&lt;/code&gt;), 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;中会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;child.measure()&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递(即递归测量), 这样就将测量工作传递到了子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DecorView.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    ...
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    ...
}

// FrameLayout.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int count = getChildCount();
        for (int i = 0; i &amp;lt; count; i++) {
            final View child = getChildAt(i);
            if (mMeasureAllChildren || child.getVisibility() != GONE) {
                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                maxWidth = Math.max(maxWidth,
                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                maxHeight = Math.max(maxHeight,
                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                childState = combineMeasuredStates(childState, child.getMeasuredState());
                if (measureMatchParentChildren) {
                    if (lp.width == LayoutParams.MATCH_PARENT ||
                            lp.height == LayoutParams.MATCH_PARENT) {
                        mMatchParentChildren.add(child);
                    }
                }
            }
        }

        // Account for padding too
        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
        ...
}

// FrameLayout.measureChildWithMargins()
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
            ....
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程分为&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量过程&lt;/p&gt;

&lt;h3 id=&quot;23-viewgroup的measure过程&quot;&gt;2.3 ViewGroup的measure过程&lt;/h3&gt;

&lt;p&gt;我们来看子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时的测量过程; 其实对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;有不同的布局规则, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearLayout&lt;/code&gt;, 有竖直布局和水平布局两种, 而这两种不同的布局测量方式也不同; 所以我们这里只是简单的看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;对子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的通用测量方式&lt;/p&gt;

&lt;p&gt;代码如下; 测量逻辑比较简单, 也是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递, 实现递归测量, 不做细讲啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i &amp;lt; size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
}


protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();
            
        // 获取child的MeasureSpec, 同时考虑Padding
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 递归调用, 又回到了这里
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的一点是子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getChildMeasureSpec()&lt;/code&gt;为例, 如下; 其构造规则除了考虑了&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;以外, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构造规则表是相同的, 可以结合代码注释再次理解该表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        case MeasureSpec.EXACTLY: // 如果父View尺寸确定
            if (childDimension &amp;gt;= 0) { // childDimension &amp;gt;= 0, 表示的是子View的layout_xxx设置了具体的数值, 因为wrap_content = -2
                                       // match_parent = -1
                resultSize = childDimension; // 那么集合MeasureSpec的构造规则及对应解释, 这里应该为childDimension, EXACTLY
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 同时父View尺寸也确定
                resultSize = size;  // 说明子View尺寸确定, 且为父View尺寸
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸确定
                resultSize = size;  // 说明子View尺寸不确定, 最大不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.AT_MOST: // 如果父View尺寸不确定
            if (childDimension &amp;gt;= 0) {
                resultSize = childDimension; // 如果子View的layout_xxx设置了明确的值
                resultMode = MeasureSpec.EXACTLY; // 那么子View有确定尺寸, 即为设置的值
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 但是父View的尺寸不定
                resultSize = size; // 那么子View的尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸不定
                resultSize = size; // 那么子View尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.UNSPECIFIED:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-view的measure过程&quot;&gt;2.4 View的measure过程&lt;/h3&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;啦~, 只是一个单纯的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;控件而已; 其默认测量规则如下; 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getSuggestedMinimumWidth()&lt;/code&gt;为例, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;android:minWidth&lt;/code&gt;属性, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 如果设置了背景, 则返回背景宽度和指定&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;中的最大值; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;则是返回默认尺寸, 我们只需关心&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;两种情况即可(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;UNSPECIFIED&lt;/code&gt;一般用于系统, 不常用), 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对于这两种情况默认都是返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即传入的尺寸,
我们上面说了&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;模式, &lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和指定数值情况, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;将这两种情况都默认返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;可用空间, 很明显, 这对于&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;是不支持的(因为此时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;), 所以在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 需要自己根据逻辑实现&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的情况, 具体实现可以参见&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ImageView&lt;/code&gt;等对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// 这里以Width为例
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}

public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, 最终我们确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的尺寸之后, 还需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;正真设置和作用到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;上; 需要注意的是, 此时只是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高, 可能不是实际宽高, 实际宽高在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中才能确定, 出现测量宽高和实际宽高不相等的原因 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中改变了&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;实际布局的位置尺寸等造成的, 但是一般情况下二者都是相等的&lt;/p&gt;

&lt;h3 id=&quot;25-自定义view时measure过程注意事项&quot;&gt;2.5 自定义View时measure过程注意事项&lt;/h3&gt;

&lt;p&gt;到这里, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制过程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程就已经讲解完了; 但是笔者还想提一下在实际使用, 即自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 还需要注意哪些方面; 这里需要提前声明的是, 下面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包含&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;, 只是单纯的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;需要自己实现对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要自己处理&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;的情况, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;还需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记住使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;使测量尺寸生效, 否则会抛异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-layout过程&quot;&gt;三. layout过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程会确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;最终的位置和尺寸, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程才是真正实现不同布局的关键; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的传递是从&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;开始往下传递&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;中则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());&lt;/code&gt;, 前面我们已经说过了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;,
但是这里我们并不去分析&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 因为这是针对某一具体布局而言的; 我们这里选择具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法如下; 可以看出其调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;中, 可以看出调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 同时还需要注意一点就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法是由&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的, 这也就意味着自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的时候, 不能重写&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;是一个抽象方法, 也就是说我们必须自己去是实现; 其实这也很好理解, 因为对于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 我们需要实现自己的布局,
这里实现逻辑其实就是写在&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;中即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewGroup.layout()
public final void layout(int l, int t, int r, int b) {
    ...
    super.layout(l, t, r, b);
    ...
}

// View.layout()
public void layout(int l, int t, int r, int b) {
    ...
    boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    ...
    onLayout(changed, l, t, r, b);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 还需要注意一点的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法中还调用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setFrame()&lt;/code&gt;, 该方法的作用其实是设置&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mRight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mTop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mBottom&lt;/code&gt;的值; 这里反应的其实是上文说过的一句话, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程中确定测量宽高, 实际宽高需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中确定; 这里就是记录&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的实际宽高; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredHeight()&lt;/code&gt;来获取, 这在&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之后即可得到; 实际宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getHeight()&lt;/code&gt;来得到,
这在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程之后可以获取; 至于二者的区别, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;为例, 如下; 可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;获取的其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;获取的则是实际宽高(因为是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的右边界减去左边界); 上面已经说过了测量宽高和实际宽高的区别, 这里就不再赘述啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final int getMeasuredWidth() {
    return mMeasuredWidth &amp;amp; MEASURED_SIZE_MASK;
}

public final int getWidth() {
    return mRight - mLeft;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程比较简单, 也是一个递归调用的过程, 至于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时主要是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的设计, 需要考虑的还是要&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的影响啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-draw过程&quot;&gt;四. draw过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;过程其实就是其&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 最终会调用到&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;(实际上调用栈是: &lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;performDraw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;drawSoftware()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时官方并不建议去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 而是建议重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;去实现自己的逻辑, &lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中实际上是一个空实现; 我们这里先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;的实现逻辑&lt;/p&gt;

&lt;p&gt;官方文档注释中已经说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;过程的实现逻辑, 如下; 可以看出, 主要绘制逻辑为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绘制背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制内容(即自己)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制装饰, 如滚动条等前景&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;步和第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;步一般会跳过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// View.draw()
public void draw(Canvas canvas) {
        ...
        /*
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
        ...
         // Step 1, draw the background, if needed
         if (!dirtyOpaque) {
             drawBackground(canvas);
         }
         // skip step 2 &amp;amp; 5 if possible (common case)
         // Step 3, draw the content
         if (!dirtyOpaque) 
            onDraw(canvas);
         // Step 4, draw the children
         dispatchDraw(canvas);
         // Step 6, draw decorations (foreground, scrollbars)
         onDrawForeground(canvas);
         ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道, 绘制内容这一步是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;, 即我们自己自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时需要实现的内容; 另外, 这里需要注意的一点是绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchDraw()&lt;/code&gt;去传递绘制绘制过程, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 一般用于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;中其实现如下; 其实就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后依次调用子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法绘制出子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void dispatchDraw(Canvas canvas) {
    ...
    for (int i = 0; i &amp;lt; childrenCount; i++) {
        ...
        more |= drawChild(canvas, transientChild, drawingTime); // 在drawChild()中调用child.draw(canvas, this, drawingTime)将绘制过程传递
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的整个绘制流程就讲解完成啦~, 当然这对于我们随心所欲的实现炫酷的自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;还是第一步理论基础, 真正要做到还是需要靠自己多动手去画咯~&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View事件分发机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之事件分发机制&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的触摸事件分发是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列中的一个重难点, 主要需要掌握的是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的传递规则和处理规则, 这是自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中冲突处理的理论来源~&lt;/p&gt;

&lt;p&gt;触摸事件分发的处理主要是对&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;封装了用户的一系列行为, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指刚触摸屏幕), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指在屏幕上滑动), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;(手指抬起)等; 以及事件发生的坐标(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getX()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getY()&lt;/code&gt;可以得到)等&lt;/p&gt;

&lt;p&gt;在开始讲解之前需要明确的一些概念是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个事件序列: 指的是一次完整的触摸过程, 即从&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指触摸屏幕)开始, 到中间的一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指滑动), 最后到&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;为止(手指抬起); 总结起来就是&lt;code class=&quot;highlighter-rouge&quot;&gt;down...move...move..up&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触摸事件的分发其实是一个从上到下不断递归传递和拦截的过程; 一个大致的传递流程是: &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 当然如果向下传递但是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;又没有消耗的话, 又会逐层返回, 最终将没有消耗的&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-事件分发之源&quot;&gt;二. 事件分发之源&lt;/h2&gt;

&lt;p&gt;触摸事件产生和分发的源头是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中处理的, 即在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;中; 如下; 处理思路也很简单, 只是单纯的向下分发而已, 如果事件没有得到处理, 那么最终就交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理; 另外, 这里还为用户提供了一个监听和拦截事件的方法, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;onUserInteraction()&lt;/code&gt;, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中是一个空实现, 可以重写该方法在事件向下传递之前进行特殊拦截和处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();  // 自定义事件拦截
        }
        if (getWindow().superDispatchTouchEvent(ev)) {  // 通过Window向下分发事件
            return true;
        }
        return onTouchEvent(ev);  // 如果事件最终没有被处理, 那么交给Activity自己的onTouchEvent()来处理
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow&lt;/code&gt;, 这里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow.superDispatchTouchEvent()&lt;/code&gt;传递实际上是只是简单调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor.superDispatchTouchEvent(event)&lt;/code&gt;, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;superDispatchTouchEvent()&lt;/code&gt;方法中, 也只是简单的将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行分发(即&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;); 到这里就将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了, 也是事件分发处理中最主要的一部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-viewgroup分发事件&quot;&gt;三. ViewGroup分发事件&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;中对事件的分发处理过程比较长, 实际上大致分成了三个部分来处理&lt;/p&gt;

&lt;h3 id=&quot;31-事件拦截&quot;&gt;3.1 事件拦截&lt;/h3&gt;

&lt;p&gt;首先, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;会判断是否进行事件拦截, 如下; 从后面将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的条件可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截, 那么该事件序列将不再向下分发; 这里还需要注意的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;判断是否进行事件拦截的条件一个是为&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget != null&lt;/code&gt;时; 也就是说一个事件序列的在开始时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;(当然, 还有一个影响因素是&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 我们稍后讲解); 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的赋值是在后面分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 如果有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值;&lt;/p&gt;

&lt;p&gt;上面是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截的基本思路, 简单总结起来就是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截(&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;), 那么同一事件序列将不再向下分发(因为之后的&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;到来时, 由于之前&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时进行了事件拦截, &lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;没有机会赋值, 所以仍然为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 故直接走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;语句, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;intercepted = true&lt;/code&gt;);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值, 即不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 此时仍然会继续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;判断是否进行事件拦截, 需要注意的是此时仍然在同一事件序列中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 也没有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;仍为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 即走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, 交由&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不处理事件时, &lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;才只会调用一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // ViewGroup是否进行事件拦截
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            if (!canceled &amp;amp;&amp;amp; !intercepted) { // 如果拦截事件, 将不再分发给子View
                // 事件分发给子View
                ....
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 上面还讲了, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;, 这里还有一个影响因素是标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 该标志位是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;requestDisallowInterceptTouchEvent()&lt;/code&gt;设置的, 作用是在子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中强制父&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 但是该标志位不能影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;, 因为在一个事件序列开始之前会先进行状态重置, 如下; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;resetTouchState()&lt;/code&gt;中会将该标志位重置, 所以就不会影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState(); // 状态重置
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-事件分发&quot;&gt;3.2 事件分发&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截的话, 会将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理; 事件分发的主要代码如下; 逻辑也比较简单, 就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;进行将事件传递给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        ...
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &amp;lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign); // 设置mFirstTouchTarget的值
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                        ...
                    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续来看&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;的处理过程, 如下; 从上面的代码中我们可以看出, 将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;非空, 所以应该调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 这样就将事件传递到子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中去了; 这里关于子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;处理在后文继续讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        ...
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event); // child非null
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event); // 调用child.dispatchTouchEvent(event)

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面我们说过, 如果子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 将会去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的值, 该值的设置其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;中, 也就是说, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 就会去调用该函数, 也就证明了我们前面所说的; 我们来看&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;, 如下; 可以看出这里实际上相当于一个单链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget; 
        mFirstTouchTarget = target; // 设置mFirstTouchTarget
        return target;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-viewgroup处理事件&quot;&gt;3.3 ViewGroup处理事件&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;将进行事件处理, 如下; 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件处理也是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;, 只是传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 那么从上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;代码中我们可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;调用的应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;进行事件处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 调用的其实都是&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;, 所以接下来我们要看的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中对事件的处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-view事件处理&quot;&gt;四. View事件处理&lt;/h2&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中没有&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;方法来进行事件拦截; 我们这里关注的, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截之后对事件的处理以及子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理; 因为从前面我们已经说了, 不管是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件)还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent()&lt;/code&gt;(子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理事件), 其实都是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;; 所以二者对事件的处理实际上是一样的, 同时需要注意的是, 这一节不包括事件的分发了,
事件分发在上一节中已经讲解完啦~&lt;/p&gt;

&lt;p&gt;触摸事件的处理主要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;的处理优先级&lt;/p&gt;

&lt;p&gt;主要代码如下; 可以看出先处理的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;View.setOnTouchListener()&lt;/code&gt;)的话, 再去处理&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;,  所以&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的优先级比&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;高; 同时还要注意的一点是, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的话, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;将不再调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
            &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
            &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {  // OnTouchListener
        result = true;
    }
    if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { // onTouchEvent
        result = true;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick()&lt;/code&gt;其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;中处理的; 如下; &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;是在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中触发的, 可以看出, 要触发&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;需要的条件是: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是可以点击的(&lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;), 这里的可点击包括了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLICKABLE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LONG_CLICKABLE&lt;/code&gt;, 注意&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;enable&lt;/code&gt;属性不影响&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;的返回值, 只要它可点击, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;就会处理该点击事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                    if (!focusTaken) {
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) {
                            mPerformClick = new PerformClick();
                        }
                        if (!post(mPerformClick)) {
                            performClickInternal();
                        }
                    }
                }
                ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;进行处理, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;会判断, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 则会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的事件分发和处理流程就分析结束啦~; 我们最开始讲&lt;strong&gt;事件分发之源&lt;/strong&gt;时讲&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;对事件的传递的时候, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;getWindow().superDispatchTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的话, 就最终将事件交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理, 这种情况其实对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;都不进行事件处理, 那么就逐层回传咯~&lt;/p&gt;

&lt;p&gt;当然理论学习完了, 就应该实际测试一下, 这里笔者写了一个测试的&lt;code class=&quot;highlighter-rouge&quot;&gt;Demo&lt;/code&gt;, &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/touch/TouchActivity.java&quot;&gt;参见Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后将上述流程总结为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View事件分发.png&quot; alt=&quot;View事件分发机制&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>Handler</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android消息机制分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handler源码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;算是我们平时开发中比较常用的一个, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所代表的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中重要的一部分, 即消息机制; 本文将分析&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的运行机制&lt;/p&gt;

&lt;h3 id=&quot;11-使用场景&quot;&gt;1.1 使用场景&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程切换: 这个是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见和最频繁的场景了; 我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中不允许执行耗时操作, 那么当我们需要先去获取数据(耗时)再进行&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;展示或者交互的时候, 线程切换就必不可少了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务延时: 即在未来某个时刻再执行任务, 这个主要是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.postDelayed()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessageDelayed()&lt;/code&gt;完成的(实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;postDelayed()&lt;/code&gt;也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessageDelayed()&lt;/code&gt;完成的)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-为什么会有handler&quot;&gt;1.2 为什么会有Handler&lt;/h3&gt;

&lt;p&gt;我们都知道&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的作用主要是用于切换线程, 那么为什么会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;喃; 我们以&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中执行耗时操作为例, 对于耗时操作, 特别是在需要实时交互的应用中, 肯定是需要设计为多线程的, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;设计之初为什么不使用多线程去访问&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;呢, 最致命的一点就是, 多线程存在并发访问的不确定性, 这就会造成&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;表现的不可预期性, 造成用户体验极差; 当然, 对于多线程并发的问题还是有很多方式去避免和解决的, 最常见的一个就是加锁, 那么为什么不采用多线程访问,
对&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;加锁的方式实现呢, 一个是加锁会使&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;逻辑变得复杂, 另一个是加锁会降低效率, 阻塞某些线程的执行&lt;/p&gt;

&lt;p&gt;所以, 基于很多方面的考虑, 特别是对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;应用这样交互性很强的场景而言, 使得需要去实现自己的一套异步通信机制, 需要达到的目标是, 线程之间的独立性保持和数据交互的便利性, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实现的&lt;/p&gt;

&lt;h3 id=&quot;13-概述&quot;&gt;1.3 概述&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;消息机制中, 有非常重要的几个部分, 也是我们分析的切入点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;: 单链表, 实现消息存储; 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层的连接纽带&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Looper&lt;/strong&gt;: 无限循环查询是否有新消息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Handler&lt;/strong&gt;: 消息接受和分发处理的中转站&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见的一种写法, 我们通常会重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;来实现自己的逻辑; 当在其他线程中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessage()&lt;/code&gt;来发送消息时, 我们就会在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中接收到该消息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            // do somthing with msg
            super.handleMessage(msg);
        }
    };

    new Thread() {
        @Override
        public void run() {
           mHandler.sendEmptyMessage(0);
        }
    }.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行线程切换和消息传递的一个大致流程是, 当我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessage()&lt;/code&gt;发送消息的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;负责存储该消息, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;会无限循环的去检查&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 如果有则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage()&lt;/code&gt;进行消息分发, 最终会回到&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;p&gt;在开始讲解之前, 需要先明确几个结论(在稍后会验证): 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是默认没有创建(除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程外); &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所必须的(否则会抛异常); &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是一一对应的关系, 也就是说每个线程会有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;在哪个线程中创建就在哪个线程中处理消息, 其他线程发送的消息存储在对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-构造函数&quot;&gt;二. 构造函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;提供了七个构造函数, 如下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler()&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(Looper looper)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(boolean async)&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback, boolean async)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback, boolean async)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这七个构造函数最常用的是默认构造函数(即不带参数那个), 其他几个, 一类是带&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;的, 是提供的消息处理函数, 我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;一般都会重写其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;方法来处理消息, 但是也可以不重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;, 而是在构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;回调, &lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的一个接口, 如下; 另一类是带标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;的, 是设置消息是否为异步处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的消息默认是同步处理的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public interface Callback {
        public boolean handleMessage(Message msg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们以构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler(Callback callback, boolean async)&lt;/code&gt;进行分析, 如下; 可以看出, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLooper&lt;/code&gt;是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;获取的, 如果我们获取为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;也就是说当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛出异常, 这个异常也是我们大多数初学者会遇到的; 这里也验证了上面所说的, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造所必须的, 如果当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛异常(至于为什么说是当前线程, 接下来马上分析~)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Handler(Callback callback, boolean async) {
        ...
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;又是如何获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的呢; 如下, 可以看出是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;获取的, &lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;类型的实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;不是一个线程, 而是用于在每个线程中存储数据的, &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;可以在不同的线程中互不干扰的存储并提供数据; 那么它是如何实现在不同线程中互不干扰的存取数据的呢, 我们先来看其&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;方法, 可以看出, 其实际上会先去检查当前线程是否持有&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;, 如果有的话, 直接将&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;存储进去即可, 否则, 初始化当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;然后再存放值, 这样就可以根据不同的线程来存取各自线程的值了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们要构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;就必须获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么我们又是什么时候构造和存储的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;喃; 前面我们说了, 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程以外都默认没有创建; 我们先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中是什么时候创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityThread&lt;/code&gt;, 在其&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数中, 我们发现了如下与&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;相关的语句, 这实际上是开启了主线程的消息处理(因为要处理各种事件, 所以一开始就开启了)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    ...
    Looper.prepareMainLooper();
    ...
    Looper.loop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续看&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.prepareMainLooper()&lt;/code&gt;, 其中实际上是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;, 如下; 这里我们看到了熟悉的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal.set()&lt;/code&gt;, 而且存储的是一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么这里就将线程和各自的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;联系起来了, 我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造函数中获取的也就是和各个线程相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里我们知道了, &lt;code class=&quot;highlighter-rouge&quot;&gt;perpare&lt;/code&gt;实际上是在准备&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;又是在做啥呢, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是开启消息处理循环, 前面我们说了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;不断的去检测&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 实际上就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;中开启的&lt;/p&gt;

&lt;p&gt;这里我们暂时不讲&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;, 而是放到后面讲消息处理的时候讲; 我们平时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候, 大多是在&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;
线程中创建的, 因为上面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中默认是创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的, 所以不需要我们再去手动创建, 但是我们如何在子线程中构造和使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;呢; 其实在&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的文档中已经给出了示例, 如下; 其实, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的处理过程差不多, 只是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程的特殊性, 所以单独给它准备了一个方法~(实际上是做一些其他特殊判断和处理)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();
 
          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;三-消息发送&quot;&gt;三. 消息发送&lt;/h3&gt;

&lt;p&gt;当我们需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;发送消息时, 可以使用两个系列, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;系列, 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;系列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;postXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列主要是发送一个自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件, 然后去执行(延迟执行)自定义事件&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;post(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, Object token, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, Object token, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtFrontOfQueue(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;sendXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列主要是发送封装的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;, 然后根据&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;带的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;或者数据在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessage(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessage(int what)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageDelayed(int what, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageAtTime(int what, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageDelayed(Message msg, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtTime(Message msg, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtFrontOfQueue(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;但是, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列最终还是将&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件封装为了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列处理, 而不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;, 最终转到的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;进行处理; 另外, 不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;int what&lt;/code&gt;等其他类型, 其实最终都会将每一条消息封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象进行传递&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-消息存储&quot;&gt;四. 消息存储&lt;/h2&gt;

&lt;p&gt;前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;会对发送的消息进行存储, 这一步就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;中处理的; 如下; 需要注意的是这里传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;是在创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;时创建, 也就是说和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关, 因为涉及到多线程的处理, 所以需要清楚&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;的来源, 不然消息处理的时候就混了~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们简单看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的组织方式, 如下, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.enqueueMessage()&lt;/code&gt;, 可以看出是很明显的单链表的存储方式, 之所以用单链表, 是因为单链表在增加和删除节点上有优势&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean enqueueMessage(Message msg, long when) {
    ...
    needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
    Message prev;
    for (;;) {
        prev = p;
        p = p.next;
        if (p == null || when &amp;lt; p.when) {
            break;
        }
        if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
            needWake = false;
        }
    }
    msg.next = p; // invariant: p == prev.next
    prev.next = msg;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-消息处理&quot;&gt;五. 消息处理&lt;/h2&gt;

&lt;p&gt;还记得前面我们还有一个问题没有解决吗, 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程实际上就是开启循环处理消息的过程~&lt;/p&gt;

&lt;p&gt;该函数如下; 首先获取消息处理线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 前面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是在消息处理线程中调用的, 所以这里获取到的, 也就是消息处理线程, 即创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的线程; 之后获取对应线程的消息队列, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 需要注意这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;关联的, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的获取是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.currentThread()&lt;/code&gt;来判断和获取的, 那么这里就能获取到和对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 当我们在不同线程中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMsg&lt;/code&gt;的时候, 插入的也是和该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 这样, 一整条完整的线就串成了:  不同的线程往需要发送消息的线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中插入&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;, 而和线程关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;又从该&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中不断获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;处理, 这样就完成了线程的切换 !!&lt;/p&gt;

&lt;p&gt;接下来就是用一个死循环(&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;)开始消息处理了; 逻辑也比较简单, 其实就是不断的从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息(&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;), 然后回调&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.dispatchMessage(msg)&lt;/code&gt;分发, 需要注意的是, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;msg.target&lt;/code&gt;实际上是存储的对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void loop() {
    final Looper me = myLooper();
    ...
    final MessageQueue queue = me.mQueue;
    ...

     for (;;) {
        Message msg = queue.next(); // might block
        // 如果消息为null, 不处理咯
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        ...
        msg.target.dispatchMessage(msg);
     }

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage&lt;/code&gt;的处理逻辑, 如下; 逻辑也很简单, 就是消息处理的优先级: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;自身设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;, 就直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;(这种情况对应前面说的&lt;code class=&quot;highlighter-rouge&quot;&gt;post(Runnable)&lt;/code&gt;的情况); 如果构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;那么交给该&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;处理, 否则回调&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还要注意的一点是从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;, 这是一个阻塞方法, 也就是说当&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中没有消息的时候, 会阻塞在这里, 直到&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中再次存储消息&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-总结&quot;&gt;六. 总结&lt;/h2&gt;

&lt;p&gt;到这里&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层面的运行机制我们就讲解完啦~ , 到这里我们对整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;的消息传递和处理机制也有了比较详细的了解了; 为加深记忆, 可以对着源码自己再过一遍过程~&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/15/Handler/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/15/Handler/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Linux开机启动流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux开机启动流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中实验基于&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;版本（&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.x&lt;/code&gt;版本都可以，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS7.x&lt;/code&gt;版本会有所区别）&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-启动流程&quot;&gt;一. 启动流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;开关电源（&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;）在开机之后将&lt;code class=&quot;highlighter-rouge&quot;&gt;AC&lt;/code&gt;信号转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;DC&lt;/code&gt;信号，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;会进行电压的检测，如果正常，&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;将会发送&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt; 信号给主板定时器，主板定时器接收到&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt;信号之后，将会停止发送&lt;code class=&quot;highlighter-rouge&quot;&gt;reset&lt;/code&gt;指令给&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;，这意味着电脑可以正常启动&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;的设置中有一些值是固定的，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;才知道从哪里开始读取指令，在&lt;code class=&quot;highlighter-rouge&quot;&gt;X86&lt;/code&gt;计算机中，第一条指令是&lt;code class=&quot;highlighter-rouge&quot;&gt; FFFF:0000h &lt;/code&gt;，指向&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;的最后一个字节，该指令因为只有一个字节，所以只是简单的包含一个跳转指令，该跳转指令指向的是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;所在的地址（&lt;code class=&quot;highlighter-rouge&quot;&gt;EPROM&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;中）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;就是基本输入输出系统，其功能主要有两个：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;POST：&lt;code class=&quot;highlighter-rouge&quot;&gt;Power On Self Test&lt;/code&gt;；硬件自检；即在&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中有一个硬件设备的列表，为了检测某一个硬件设备是否可用，就发送一个电脉冲给每一个设备，如果该脉冲被设备返回，说明设备可用，否则，不可用；如果有新的硬件接入，那么会使用同样的检测过程，同时会更新&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中的列表，用于下次启动过程&lt;/li&gt;
    &lt;li&gt;选择第一个启动设备：&lt;code class=&quot;highlighter-rouge&quot;&gt; BIOS&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;里面的记录的启动顺序以及上一步硬件自检过程中，设备的可用装态，确定最终的可启动设备顺序，具体的过程是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;将磁盘的第一扇区（磁盘最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节）载入内存，放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X0000:0X7C00&lt;/code&gt;处，然后检查这个扇区的最后两个字节是不是&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;，如果是则认为这是一个有效的启动扇区，如果不是就会尝试下一个启动介 质，如果找到可以启动的程序就会从这一介质启动，如果所有的启动介质都判断过后仍然没有找到可启动的程序那么&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;会给出错误提示&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 我们平时所说的更改&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;设置，实际上是错的，我们更改的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;中存储的设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中信息不能被用户改变，需要厂商提供闪存程序&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;MBR&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;确定好第一个启动设备之后，去该设备磁盘的第一个扇区读取最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节到内存（通过硬件的&lt;code class=&quot;highlighter-rouge&quot;&gt;INT 13&lt;/code&gt;中断功能来读取的），该&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;，即主引导记录；这&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节中有&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节才是正真的主引导加载代码（&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，即可以安装引导加载程序的地方），还有&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;字节用于存放磁盘分区表信息，以及最后两个字节用于校验（&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;)是否为有效的启动扇区；每个分区需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节用于存储分区的开始，结束位置，分区类型等（由于每个分区信息需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节，所以对于采用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;型分区结构的硬盘(其磁盘卷标类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;MS-DOS&lt;/code&gt;)，最多只能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个主要分区。所以对于一个采用此种分区结构的硬盘来说，想要得到&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个以上的主要分区是不可能的。这里就需要引出了扩展分区。扩展分区也是主分区（&lt;code class=&quot;highlighter-rouge&quot;&gt;Primary partition&lt;/code&gt;）的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;结构类似的扩展引导记录(&lt;code class=&quot;highlighter-rouge&quot;&gt;EBR&lt;/code&gt;) ）（&lt;code class=&quot;highlighter-rouge&quot;&gt; MBR&lt;/code&gt;分区方案无法支持超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;容量的磁盘。因为这一方案用&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节存储分区的总扇区数，最大能表示&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;次方的扇区个数，按每扇区&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节计算，每个分区最大不能超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，如果磁盘容量超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，那分区的起始位置 就无法表示了）&lt;/li&gt;
  &lt;li&gt;继续之前，我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;的信息，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;为例（后文不再声明），使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;dd if=/dev/sda of=mbr bs=512 count=1&lt;/code&gt;，将第一个扇区的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节内容转存到&lt;code class=&quot;highlighter-rouge&quot;&gt;mbr&lt;/code&gt;文件中，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt;表示大小；然后可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;file mbr&lt;/code&gt;来查看分区信息等，输出如下；其中&lt;code class=&quot;highlighter-rouge&quot;&gt;partition x&lt;/code&gt;表示第&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;个分区的信息，上面说了，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;时最多只能有四个分区，而且这四个分区中最多只能有一个活动分区，也就是下面被标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;active&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;partition 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 19451904 sectors; partition 2: ID=0x5, starthead 254, startsector 19455998, 2093058 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage1&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;中的前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节存储着引导加载程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;为例；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;有两个阶段（实际上应该是三个阶段，后面会解释），实际上这&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中存储的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;的第一阶段，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节的空间实在有限，做不了太多事情；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;第一阶段的作用主要是加载第二阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;实际上分为三个阶段：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1 -- stage1.5 -- stage2&lt;/code&gt;）&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;是存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中的引导加载程序；&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1.5&lt;/code&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;：扇区编号从0开始，但是真正的磁盘分区一般是从第63个扇区开始的，也就是说从1-63扇区是空闲的（第0个扇区存储&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;），这段空间叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;），因为&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;）存储于磁盘上，但是读取文件系统需要驱动，&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GA&lt;/code&gt;P中主要存储的就是读取文件系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;driver&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;读取该部分内容之后，就可以去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;grub&lt;/code&gt;配置文件，即&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage2&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件，主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;，这里我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.conf&lt;/code&gt;的内容，如下&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;：这个必须和下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;对应，在配置文件中有几个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;，启动的时候就会有几个菜单可以选择；&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;表示使用第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;选项来启动，&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;表示在读秒时间结束前都没有按键，则使用默认选项启动&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout=5&lt;/code&gt;：读秒时间，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;秒钟内没有按键，则使用默认选项启动；当然可以自行调整时间&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;splashimage=(hd0,0)/grub/splash.xpm.gz&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS&lt;/code&gt;启动的时候，后台不是黑白而是彩色变化的，就是这个文件提供的后台图示&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hidemenu&lt;/code&gt;：是否显示提示菜单，默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;hide&lt;/code&gt;的，但是笔者这里将这个选项注释掉了，在选择开机启动项的时候还会显示提示菜单&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;：这部分指定的是菜单选项，开机时有多少个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;就会有多少个菜单选项；每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;下的内容，一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;文件及设置，另一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;位置&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/grub_conf.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;加载：&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loade&lt;/code&gt;根据用户的选项，去加载相应的磁盘映像到内存，内核是一个压缩文件，解压缩后，内核会再一次进行测试与驱动周边设备；之后，内核需要去加载各个模块，&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;内核可以动态加载内核模块，这些内核模块放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;目录下，由于模块放置到磁盘根目录下，所以内核要去读取这些模块的话，需要挂载到根目录，这样才能读取内核模块加载驱动程序的功能，但是内核根本不认识&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘，所以需要加载&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘的驱动程序，否则根本无法挂载根目录，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;的驱动程序是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;内，这就出现了两难的问题，所以为了去挂载根目录，就出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;这个东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;initrd&lt;/strong&gt;：虚拟文件系统，一般位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/initrd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;在将内核加载到内存的同时，也会将&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;加载到内存中，并仿真成为一个根目录；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;的作用就是去加载必要的驱动，以便内核可以访问真正的根文件系统（如：磁盘控制器驱动，文件系统驱动（&lt;code class=&quot;highlighter-rouge&quot;&gt;ext3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt;等）），然后去挂载真正的根文件系统，进行根切换操作，用真正的根文件系统进行启动；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;完成上述任务之后，会清除掉自己在内存中的痕迹，让出空间&lt;/li&gt;
  &lt;li&gt;内核及其必要模块加载完毕之后，会主动执行第一个程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;，这也是第一个启动的进程；&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;的主要功能是根据其配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;）去准备软件的执行环境（系统服务等）；这里我们看一下其配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;的内容；如下；前面的注释是对该配置文件的描述，在笔者的该系统中，&lt;code class=&quot;highlighter-rouge&quot;&gt;inittab&lt;/code&gt;中只有一项配置，即运行级别（&lt;code class=&quot;highlighter-rouge&quot;&gt;runlevel&lt;/code&gt;）的设置，所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;的设置来启动不同的服务，让&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;的运行环境不同；至于&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;，分为七个等级：如下；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0 -- halt&lt;/code&gt;：系统直接关机&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 -- single user mode&lt;/code&gt;：单用户维护模式，用在系统出问题时的维护&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 -- Multi-user， without NFS&lt;/code&gt;：类似下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;，只是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;NFS&lt;/code&gt;服务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3 -- Full multi-user mode&lt;/code&gt;：完整含有网络功能的纯文本模式&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4 -- unused&lt;/code&gt;：系统保留功能&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5 -- X11&lt;/code&gt;：与&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;类似，但是加载使用&lt;code class=&quot;highlighter-rouge&quot;&gt;X Window&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6 -- reboot&lt;/code&gt;：重新启动&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里笔者将运行级别设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;，所以是以纯文本形式启动，即纯命令行模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/inittab.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;到这里系统就启动起来啦 ~ ，这也是系统启动的大致流程 ~&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-参考链接&quot;&gt;二. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;鸟哥私房菜基础学习篇第三版&lt;/li&gt;
  &lt;li&gt;https://www.slashroot.in/linux-booting-process-step-step-tutorial-understanding-linux-boot-sequence&lt;/li&gt;
  &lt;li&gt;https://www.linuxnix.com/linux-booting-process-explained/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Linux</category>
        
        <category>操作系统</category>
        
        
      </item>
    
  </channel>
</rss>
