<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 12 Dec 2018 21:58:57 +0800</pubDate>
    <lastBuildDate>Wed, 12 Dec 2018 21:58:57 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>ListView[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将从&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的基本使用入手, 介绍常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;性能优化问题&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;采用适配器模式, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的优化主要体现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;上; 本文也主要从&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;入手, 分析常见的优化问题&lt;/p&gt;

&lt;p&gt;文章代码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-最差版本&quot;&gt;一. 最差版本&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的性能问题主要是其通常用于展示大量数据造成的; 我们手指上下滑动的时候伴随着&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter.getView()&lt;/code&gt;方法的不断调用, &lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的主要作用是去解析&lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图, 但是这一过程是一个耗时操作, 如果每次滑动都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;的话, 势必会造成界面的卡顿, 如下即是这种情况: 每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 然后再&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;再进行设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 最差版本
class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view = mInflater.inflate(R.layout.item_main, parent, false)
        view.setOnClickListener{
            Toast.makeText(context,data[position],Toast.LENGTH_SHORT).show()
        }
        view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-优化一&quot;&gt;二. 优化一&lt;/h2&gt;

&lt;p&gt;为了避免每次滑动的时候都要&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;官方提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的缓存机制, 即将滑动出屏幕外面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;缓存下来, 因为通常情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;要展示的数据类型都是相同的, 所以可以复用同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;界面, 只是展示数据不同; 我们注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的参数中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;, 这个便是被缓存下来的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以我们第一次优化可以如下: 主要就是判断&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;是否为空, 如果为空, 说明没有缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 此时就需要去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 否则, 直接更改展示数据即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
            return view
        }
        convertView.apply {
            findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        }
        return convertView
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-优化二&quot;&gt;三. 优化二&lt;/h2&gt;

&lt;p&gt;到这里, 其实最耗时的部分已经被优化了, 那么我们是否还能够进行优化呢? 我们注意到每次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getView&lt;/code&gt;的时候, 虽然避免了每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 但是我们仍然每次都调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 那么这部分我们是否也可以避免掉呢, 当然是可以的, 此时我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;就派上用场啦~&lt;/p&gt;

&lt;p&gt;这里我们使用了一个内部类, 将每次&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById&lt;/code&gt;找到的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;保存下来, 因为我们前面说过了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;展示的时候, 通常数据类型都是相同的, 即界面相同, 只是每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示的数据不同而已, 因此也就没有必要每次都去执行一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;所做的主要的优化&lt;/p&gt;

&lt;p&gt;另外, 还需要提一下的是这里保存&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;, 其实我们还可以用这个&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存许多我们需要的值, 而不用局限与&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        var holder: MyViewHolder
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            holder = MyViewHolder(view)
            holder.textView.text = data[position]
            view.tag = holder
            return view
        }
        holder = convertView.tag as MyViewHolder
        holder.textView.text = data[position]
        return convertView
    }
    
    // 其他方法按照常规写, 故此省略
    ...

    class MyViewHolder(val view: View){
        val textView: TextView by lazy {
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-优化三&quot;&gt;四. 优化三&lt;/h2&gt;

&lt;p&gt;将异步操作放在子线程中执行; 其实这个也不算&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;自身特殊的优化, 而是由&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;自身特性所决定的&lt;/p&gt;

&lt;p&gt;如下; 当加载大图时, 使用异步的&lt;code class=&quot;highlighter-rouge&quot;&gt;AsyncTask&lt;/code&gt;去网络下载好后再展示到界面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(private val context: Context) : BaseAdapter() {

    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view: View = convertView ?: mInflater.inflate(R.layout.item_main, parent, false)
        val holder: ViewHolder = view.tag as ViewHolder? ?: ViewHolder(view)
        ImageLoader(holder).execute(ImageUrl.url[position])
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...

    class ImageLoader(private var holder: ViewHolder) : AsyncTask&amp;lt;String, Void, Bitmap&amp;gt;() {

        private val cache: LruCache&amp;lt;String, Bitmap&amp;gt; by lazy {
            val maxMemory = Runtime.getRuntime().maxMemory()
            val cacheSize = maxMemory / 8
            object: LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize.toInt()) {
                override fun sizeOf(key: String?, value: Bitmap?): Int {
                    return value?.allocationByteCount ?: 0
                }
            }
        }

        override fun doInBackground(vararg params: String?): Bitmap? {
            val urlStr = params[0]
            var bitmap = cache.get(urlStr)
            if (bitmap != null)
                return bitmap
            val url = URL(urlStr)
            var connection: HttpURLConnection? = null
            try {
                connection = url.openConnection() as HttpURLConnection
                connection.connectTimeout = 5000
                connection.readTimeout = 5000
                bitmap = BitmapFactory.decodeStream(connection.inputStream)
                cache.put(urlStr, bitmap)
            } catch (e: Exception) {
                Log.d(&quot;@HusterYP&quot;,&quot;error&quot;, e)
            } finally {
                connection?.disconnect()
            }
            return bitmap
        }

        override fun onPostExecute(result: Bitmap?) {
            holder.imageView.setImageBitmap(result)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码其实还有问题; 只是解决了异步加载, 但是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图的缓存复用, 当滑动的时候会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示图片不断改变的现象; 关于此问题的解决可以参见&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/45586553&quot;&gt;博客&lt;/a&gt; (&lt;strong&gt;注:&lt;/strong&gt; 上述代码图片&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;也来自该博客)&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>ListView</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;ListView笔记&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;问题: 展示大量数据, 处理内存开销和性能&lt;/p&gt;

&lt;p&gt;复用: 重新填写内容而已&lt;/p&gt;

&lt;p&gt;stable ID&lt;/p&gt;

&lt;p&gt;ListView相关内容:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView相关.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;getView():&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;错误的使用方式: 如下; 每次都会创建一个新的View视图(会去解析XML, 这是非常耗时的); 特别是当用户滑动的时候, 这种写法将产生大量的View视图&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Slow_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;正确的使用方式: 如下; 复用convertView; 但是下面这种写法也存在待优化的地方, 因为它每次都需要去findViewById(), 这点其实还可以改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Right_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最快的方式: 如下; 使用ViewHolder, 节省findViewById的时间; 还可以通过setTag()和getTag()来存储更多的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Fast_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;数据集更新的方式:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;notifyDataSetChanged()&lt;/li&gt;
    &lt;li&gt;notifiyDataSetInvalidated(): 表示数据集无效了&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;getViewType()和getViewTypeCount()&lt;/p&gt;

&lt;p&gt;可以通过设置Item的属性, enable或者disable, enable时Item可以被点击和选择, disable时不可被点击和选择; disable属性可以用于比如单纯的展示header展示等&lt;/p&gt;

&lt;p&gt;HeaderView和FooterView:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;listView.addHeaderView()&lt;/li&gt;
    &lt;li&gt;listView.addFooterView()&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;List Selector: 高亮选中Item&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;可以在xml中指定属性&lt;code class=&quot;highlighter-rouge&quot;&gt;android:drawSelectorOnTop = &quot;true&quot;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;创建一个XML的selector选择器&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;自定义ListView的背景的时候会出现问题貌似; 好像会出现在滑动的时候出现全是黑色的情况; 解决办法:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;xml中指定: &lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;#00000000&quot;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;@color/myBackgroundColor&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在ScrollView中嵌套ListView&lt;/p&gt;

&lt;p&gt;ListView中的Filter是什么?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;场景: 当我们要展示的条目很多时, 我们可以设置选项让用户选择查看哪些分类的选项, 而不是全部展示&lt;/li&gt;
    &lt;li&gt;将Adapter实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;接口即可(当Adapter继承的是BaseAdapter时, SimpleAdapter默认实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;对ListView设置Item的点击监听:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listView.setOnItemClickListener(new OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view,
        int position, long id) {
        Toast.makeText(getApplicationContext(),
            &quot;Click ListItem Number &quot; + position, Toast.LENGTH_LONG)
            .show();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取LayoutInflator可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以设置ListView没有数据时的占位View, 指定id为&lt;code class=&quot;highlighter-rouge&quot;&gt;@android:id/empty&lt;/code&gt;的View即可&lt;/p&gt;

&lt;h2 id=&quot;scrollview嵌套listview&quot;&gt;ScrollView嵌套ListView&lt;/h2&gt;

&lt;p&gt;问题: 只能显示一个Item(ListView不能全部展示)&lt;/p&gt;

&lt;h2 id=&quot;listview的item是scrollview&quot;&gt;ListView的Item是ScrollView&lt;/h2&gt;

&lt;p&gt;ListView性能优化官方文档: https://developer.android.com/training/improving-layouts/smooth-scrolling
性能优化官方推荐博客: https://android-developers.googleblog.com/2009/01/why-is-my-list-black-android.html&lt;/p&gt;

&lt;p&gt;ListView和大多数Android组件一样有透明背景, 也就意味这你可以看到Window的背景色; 但是当使用自定义ListView背景或者改变Window背景的话, 会出现问题;&lt;/p&gt;

&lt;p&gt;当ListView滑动时会依照不同的滑动方向来填充ListView; 比如从上往下填充或者从下往上填充;&lt;/p&gt;

&lt;p&gt;优化: 除了Demo中写的几个常见的优化外; ListView的性能优化其实就是使getView()方法更快而已&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;异步加载: 对于耗时资源在getView中去异步加载; 但是有一个问题是当快速滑动时, 此时需要去处理滑动时不加载的情况&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ListView  height设置wrap_content 导致getView()重复调用问题&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/08/ListView/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/08/ListView/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
      <item>
        <title>红黑树</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;红黑树&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;实现&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;红黑树是一颗平衡二叉树, 是为了避免二叉查找树在极端情况下形成单链表而表现出线性级别的时间复杂度; 红黑树的前身是&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树, 为了便于理解红黑树的各种旋转操作, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树&lt;/p&gt;

&lt;p&gt;平衡二叉树始终要保证的是所有空链接(指向一棵空树的链接)到根节点的距离相等&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-2-3查找树&quot;&gt;二. 2-3查找树&lt;/h2&gt;

&lt;h3 id=&quot;21-基本概念&quot;&gt;2.1 基本概念&lt;/h3&gt;

&lt;p&gt;为了保证树的平衡性, &lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树允许树中的一个节点保存多个键; 如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/RedBlackTree/2-3树.png&quot; alt=&quot;2-3查找树&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2-结点: 含有一个键(及其对应的值)和两条链接, 左链接指向的2-3树中的键都小于该结点, 右链接指向的2-3树中的键都大于该结点
3-结点: 含有两个键(及其对应的值)和三条链接, 左链接指向的2-3树中的键都小于该结点, 右链接指向的2-3树中的键都大于该结点, 中链接指向的2-3树中的键介于该结点之间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一棵完美平衡的&lt;code class=&quot;highlighter-rouge&quot;&gt;2-3&lt;/code&gt;查找树中的所有空链接到根结点的距离都是相同的&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;22-2-3树的插入&quot;&gt;2.2 2-3树的插入&lt;/h3&gt;

&lt;h4 id=&quot;221-向2-结点中插入新键&quot;&gt;2.2.1 向2-结点中插入新键&lt;/h4&gt;

&lt;p&gt;这种情况比较简单, 直接将2-结点替换为3-结点即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/RedBlackTree/2-结点插入新键.png&quot; alt=&quot;2-结点插入新键&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/06/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>AwesomeAndroid</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录一些有趣的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;知识, 内容不限~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;子线程更新ui&quot;&gt;子线程更新UI&lt;/h2&gt;

&lt;p&gt;考虑如下代码:&lt;/p&gt;

&lt;p&gt;注: &lt;code class=&quot;highlighter-rouge&quot;&gt;MainActivity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Layout&lt;/code&gt;布局只有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;main_text&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        initView()
    }

    private fun initView() {
//        Thread { main_text.text = &quot;World&quot; }.start() // 更新UI成功
        Thread {
            sleep(200)
            main_text.text = &quot;World&quot; // 更新UI失败(崩溃0)
        }.start()
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上代码中, 在第二个子线程中跟新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;的时候失败了, 报错: &lt;code class=&quot;highlighter-rouge&quot;&gt;Only the original thread that created a view hierarchy can touch its views&lt;/code&gt;; 即常见的不能在子线程中更新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;; 但是在第一个子线程中跟新&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;成功了, 原因是: 线程的检查是在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;checkThread()&lt;/code&gt;中, 但是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;中, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;还没有创建, 所以此时无法&lt;code class=&quot;highlighter-rouge&quot;&gt;checkThread()&lt;/code&gt;, 实际上, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;的创建是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;方法回调之后, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;WindowManagerGlobal&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;addView&lt;/code&gt;中创建的; 所以如果这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;initView&lt;/code&gt;即使是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;中调用也是同样的现象&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/24/AwesomeAndroid/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/24/AwesomeAndroid/</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>Note</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录各类笔记, 包括各类优秀文章收集, 资料收集等!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-git&quot;&gt;一. Git&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d4d5e07ea0cd&quot;&gt;超赞的Git操作讲解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二-android&quot;&gt;二. Android&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://qq634421026.github.io/2017/06/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/&quot;&gt;Android面试&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/18/Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/18/Note/</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>FFmpeg交叉编译与接入Android工程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要讲解如何在&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;上编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;, 以及将编译出来的动态库(&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;)接入已有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-ffmpeg交叉编译&quot;&gt;一. FFmpeg交叉编译&lt;/h2&gt;

&lt;p&gt;本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg 4.0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android-ndk-r15c&lt;/code&gt;, 注意在编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;时, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本有要求, 另外, 笔者最开始选用最新版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 总是编译不过, 去查证了一下, 发现从&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk-r16&lt;/code&gt;开始, 其用于交叉编译都有问题了, 所以选用较低版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk&lt;/code&gt;; 本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本和&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本亲测可编译通过; 先提供下载地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ffmpeg.org/releases/ffmpeg-4.0.tar.bz2&quot;&gt;FFmpeg 4.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dl.google.com/android/repository/android-ndk-r15c-linux-x86_64.zip&quot;&gt;Android-ndk-r15c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;笔者选用的编译环境是&lt;code class=&quot;highlighter-rouge&quot;&gt;ArchLinux&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;上的编译的话, 大体流程不变, 环境配置需要自己弄啦~&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下相关知识:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;JNI和NDK&lt;/li&gt;
    &lt;li&gt;CPU架构&lt;/li&gt;
    &lt;li&gt;交叉编译&lt;/li&gt;
    &lt;li&gt;FFmpeg简介&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里推荐&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/&quot;&gt;官方文档&lt;/a&gt;, 对以上方面讲解比较详细; 下面简要介绍重点地方&lt;/p&gt;

&lt;h3 id=&quot;11-基础知识&quot;&gt;1.1 基础知识&lt;/h3&gt;

&lt;h4 id=&quot;111-jni和ndk&quot;&gt;1.1.1 JNI和NDK&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Native Interface&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层通信的接口; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;可以实现和其他语言之间的互相调用(注意其他语言不仅仅只限于&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;, 虽然大多时候是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是跨平台的, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;不是跨平台的, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;也使得&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;需要考虑和特定平台相关的特性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native Development Kit&lt;/code&gt;, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;平台提供的一个工具集, 提供与本地代码之间的交互&lt;/p&gt;

&lt;p&gt;详细可参见&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/73250163&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;112-cpu架构&quot;&gt;1.1.2 CPU架构&lt;/h4&gt;

&lt;p&gt;不同的手机使用不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;有不同的指令集, 每种&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;及其指令集有其自己的应用程序二进制接口(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application Binary Interface&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;定义了机器代码与系统运行时的交互方式; &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;与指令集的对应关系如下表(摘自官方文档)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/ABI与指令集对应关系.png&quot; alt=&quot;ABI与指令集对应关系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构有&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;等(&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;也是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的), 其中, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;主要是针对&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;端, &lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;主要针对移动端; &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;系统目前支持&lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv7&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv8&lt;/code&gt;, ` x86&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;x86_64&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;MIPS&lt;code class=&quot;highlighter-rouge&quot;&gt;以及&lt;/code&gt;MIPS64&lt;code class=&quot;highlighter-rouge&quot;&gt;共七种&lt;/code&gt;CPU`架构&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中应用安装时, &lt;code class=&quot;highlighter-rouge&quot;&gt;Package Manager Service&lt;/code&gt;会去扫描&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;, 只有该设备&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构支持的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件才会被安装, 另外还可以定义&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件的对应安装优先级&lt;/p&gt;

&lt;h4 id=&quot;113-交叉编译&quot;&gt;1.1.3 交叉编译&lt;/h4&gt;

&lt;p&gt;在某个平台上编译该平台上的可执行文件叫本地编译; 如果在一个平台上编译在其他平台上的可执行程序则叫交叉编译; 交叉编译是随着嵌入式系统的发展而发展的, 因为嵌入式系统的处理能力, 内存等均有限, 所以有时候需要在其他平台上编译好后导入嵌入式系统中, 此时就需要交叉编译&lt;/p&gt;

&lt;p&gt;交叉编译最主要的是环境, 即交叉编译链; 对本文来说, 编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;需要准备&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;中提供了交叉编译链; 即&lt;code class=&quot;highlighter-rouge&quot;&gt;android-ndk-r15c/toolchains/&lt;/code&gt;下提供的各种平台相关的编译工具链&lt;/p&gt;

&lt;p&gt;本文使用的示例是在&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;下编译&lt;code class=&quot;highlighter-rouge&quot;&gt;arm-v7a&lt;/code&gt;架构的动态库&lt;/p&gt;

&lt;h4 id=&quot;114-ffmpeg&quot;&gt;1.1.4 FFmpeg&lt;/h4&gt;

&lt;p&gt;推荐&lt;a href=&quot;https://ffmpeg.org/ffmpeg-formats.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://javapyer.iteye.com/blog/1989274&quot;&gt;基本用法&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;12-ffmpeg交叉编译&quot;&gt;1.2 FFmpeg交叉编译&lt;/h3&gt;

&lt;p&gt;在开始之前需要先配置一下&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;的环境变量, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/profile&lt;/code&gt;文件中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;编译生成的动态库默认格式为&lt;code class=&quot;highlighter-rouge&quot;&gt;xx.so.版本号&lt;/code&gt;, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程中只支持以&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;结尾的动态库, 所以需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;的配置文件, 修改其生成库文件名的格式; 编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt;文件, 修改如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将configure文件中的：
SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'
SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'

#替换为：
SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'
SLIB_INSTALL_LINKS='$(SLIBNAME)'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了减小&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;大小, 我们只将需要的功能开启即可; 配置参数较多, 我们写一个脚本如下(名为&lt;code class=&quot;highlighter-rouge&quot;&gt;build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 下面的注释在运行脚本时需删除~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;NDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/yuanping/Software/NDK/android-ndk-r15c  &lt;span class=&quot;c&quot;&gt;# NDK所在路径, 注意替换为你的&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SYSROOT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/platforms/android-19/arch-arm/
&lt;span class=&quot;nv&quot;&gt;TOOLCHAIN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 &lt;span class=&quot;c&quot;&gt;# 交叉编译链, 这里使用的是arm, 如果需要编译其他平台的, 更换即可&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;build_one
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
./configure &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PREFIX&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-shared&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-static&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# 禁止生成静态库&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-doc&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关闭不需要的功能, 下同&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffplay&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffprobe&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-doc&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-symver&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffmpeg&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-small&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--cross-prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TOOLCHAIN&lt;/span&gt;/bin/arm-linux-androideabi- &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--target-os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-cross-compile&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--sysroot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$SYSROOT&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--extra-cflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-Os -fpic &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--extra-ldflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_LDFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ADDITIONAL_CONFIGURE_FLAG&lt;/span&gt;
make clean all
make &lt;span class=&quot;nt&quot;&gt;-j3&lt;/span&gt;
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-a &lt;span class=&quot;c&quot;&gt;# CPU架构&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/android/&lt;span class=&quot;nv&quot;&gt;$CPU&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库所在路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-marm&quot;&lt;/span&gt;
build_one
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后运行该脚本即可, 注意添加可执行权限(&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod a+x build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;等待一会应该就好啦, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;android&lt;/code&gt;目录, 生成的动态库就在其中啦~; 笔者生成的如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/armv7-a.png&quot; alt=&quot;Armv7-a&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-动态库接入android工程&quot;&gt;二. 动态库接入Android工程&lt;/h2&gt;

&lt;p&gt;在开始接入之前, 需要先配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;的环境; 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;SDK Manager&lt;/code&gt;中下载&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LLDB&lt;/code&gt;; 这里可以不用下载&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 最好使用与编译版本一致的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 以免出现兼容性问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/SDKManager.png&quot; alt=&quot;SDKManager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;路径, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/NDKPath.png&quot; alt=&quot;NDK路径&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;项目接入&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;有两种方法, 一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;配置文件来指定; 另一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ndk-build&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Application.mk&lt;/code&gt;配置文件来指定; 官方推荐使用第一种; 关于第二种接入方式, 可以参见&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot;&gt;官方文档&lt;/a&gt;配置&lt;/p&gt;

&lt;p&gt;这里主要讲解第一种方式, 参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是创建的新项目的话, 可以直接在创建项目的时候选择&lt;code class=&quot;highlighter-rouge&quot;&gt;include C++  surpport&lt;/code&gt;, 如下图; 如果项目已经创建了, 也不要紧, 下面讲解的就是这种情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI新项目.png&quot; alt=&quot;JNI新项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们先来看一下完整的目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI目录结构.png&quot; alt=&quot;目录结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;目录下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;目录(其他目录名也可以, 但是要注意后文的更改), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;目录, 将上面编译好的&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a/lib&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg/armeabi-v7a&lt;/code&gt;下(新建&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;目录, 注意目录名一定要是&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构对应), 需要注意的是生成的动态链接库中有一些不带版本号的是指向另一个待版本号的软链接, 如下举例的两个&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;文件, 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec.so&lt;/code&gt;文件是软链接, 指向&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec-58.so&lt;/code&gt;, 所以拷贝时不需要拷贝这些软链接咯&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/动态链接库.png&quot; alt=&quot;动态链接库&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再将&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;文件夹拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;下; 创建好后目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建jni目录.png&quot; alt=&quot;创建jni目录&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt;目录下创建&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;(一定要是这个名字咯), 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建CMakeLists.png&quot; alt=&quot;创建CMakeLists&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.4.1) # cmake最低版本

add_library( # Sets the name of the library.
             wlffmpeg

             # Sets the library as a shared library.
             SHARED

             # Provides a relative path to your source file(s).
             src/main/jni/ffmpeg/player.c )

add_library( avcodec-58  # 库名字
             SHARED
             IMPORTED)
set_target_properties( avcodec-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavcodec-58.so) 

add_library( avdevice-58
             SHARED
             IMPORTED)
set_target_properties( avdevice-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavdevice-58.so)

add_library( avfilter-7
             SHARED
             IMPORTED)
set_target_properties( avfilter-7
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavfilter-7.so)

add_library( avformat-58
             SHARED
             IMPORTED)
set_target_properties( avformat-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavformat-58.so)

add_library( avutil-56
             SHARED
             IMPORTED)
set_target_properties( avutil-56
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavutil-56.so)

add_library( swresample-3
             SHARED
             IMPORTED)
set_target_properties( swresample-3
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswresample-3.so)

add_library( swscale-5
             SHARED
             IMPORTED)
set_target_properties( swscale-5
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswscale-5.so)


find_library( # Sets the name of the path variable.
              log-lib  # Android内置的log模块, 用于将JNI层的log打到AS控制台

              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )

include_directories(src/main/jni/ffmpeg/include)

target_link_libraries( # Specifies the target library.  # 链接

                       wlffmpeg  
                       avcodec-58
                       avdevice-58
                       avfilter-7
                       avformat-58
                       avutil-56
                       swresample-3
                       swscale-5

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib} )

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;配置可以参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在模块级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;下配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android {
    ...
    defaultConfig {
        ...
        externalNativeBuild {
            cmake {
                cppFlags &quot;&quot; 
            }
            ndk {
                abiFilters &quot;armeabi-v7a&quot; # 指定CPU架构
            }
        }
        sourceSets {
            main {
                jniLibs.srcDirs = ['src/main/jni/ffmpeg']  # 指定jni路径
            }
        }
    }
    externalNativeBuild {
        cmake {
            path 'CMakeLists.txt' # 指定cmake的配置文件路径
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg.java&lt;/code&gt;类, 使用静态代码块加载动态链接库, 定义&lt;code class=&quot;highlighter-rouge&quot;&gt;native&lt;/code&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;, 如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FFmpeg {
    static {
        System.loadLibrary(&quot;avutil-56&quot;);
        System.loadLibrary(&quot;swresample-3&quot;);
        System.loadLibrary(&quot;avcodec-58&quot;);
        System.loadLibrary(&quot;avformat-58&quot;);
        System.loadLibrary(&quot;swscale-5&quot;);
        System.loadLibrary(&quot;avfilter-7&quot;);
        System.loadLibrary(&quot;avdevice-58&quot;);
        System.loadLibrary(&quot;wlffmpeg&quot;); // 注意不要忘了加载这个库
    }

    public native void playMyMedia(String url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;上快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt;Alt + Enter&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;create function xxx&lt;/code&gt;, 可以自动创建对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件, 当然该&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件也可以自命名, 此处命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;的完整代码如下: 该代码摘自&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;jni.h&amp;gt;
#include &quot;libavformat/avformat.h&quot;
#include &amp;lt;android/log.h&amp;gt;
#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);  // 输出到AS的log中
#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);

JNIEXPORT void JNICALL
Java_com_gif_ping_jnidemo_FFmpeg_playMyMedia(JNIEnv *env, jobject instance, jstring url_) {
    const char *url = (*env)-&amp;gt;GetStringUTFChars(env, url_, 0);
    LOGI(&quot;url:%s&quot;, url);
    av_register_all();
    AVCodec *c_temp = av_codec_next(NULL);
    while (c_temp != NULL)
    {
        switch (c_temp-&amp;gt;type)
        {
            case AVMEDIA_TYPE_VIDEO:
                LOGI(&quot;[Video]:%s&quot;, c_temp-&amp;gt;name);
                break;
            case AVMEDIA_TYPE_AUDIO:
                LOGI(&quot;[Audio]:%s&quot;, c_temp-&amp;gt;name);
                break;
            default:
                LOGI(&quot;[Other]:%s&quot;, c_temp-&amp;gt;name);
                break;
        }
        c_temp = c_temp-&amp;gt;next;
    }
    (*env)-&amp;gt;ReleaseStringUTFChars(env, url_, url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;MainActivity&lt;/code&gt;中使用, 也比较简单; 注意添加网络权限, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;中就可以看到输出的视频信息啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {

    FFmpeg mFFmpeg;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
    }

    private void init() {
        mFFmpeg = new FFmpeg();
        mFFmpeg.playMyMedia(&quot;http://video.xxx&quot;); // 随便找一个视频url啦~
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里, 项目应该就能跑起来啦~&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程参见&lt;a href=&quot;https://github.com/HusterYP/JNIDemo&quot;&gt;JNIDemo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;编译参见: https://github.com/HusterYP/FFmpeg&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-参考链接&quot;&gt;三. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@karthikcodes1999/cross-compiling-ffmpeg-4-0-for-android-b988326f16f2&quot;&gt;Cross Compiling FFmpeg 4.0 for Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yhaolpz/article/details/76408829&quot;&gt;Android 集成 FFmpeg (一) 基础知识及简单调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;Android Studio通过cmake创建FFmpeg项目&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>进程与线程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作系统之进程与线程总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-进程&quot;&gt;一. 进程&lt;/h2&gt;

&lt;p&gt;定义: 一个运行中的程序&lt;/p&gt;

&lt;p&gt;进程和程序的区别: 一个进程是某种类型的活动, 它有程序, 输入, 输出以及状态, 如果一个程序运行了两遍, 则算作两个进程&lt;/p&gt;

&lt;p&gt;进程地址空间见下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程地址空间.png&quot; alt=&quot;进程地址空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内核模式和用户模式的实现: 通常是用某个控制寄存器中的一个模式位实现的&lt;/p&gt;

&lt;p&gt;进程有三种状态: 运行态, 就绪态, 阻塞态; 其相互之间的切换见下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程状态切换.png&quot; alt=&quot;进程状态切换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;子进程的回收: 当一个进程由于某种原因终止时, 内核并不是立即把它从系统中清除, 相反, 进程被保持在已终止的状态, 知道被它的父进程回收, 一个终止但还未被回收的进程称为僵死进程, 即使僵死进程没有运行, 他们仍然消耗系统的内存资源; 如果一个父进程终止了, 内核会安排&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;进程成为它的孤儿进程的养父&lt;/p&gt;

&lt;h3 id=&quot;11-进程创建fork&quot;&gt;1.1 进程创建–fork()&lt;/h3&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;可以创建进程, 新创建的子进程与父进程几乎但不是完全相同的, 子进程得到与父进程用户级虚拟地址空间相同(但是独立)的副本, 包括代码和数据段, 堆, 共享库以及用户栈, 子进程还获得与父进程任何打开文件描述符相同的副本, 这就意味着当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, 子进程可以读写父进程中打开的任何文件; 其最大的区别就是具有不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;UID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通常子进程会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execve&lt;/code&gt;或一个相同的系统调用以修改其内存映像并运行一个新的程序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;函数调用一次但是返回两次, 一次是在父进程中, 另一次是在新创建的子进程中, 参见一下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main() 
{
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0) // 子进程
    {
        printf(&quot;Child: x = %d\n&quot;, ++x); 
        exit(0);
    }
    printf(&quot;Parent: x = %d\n&quot;, --x); // 父进程
    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出(注意由于并发不定性, 所以输出顺序不定):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent: x = 0
Child: x = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意理解上述程序:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;调用一次, 返回两次&lt;/li&gt;
    &lt;li&gt;并发执行&lt;/li&gt;
    &lt;li&gt;相同但是独立的地址空间: 写时复制; 子进程共享父进程的所有内存, 但这块内存通过写时复制共享, 这意味着一旦两者之一想要修改部分内存, 则这块内存首先被明确的复制, 以确保修改发生在私有内存区域&lt;/li&gt;
    &lt;li&gt;共享文件: 当运行这个程序时, 我们注意到父进程和子进程都把他们的输出显示到屏幕上, 原因是子进程继承了父进程所有的打开文件, 当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;文件是打开的, 并指向屏幕, 子进程继承了这个文件, 因此它的输出也是指向屏幕的(&lt;strong&gt;注意理解此处&lt;/strong&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-进程间通信&quot;&gt;1.2 进程间通信&lt;/h3&gt;

&lt;h4 id=&quot;121-如何保证临界区互斥&quot;&gt;1.2.1 如何保证临界区互斥&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;屏蔽中断: 在单处理器系统中, 最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断, 并在要离开之前再打开中断&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;严格的轮换法: 自旋锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Peterson&lt;/code&gt;解法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令: 测试并加锁; 读字和写字操作保证是不可分割的, 即该指令结束之前其他处理器均不允许访问该内存字; 执行&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;锁住内存总线, 以禁止其他&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;在本指令结束之前访问内存(原子操作的更底层解释)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;122-生产者消费者问题&quot;&gt;1.2.2 生产者消费者问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;信号量: 用一个整型变量来累计唤醒次数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define N 100 // 缓冲区的槽数目
typedef int semaphore; // 信号量是一种特殊类型的整型数据
semaphore mutex = 1; // 控制对临界区的访问
semaphore empty = N; // 计数缓冲区的空槽数目
semaphore full = 0; // 计数缓冲区的满槽数目

void producer(void)
{   
    int item;

    while(true)
    {   
        item = produce_item();
        down(&amp;amp;empty); // 将空槽数目减一; 注意理解, 若交换这里两个down操作的顺序, 可能会造成死锁
        down(&amp;amp;mutex); // 进入临界区
        insert_item(item);
        up(&amp;amp;mutex); // 离开临界区
        up(&amp;amp;full); // 将满槽数目加一
    }
}

void consumer(void)
{
    int item;

    while(true)
    {
        down(&amp;amp;full);
        down(&amp;amp;mutex);
        item = remove_item();
        up(&amp;amp;mutex);
        up(&amp;amp;empty);
        comsume_item(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;互斥量: 没有计数能力, 可以处于两态之一: 解锁和加锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管程: 一个管程是一个由过程, 变量以及数据等组成的一个集合, 它们组成一个特殊的模块或软件包, 进程可以在任何需要的时候调用管程中的过程, 但是不能在管程之外声明的过程中直接访问管程内的数据结构&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/管程.png&quot; alt=&quot;管程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入管程的互斥由编译器负责, 但通常的做法是用一个互斥量或二元信号量&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;避免锁: 读-复制-更新&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-调度&quot;&gt;1.3 调度&lt;/h3&gt;

&lt;p&gt;进程切换做的工作: 首先用户态切换到内核态, 然后保存当前进程的状态, 包括在进程表中存储器值; 在许多系统中, 内存映像(如: 页表内内存访问位)也必须保存, 接着, 通过运行调度程序选择一个新进程, 之后, 将该新进程的内存映像装进&lt;code class=&quot;highlighter-rouge&quot;&gt;MMU&lt;/code&gt;, 最后新进程开始运行; 除此之外, 进程切换还要使整个内存高速缓存失效, 强迫缓存从内存中动态重新装入两次(进入内核一次, 离开内核一次)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/上下文切换.png&quot; alt=&quot;上下文切换&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;131-调度时机&quot;&gt;1.3.1 调度时机&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么时候调度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新进程之后, 决定是运行子进程还是父进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个进程退出时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个进程阻塞在&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;和信号量上或由于其他原因阻塞时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;中断时&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;132-调度策略&quot;&gt;1.3.2 调度策略&lt;/h4&gt;

&lt;p&gt;有三种环境:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;批处理&lt;/li&gt;
    &lt;li&gt;交互式&lt;/li&gt;
    &lt;li&gt;实时&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;批处理&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;先来先服务&lt;/li&gt;
    &lt;li&gt;最短作业优先&lt;/li&gt;
    &lt;li&gt;最短剩余时间优先&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;交互式&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;轮转调度: 时间分片; 维护一个进程队列, 用完时间片后, 排到队列末尾&lt;/li&gt;
    &lt;li&gt;优先级调度&lt;/li&gt;
    &lt;li&gt;多级队列&lt;/li&gt;
    &lt;li&gt;最短进程优先&lt;/li&gt;
    &lt;li&gt;保证调度&lt;/li&gt;
    &lt;li&gt;彩票调度&lt;/li&gt;
    &lt;li&gt;公平分享调度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;133-读者-写者问题&quot;&gt;1.3.3 读者-写者问题&lt;/h4&gt;

&lt;p&gt;实现目标是: 可以多个读者&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以数据库为例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int semaphore;
semaphore mutex = 1; 
semaphore db = 1; // 控制对数据库的访问
int rc = 0; // 正在读或者即将读的进程数目

void reader(void)
{
    while(true)
    {
        down(&amp;amp;mutex); // 获得对rc的互斥访问权
        rc = rc + 1; // 多了一个读者
        if (rc == 1) // 如果是第一个读者
            down(&amp;amp;db);
        up(&amp;amp;mutex);
        read_data_base(); // 访问数据
        down(&amp;amp;mutex);
        rc = rc - 1; // 减少了一个读者
        if (rc == 0) // 如果是最后一个读者
            up(&amp;amp;db); 
        up(&amp;amp;mutex);
        use_data_read(); // 非临界区
    }
}

void writer(void) 
{   
    while(true)
    {
        think_up_data(); // 非临界区
        down(&amp;amp;db); // 获取互斥访问
        write_data_basae(); // 更新数据
        up(&amp;amp;db); // 释放互斥访问
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-线程&quot;&gt;二. 线程&lt;/h2&gt;

&lt;p&gt;为什么要使用线程:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;并行实体拥有共享同一个地址空间和所有可用数据的能力, 这是多进程无法表达的&lt;/li&gt;
    &lt;li&gt;线程比进程更轻量级, 它们比进程更容易创建, 也更容易撤销&lt;/li&gt;
    &lt;li&gt;若多个线程都是&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;密集型的, 那么并不能获得性能上的增强(考虑调度消耗时间), 但是如果存在大量的计算和大量的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;处理, 拥有多个线程允许这些活动彼此重叠进行, 从而会加快应用程序执行的速度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在线程中有一个程序计数器, 用来记录接着要执行哪一条指令, 线程拥有寄存器, 用来保存线程当前的工作变量, 线程还拥有一个堆栈, 其中每一帧保存了一个已调用的但是还没有从中返回的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/线程与进程.png&quot; alt=&quot;线程与进程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程用于把资源集中到一起, 而线程则是在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;上被调度执行的实体(资源管理的单位是进程)&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java并发[三]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解锁等高级主题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-死锁及其避免&quot;&gt;一. 死锁及其避免&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;死锁出现的原因通常是出现锁环路造成的, 不管是显示的还是隐式的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过定义获取锁的顺序来避免死锁: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;System.identityHashCode(object)&lt;/code&gt;来返回一个锁对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.hashCode()&lt;/code&gt;的返回值; 通过这个值来定义锁的顺序, 并在整个应用程序中都按照这个顺序来获取锁, 那么就不会形成锁环路了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Object fromAcct = new Object(); // 这里的锁对象也可以是其他
        Object toAcct = new Object();
        Object tieLock = new Object();
        int fromHash = System.identityHashCode(fromAcct);
        int toHash = System.identityHashCode(toAcct);
        if (fromHash &amp;lt; toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    // doSomething
                }
            }
        } else if (fromHash &amp;gt; toHash) {
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    // doSomething
                }
            }
        } else { // 这种情况主要是避免Hash冲突, 此时需要额外的锁
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        // doSomething
                    }
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用开放调用(如果在调用某个方法时, 不需要持有锁, 那么这种调用就被成为开放调用)避免死锁: 这种情况下适用于持有不同锁的方法之间的相互调用(注意锁的级别是在方法上, 而不是代码块上)(相当于形成一个隐式的环); 将锁从方法上转移到需要同步的内部代码块上可以避免死锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock.tryLock()&lt;/code&gt;: 可以检测死锁和从死锁中恢复过来; 即指定一个超时时限, 在等待超过该时间后&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock()&lt;/code&gt;会返回一个失败信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的几点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;对象分配操作的开销比同步的开销更低(实际上, 现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;的分配操作已经比&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;调用更快&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的以前实现中(现在实现不同咯)采用分段锁, 使用了一个包含&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个锁的数组, 每个锁保护散列桶的&lt;code class=&quot;highlighter-rouge&quot;&gt;1/16&lt;/code&gt;, 这样就能够支持多达&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个并发的写入器; &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;将对每个分段进行枚举并将每个分段中的元素数量相加, 而不是维护一个全局计数, 为了避免枚举每个计数, &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;为每个分段都维护了一个独立的计数, 并通过每个分段的锁来维护这个值(这个地方有两点需要注意: 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算是在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作都会改变一次, 这样虽然增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;的操作, 但是这会使得&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算从&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;; 另一个是为每个分段维护一个&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 而不是使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 如果使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的话, ,实际上就破坏了分段锁的分段特性, 因为访问共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的时候, 需要同步)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 09 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[二]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要讲解了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;框架&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-executor框架&quot;&gt;一. Executor框架&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程池: 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Executors&lt;/code&gt;中的静态工厂方法之一来创建一个线程池&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newFixedThreadPool&lt;/code&gt;: 创建一个固定长度的线程池, 每当提交一个任务时就创建一个线程, 直到达到线程池的最大数量, 这是线程池规模将不再变化(如果某个线程发生异常终止, 那么线程池会补充一个线程)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newCachedThreadPool&lt;/code&gt;: 创建一个可缓存的线程池, 如果线程池的当前规模超过了处理需求时, 那么将回收空闲的线程, 而当需求增加时, 则可以添加新的线程, 线程池的规模不存在任何限制&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;: 一个单线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;, 它创建单个工作者线程来执行任务, 如果这个线程异常结束, 会创建另一个线程来代替;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;能确保依照任务在队列中的顺序来执行(如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LIFO&lt;/code&gt;, 优先级)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newScheduledThreadPool&lt;/code&gt;: 创建了一个固定长度的线程池, 而且以延迟或定时的方式来执行任务, 类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;生命周期: 为了解决执行服务的生命周期问题, &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;扩展了&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;接口; &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;的生命周期有三种状态: 运行, 关闭, 已终止; 提供了如下方法:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt;: 执行平缓的关闭过程, 不再接受新任务, 同时等待已经提交的任务执行完成(包括那些还未开始执行的任务)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow()&lt;/code&gt;: 执行粗暴的关闭过程, 尝试取消所有运行中的任务, 并且不再启动队列中尚未开始执行的任务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;awaitTermination()&lt;/code&gt;: 等待&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;到达终止状态, 或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;isTerminated()&lt;/code&gt;来轮循是否已经终止&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;延迟任务与周期任务: &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;ScheduleThreadPoolExecutor&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;: 在执行所有定时任务时只会创建一个线程, 如果某个任务执行时间过长, 那么将破坏其他&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;的定时精确性; &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;线程并不捕获异常, 因此当&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;抛出未检查异常时将终止定时线程&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序, 运行&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;秒之后结束, 而不是运行&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;秒; 同时还会抛出异常&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class OutOfTime {
    public static void main(String[] args) throws InterruptedException {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 5);
        SECONDS.sleep(5);
    }

    public static class ThrowTask extends TimerTask {

        @Override
        public void run() {
            throw new RuntimeException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;携带结果的任务&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;任务主入口点(即&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;)将返回一个值, 并可能抛出一个异常&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;: 表示一个任务的生命周期, 并提供了相应的方法来判断是否已经完成或取消, 以及获取任务的结果和取消任务等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;二者区别参见其提供方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-中断&quot;&gt;二. 中断&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;有三个中断方法: &lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupted()&lt;/code&gt;, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;能中断目标线程, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupt()&lt;/code&gt;能返回目标线程的中断状态, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;将清除当前线程的中断状态并返回它之前的值; 这也是清除中断状态的唯一方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阻塞库方法, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.wait()&lt;/code&gt;等, 都检查线程何时中断, 它们在响应中断时执行的操作包括: 清除中断状态, 抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;并不意味着立即停止目标线程正在进行的工作, 而只是传递了请求中断的消息(由线程自己去决定如何处理中断)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中断是实现取消最合理的方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;响应中断:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;传递异常&lt;/li&gt;
        &lt;li&gt;恢复中断状态&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;不可阻塞中断: 许多可阻塞的方法都是通过提前返回或者抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;来响应中断请求的; 但是并非所有的可阻塞方法或者阻塞机制都能响应中断, 有如下两种情况:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当线程执行同步的&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket I/O&lt;/code&gt;时&lt;/li&gt;
    &lt;li&gt;等待获得内置锁而阻塞时: 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;类中提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;lockInterruptibly&lt;/code&gt;方法来允许在等待一个锁的同时仍能响应中断&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-守护线程&quot;&gt;三. 守护线程&lt;/h2&gt;

&lt;p&gt;线程可以分为两种: 普通线程和守护线程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;启动时创建的所有线程中, ,除了主线程以外, 其他的线程都是守护线程(例如垃圾回收器以及其他执行辅助工作的线程); 当创建一个新线程时, 新线程将继承它的线程的守护状态&lt;/p&gt;

&lt;p&gt;普通线程与守护线程的区别仅在于当线程退出时发生的操作, 当一个线程退出时, &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会检查其他正在运行的线程, 如果这些线程都是守护线程, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会正常退出操作, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;停止时, 所有仍然存在的守护线程都将被抛弃–既不会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finally&lt;/code&gt;代码块, 也不会执行回卷栈, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;只是直接退出&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java并发编程实战第一部分总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;先检查后执行&lt;/strong&gt;: 首先观察到某个条件为真(例如文件X不存在), 然后根据这个观察结果采用相应的动作(创建文件X), 但事实上, 在你观察到这个结果以及开始穿件文件之间, 观察结果可能变得无效(另一个线程创建了文件X), 从而导致各种问题(未预期异常, 数据被覆盖, 文件被破坏等)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象都可以用作一个实现同步的锁, 这些锁被称为内置锁或监视锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要在构造过程中使&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用逸出: 当且仅当对象的构造函数返回时, 对象才处于可预测的和一致的状态, 因此, 当从对象的构造函数中发布对象时, 只是发布了一个尚未构造完成的对象, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出, 那么这种对象就被认为是不正确的构造; 常见场景是:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在构造函数中创建线程: 在构造函数中创建线程并没有错, 但是最好不要立即启动它&lt;/li&gt;
    &lt;li&gt;在构造函数中注册事件监听: 依据是非静态内部类会持有外部类的引用&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() { // this逸出
            public void onEvent(Event e) { 
                doSomething(); 
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用静态工厂方法来防止&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething();
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener listener = new SafeListener();
        source.registerListener(listener.listener);
        return listener;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;一个正确构造的对象可以通过以下方式来安全的发布:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;在静态初始化函数中初始化一个对象引用&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的域或者&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicReferance&lt;/code&gt;对象中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到某个正确构造对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;类型域中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到一个由锁保护的域中&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要安全的发布一个静态构造的对象, 最简单和安全的方式是使用静态的初始化器: 静态初始化器由&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;在类的初始化阶段执行, 由于在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;内部存在着同步机制, 因此通过这种方式初始化的任何对象都可以被安全的发布&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Holder holder = new Holder();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-synchronized&quot;&gt;二. synchronized&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;使用的是对象锁, 修饰方法, 代码块或局部执行代码时, 使用的是当前锁对象; 修饰静态方法时, 使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;XX.class&lt;/code&gt;锁对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内置锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)可重入; 可重入: 如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功, 而不会造成死锁
考虑如下代码, 子类改写了父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;方法, 然后调用父类中的方法, 此时如果没有可重入的锁, 那么这段代码将产生死锁&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
    public synchronized void doSomething() {
        System.out.println(&quot;Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public synchronized void doSomething() {
        System.out.println(&quot;LoggingWidget&quot;);
        super.doSomething();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;不能被继承:
    &lt;blockquote&gt;
      &lt;p&gt;1、子类继承父类时, 如果没有重写父类中的同步方法, 子类同一对象, 在不同线程并发调用该方法时, 具有同步效果&lt;/p&gt;
      &lt;ol&gt;
        &lt;li&gt;子类继承父类, 并且重写父类中的同步方法,但没有添加关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;, 子类同一对象, 在不同线程并发调用该方法时, 不再具有同步效果&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Widget {
    public synchronized void doSomething() {
        System.out.println(Thread.currentThread() + &quot; Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public void doSomething() { // 这里没有加synchronized
        System.out.println(Thread.currentThread() + &quot; LoggingWidget&quot;); // 由于子类的doSomething()没有加synchronized方法, 所以子类的doSomething()不可同步
        super.doSomething(); // 但是父类的doSomething()仍可同步
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-volatile&quot;&gt;三. volatile&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量用来确保将变量的更新操作通知到其他线程; 当把变量声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型后, 不会将该变量上的操作与其他内存操作一起重排序, &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量不会被缓存在寄存器或者对其他处理器不可见的地方, 因此在读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的变量总会返回最新写入的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前大多数处理器架构上, 读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销只比读取非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销略高一些&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;变量(&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位), &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;允许将&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位的读操作或写操作分解为两个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位的操作; 当读取一个非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;变量时, 如果对该变量的读操作和写操作在不同线程中执行, 那么很可能会读取到某个值的高&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位和另一个值的低&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位; 因此, 即使不考虑失效数据问题, 在多线程中使用共享且可变的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;等类型的变量也是不安全的, 除非用&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;来声明他们, 或者用锁保护起来&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-同步工具类&quot;&gt;四. 同步工具类&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步工具类可以根据其自身的状态来协调线程的控制流; 可以用作同步工具类的如: 阻塞队列, 信号量(Semaphore), 栅栏(Barrier), 闭锁(Latch)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;41-阻塞队列-blockingqueue&quot;&gt;4.1 阻塞队列-BlockingQueue&lt;/h3&gt;

&lt;p&gt;阻塞队列提供了可阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法, 以及支持定时的&lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt;方法, 如果队列已经满了, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法将阻塞直到有空间可用; 如果队列为空, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法将阻塞直到有元素可用(实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;循环不断插入元素和获取元素, 以及结合信号量来实现的阻塞)&lt;/p&gt;

&lt;p&gt;常用的接口&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现有: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayBlockingQueue&lt;/code&gt;, 这两个是&lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;队列, 分别与&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;类似; 还有一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt;, 是一个优先级队列, 可以按照元素的自然顺序来排列, 也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;来排列(如果它们实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;方法); 最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现是&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;, 实际上它不是一个真正的队列, 因为它不会为队列中元素维护存储空间, 与其他队列不同的是, 它维护一组线程,
这些线程在等待这把元素加入或移出队列, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;没有存储功能, 因此&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;会一直阻塞, 直到有另一个线程已经准备好参与到交付过程中, 仅当有足够多的消费者, 并且总是有一个消费者准备好获取交付工作时, 才适合使用同步队列&lt;/p&gt;

&lt;p&gt;这里再提一下&lt;strong&gt;双端队列&lt;/strong&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Deque&lt;/code&gt;(可以在队列头和队列尾高效插入和移除), 具体实现包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingDeque&lt;/code&gt;; 双端队列适用于工作密取, 即每个消费者都有自己的双端队列, 如果一个消费者完成了自己双端队列的全部工作, 那么它可以从其他消费者双端队列末尾秘密的获取工作(因为可以首尾插入和获取, 所以互不影响)&lt;/p&gt;

&lt;h3 id=&quot;42-闭锁&quot;&gt;4.2 闭锁&lt;/h3&gt;

&lt;h4 id=&quot;421-countdownlatch&quot;&gt;4.2.1 CountDownLatch&lt;/h4&gt;

&lt;p&gt;作用: 可以延迟线程的进度直到其到达终止状态; 闭锁的作用相当于一扇门: 在闭锁到达结束状态之前, 这扇门一直是关闭的, 并且没有任何线程能通过, 当到达结束状态时, 这扇门会打开并允许所有的线程通过; 当闭锁到达结束状态后, 将不再改变状态, 因此这扇门永远保持打开状态; 闭锁可以用来确保某些活动直到其他活动都完成后才继续进行(可以使一个或多个线程等待一组事件发生)&lt;/p&gt;

&lt;p&gt;闭锁状态包括一个计数器, 该计数器被初始化为一个正数, 表示需要等待的事件数量, &lt;code class=&quot;highlighter-rouge&quot;&gt;countDown&lt;/code&gt;递减计数器 , 表示有一个事件已经发生了, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法等待计数器达到零, 这表示所有需要等待的事件都已发生; 如果计数器值非零, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;会一直阻塞直到计数器为零, 或者等待中的线程中断, 或者等待超时&lt;/p&gt;

&lt;p&gt;用法参见下列程序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class LatchTest {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i &amp;lt; nThreads; i++) {
            Thread t = new Thread(() -&amp;gt; {
                try {
                    startGate.await(); // 等待所有线程准备完毕
                    task.run();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    endGate.countDown();
                }
            });
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown(); // 执行到这里, 说明所有线程准备好了, 可以开始执行了
        endGate.await(); // 主线程等待任务执行完毕
        long end = System.nanoTime();
        return end - start;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;422-futuretask&quot;&gt;4.2.2 FutureTask&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FutureTask&lt;/code&gt;也可以用作闭锁, 相当于一种可生成结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future.get()&lt;/code&gt;: 如果任务已经完成, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;会立即返回结果, 否则&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;将阻塞直到任务进入完成状态, 然后返回结果或者抛出异常&lt;/p&gt;

&lt;p&gt;基本使用参见如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FutureTest {
    private final FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;String&amp;gt;(new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            // 耗时操作
            return &quot;Hello&quot;;
        }
    });

    private final Thread thread = new Thread(futureTask);

    public void start() { // 不要在构造函数中构造和start线程: 参见上文安全发布
        thread.start();
    }

    public String get() throws ExecutionException, InterruptedException {
        return futureTask.get(); // 阻塞直到结束或者异常
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-信号量-semaphore&quot;&gt;4.3 信号量-Semaphore&lt;/h3&gt;

&lt;p&gt;计数信号量用来控制同时访问某个特定资源的操作数量, 或者同时执行某个指定操作的数量&lt;/p&gt;

&lt;p&gt;计算信号量的一种就简化形式是二值信号量, 即初始值为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;, 二值信号量可以用作互斥体, 并具备不可重入的加锁语义: 谁拥有这个唯一的许可, 谁就拥有了互斥锁&lt;/p&gt;

&lt;p&gt;使用信号量实现有界阻塞容器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BoundedHashSet&amp;lt;T&amp;gt; {
    private final Set&amp;lt;T&amp;gt; set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        set = Collections.synchronizedSet(new HashSet&amp;lt;T&amp;gt;());
        sem = new Semaphore(bound);
    }

    public boolean add(T t) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(t);
            return wasAdded;
        } finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(T o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;44-栅栏-barrier&quot;&gt;4.4 栅栏-Barrier&lt;/h3&gt;

&lt;p&gt;栅栏类似于闭锁, 它能阻塞一组线程直到某个事件发生, 栅栏与闭锁的关键区别在于, 所有线程必须同时到达栅栏位置, 才能继续执行, 闭锁用于等待事件, 而栅栏用于等待其他线程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;可以使一定数量的参与方反复的在栅栏位置汇集, 它在并行迭代算法中非常有用; 当线程到达栅栏位置时将调用&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法, 这个方法将阻塞直到所有线程都到达栅栏位置; 如果所有线程都到达了栅栏位置, 那么栅栏将打开, 此时所有线程都被释放, 而栅栏将被重置以便下次使用; 如果对&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用超时, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;阻塞的线程被中断, 那么栅栏就被认为是打破了, 所有阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用都将终止并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;BrokenBarrierException&lt;/code&gt;; 如果成功通过栅栏, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;将为每个线程返回一个唯一到达索引号;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;还可以使你将一个栅栏操作传递给构造函数, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 当成功通过栅栏时会(在一个子任务线程中)执行它, 但在阻塞线程被释放之前是不能执行的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-遗留&quot;&gt;五. 遗留&lt;/h2&gt;

&lt;p&gt;Vector, Hashtable, CopyOnWriteArrayList(写入时复制: Copy-On-Write), CopyOnWriteArraySet, BlockingQueue, ConcurrentLinkedQueue, PriorityQueue
Deque: ArrayDeque, LinkedBlockingDeque&lt;/p&gt;

&lt;p&gt;三个interrupt()理解&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
