<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 18 Nov 2018 16:41:43 +0800</pubDate>
    <lastBuildDate>Sun, 18 Nov 2018 16:41:43 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Note</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;记录各类笔记, 包括各类优秀文章收集, 资料收集等!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-git&quot;&gt;一. Git&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/d4d5e07ea0cd&quot;&gt;超赞的Git操作讲解&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/18/Note/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/18/Note/</guid>
        
        <category>Note</category>
        
        
      </item>
    
      <item>
        <title>FFmpeg交叉编译与接入Android工程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要讲解如何在&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;上编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;, 以及将编译出来的动态库(&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;)接入已有的&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-ffmpeg交叉编译&quot;&gt;一. FFmpeg交叉编译&lt;/h2&gt;

&lt;p&gt;本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg 4.0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android-ndk-r15c&lt;/code&gt;, 注意在编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;时, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本有要求, 另外, 笔者最开始选用最新版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 总是编译不过, 去查证了一下, 发现从&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk-r16&lt;/code&gt;开始, 其用于交叉编译都有问题了, 所以选用较低版本的&lt;code class=&quot;highlighter-rouge&quot;&gt;Androud-ndk&lt;/code&gt;; 本文选用的&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;版本和&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;版本亲测可编译通过; 先提供下载地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ffmpeg.org/releases/ffmpeg-4.0.tar.bz2&quot;&gt;FFmpeg 4.0&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://dl.google.com/android/repository/android-ndk-r15c-linux-x86_64.zip&quot;&gt;Android-ndk-r15c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;笔者选用的编译环境是&lt;code class=&quot;highlighter-rouge&quot;&gt;ArchLinux&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;上的编译的话, 大体流程不变, 环境配置需要自己弄啦~&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下相关知识:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;JNI和NDK&lt;/li&gt;
    &lt;li&gt;CPU架构&lt;/li&gt;
    &lt;li&gt;交叉编译&lt;/li&gt;
    &lt;li&gt;FFmpeg简介&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里推荐&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/&quot;&gt;官方文档&lt;/a&gt;, 对以上方面讲解比较详细; 下面简要介绍重点地方&lt;/p&gt;

&lt;h3 id=&quot;11-基础知识&quot;&gt;1.1 基础知识&lt;/h3&gt;

&lt;h4 id=&quot;111-jni和ndk&quot;&gt;1.1.1 JNI和NDK&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Native Interface&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层通信的接口; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;可以实现和其他语言之间的互相调用(注意其他语言不仅仅只限于&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;, 虽然大多时候是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是跨平台的, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;不是跨平台的, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;也使得&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;需要考虑和特定平台相关的特性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native Development Kit&lt;/code&gt;, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;平台提供的一个工具集, 提供与本地代码之间的交互&lt;/p&gt;

&lt;p&gt;详细可参见&lt;a href=&quot;https://blog.csdn.net/carson_ho/article/details/73250163&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;112-cpu架构&quot;&gt;1.1.2 CPU架构&lt;/h4&gt;

&lt;p&gt;不同的手机使用不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;有不同的指令集, 每种&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;及其指令集有其自己的应用程序二进制接口(&lt;code class=&quot;highlighter-rouge&quot;&gt;Application Binary Interface&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;); &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;定义了机器代码与系统运行时的交互方式; &lt;code class=&quot;highlighter-rouge&quot;&gt;ABI&lt;/code&gt;与指令集的对应关系如下表(摘自官方文档)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/ABI与指令集对应关系.png&quot; alt=&quot;ABI与指令集对应关系&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构有&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;等(&lt;code class=&quot;highlighter-rouge&quot;&gt;x86-64&lt;/code&gt;也是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的), 其中, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;主要是针对&lt;code class=&quot;highlighter-rouge&quot;&gt;PC&lt;/code&gt;端, &lt;code class=&quot;highlighter-rouge&quot;&gt;arm&lt;/code&gt;主要针对移动端; &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;系统目前支持&lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv7&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ARMv8&lt;/code&gt;, ` x86&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;x86_64&lt;code class=&quot;highlighter-rouge&quot;&gt;, &lt;/code&gt;MIPS&lt;code class=&quot;highlighter-rouge&quot;&gt;以及&lt;/code&gt;MIPS64&lt;code class=&quot;highlighter-rouge&quot;&gt;共七种&lt;/code&gt;CPU`架构&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中应用安装时, &lt;code class=&quot;highlighter-rouge&quot;&gt;Package Manager Service&lt;/code&gt;会去扫描&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;, 只有该设备&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构支持的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件才会被安装, 另外还可以定义&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件的对应安装优先级&lt;/p&gt;

&lt;h4 id=&quot;113-交叉编译&quot;&gt;1.1.3 交叉编译&lt;/h4&gt;

&lt;p&gt;在某个平台上编译该平台上的可执行文件叫本地编译; 如果在一个平台上编译在其他平台上的可执行程序则叫交叉编译; 交叉编译是随着嵌入式系统的发展而发展的, 因为嵌入式系统的处理能力, 内存等均有限, 所以有时候需要在其他平台上编译好后导入嵌入式系统中, 此时就需要交叉编译&lt;/p&gt;

&lt;p&gt;交叉编译最主要的是环境, 即交叉编译链; 对本文来说, 编译&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;需要准备&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;中提供了交叉编译链; 即&lt;code class=&quot;highlighter-rouge&quot;&gt;android-ndk-r15c/toolchains/&lt;/code&gt;下提供的各种平台相关的编译工具链&lt;/p&gt;

&lt;p&gt;本文使用的示例是在&lt;code class=&quot;highlighter-rouge&quot;&gt;x86&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;下编译&lt;code class=&quot;highlighter-rouge&quot;&gt;arm-v7a&lt;/code&gt;架构的动态库&lt;/p&gt;

&lt;h4 id=&quot;114-ffmpeg&quot;&gt;1.1.4 FFmpeg&lt;/h4&gt;

&lt;p&gt;推荐&lt;a href=&quot;https://ffmpeg.org/ffmpeg-formats.html&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://javapyer.iteye.com/blog/1989274&quot;&gt;基本用法&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;12-ffmpeg交叉编译&quot;&gt;1.2 FFmpeg交叉编译&lt;/h3&gt;

&lt;p&gt;在开始之前需要先配置一下&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;的环境变量, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/profile&lt;/code&gt;文件中添加&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;编译生成的动态库默认格式为&lt;code class=&quot;highlighter-rouge&quot;&gt;xx.so.版本号&lt;/code&gt;, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程中只支持以&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;结尾的动态库, 所以需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;的配置文件, 修改其生成库文件名的格式; 编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt;文件, 修改如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 将configure文件中的：
SLIBNAME_WITH_MAJOR='$(SLIBNAME).$(LIBMAJOR)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_VERSION)'
SLIB_INSTALL_LINKS='$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)'

#替换为：
SLIBNAME_WITH_MAJOR='$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)'
LIB_INSTALL_EXTRA_CMD='$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;'
SLIB_INSTALL_NAME='$(SLIBNAME_WITH_MAJOR)'
SLIB_INSTALL_LINKS='$(SLIBNAME)'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了减小&lt;code class=&quot;highlighter-rouge&quot;&gt;APK&lt;/code&gt;大小, 我们只将需要的功能开启即可; 配置参数较多, 我们写一个脚本如下(名为&lt;code class=&quot;highlighter-rouge&quot;&gt;build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注: 下面的注释在运行脚本时需删除~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;NDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/yuanping/Software/NDK/android-ndk-r15c  &lt;span class=&quot;c&quot;&gt;# NDK所在路径, 注意替换为你的&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;SYSROOT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/platforms/android-19/arch-arm/
&lt;span class=&quot;nv&quot;&gt;TOOLCHAIN&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$NDK&lt;/span&gt;/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64 &lt;span class=&quot;c&quot;&gt;# 交叉编译链, 这里使用的是arm, 如果需要编译其他平台的, 更换即可&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;function &lt;/span&gt;build_one
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
./configure &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$PREFIX&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-shared&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-static&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;&lt;span class=&quot;c&quot;&gt;# 禁止生成静态库&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-doc&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 关闭不需要的功能, 下同&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffplay&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffprobe&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-doc&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-symver&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--disable-ffmpeg&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-small&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--cross-prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$TOOLCHAIN&lt;/span&gt;/bin/arm-linux-androideabi- &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--target-os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;linux &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;arm &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--enable-cross-compile&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--sysroot&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$SYSROOT&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--extra-cflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-Os -fpic &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--extra-ldflags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$ADDI_LDFLAGS&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ADDITIONAL_CONFIGURE_FLAG&lt;/span&gt;
make clean all
make &lt;span class=&quot;nt&quot;&gt;-j3&lt;/span&gt;
make &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;CPU&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-a &lt;span class=&quot;c&quot;&gt;# CPU架构&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;/android/&lt;span class=&quot;nv&quot;&gt;$CPU&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# 生成动态库所在路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ADDI_CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-marm&quot;&lt;/span&gt;
build_one
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之后运行该脚本即可, 注意添加可执行权限(&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod a+x build-script.sh&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;等待一会应该就好啦, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg&lt;/code&gt;目录下有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;android&lt;/code&gt;目录, 生成的动态库就在其中啦~; 笔者生成的如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/armv7-a.png&quot; alt=&quot;Armv7-a&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-动态库接入android工程&quot;&gt;二. 动态库接入Android工程&lt;/h2&gt;

&lt;p&gt;在开始接入之前, 需要先配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Android Studio&lt;/code&gt;的环境; 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;SDK Manager&lt;/code&gt;中下载&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LLDB&lt;/code&gt;; 这里可以不用下载&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 最好使用与编译版本一致的&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;, 以免出现兼容性问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/SDKManager.png&quot; alt=&quot;SDKManager&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置&lt;code class=&quot;highlighter-rouge&quot;&gt;NDK&lt;/code&gt;路径, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/NDKPath.png&quot; alt=&quot;NDK路径&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;项目接入&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;有两种方法, 一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;配置文件来指定; 另一种是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ndk-build&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Android.mk&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Application.mk&lt;/code&gt;配置文件来指定; 官方推荐使用第一种; 关于第二种接入方式, 可以参见&lt;a href=&quot;https://developer.android.google.cn/ndk/guides/android_mk&quot;&gt;官方文档&lt;/a&gt;配置&lt;/p&gt;

&lt;p&gt;这里主要讲解第一种方式, 参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是创建的新项目的话, 可以直接在创建项目的时候选择&lt;code class=&quot;highlighter-rouge&quot;&gt;include C++  surpport&lt;/code&gt;, 如下图; 如果项目已经创建了, 也不要紧, 下面讲解的就是这种情况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI新项目.png&quot; alt=&quot;JNI新项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们先来看一下完整的目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/JNI目录结构.png&quot; alt=&quot;目录结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;目录下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;目录(其他目录名也可以, 但是要注意后文的更改), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;jni&lt;/code&gt;下创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;目录, 将上面编译好的&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a/lib&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt;文件拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;工程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg/armeabi-v7a&lt;/code&gt;下(新建&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;目录, 注意目录名一定要是&lt;code class=&quot;highlighter-rouge&quot;&gt;armeabi-v7a&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;架构对应), 需要注意的是生成的动态链接库中有一些不带版本号的是指向另一个待版本号的软链接, 如下举例的两个&lt;code class=&quot;highlighter-rouge&quot;&gt;so&lt;/code&gt;文件, 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec.so&lt;/code&gt;文件是软链接, 指向&lt;code class=&quot;highlighter-rouge&quot;&gt;libavcodec-58.so&lt;/code&gt;, 所以拷贝时不需要拷贝这些软链接咯&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/动态链接库.png&quot; alt=&quot;动态链接库&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再将&lt;code class=&quot;highlighter-rouge&quot;&gt;android/armv7-a&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt;文件夹拷贝到&lt;code class=&quot;highlighter-rouge&quot;&gt;ffmpeg&lt;/code&gt;下; 创建好后目录结构如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建jni目录.png&quot; alt=&quot;创建jni目录&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt;目录下创建&lt;code class=&quot;highlighter-rouge&quot;&gt;CMakeLists.txt&lt;/code&gt;(一定要是这个名字咯), 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/FFmpegCompile/创建CMakeLists.png&quot; alt=&quot;创建CMakeLists&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内容如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.4.1) # cmake最低版本

add_library( # Sets the name of the library.
             wlffmpeg

             # Sets the library as a shared library.
             SHARED

             # Provides a relative path to your source file(s).
             src/main/jni/ffmpeg/player.c )

add_library( avcodec-58  # 库名字
             SHARED
             IMPORTED)
set_target_properties( avcodec-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavcodec-58.so) 

add_library( avdevice-58
             SHARED
             IMPORTED)
set_target_properties( avdevice-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavdevice-58.so)

add_library( avfilter-7
             SHARED
             IMPORTED)
set_target_properties( avfilter-7
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavfilter-7.so)

add_library( avformat-58
             SHARED
             IMPORTED)
set_target_properties( avformat-58
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavformat-58.so)

add_library( avutil-56
             SHARED
             IMPORTED)
set_target_properties( avutil-56
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libavutil-56.so)

add_library( swresample-3
             SHARED
             IMPORTED)
set_target_properties( swresample-3
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswresample-3.so)

add_library( swscale-5
             SHARED
             IMPORTED)
set_target_properties( swscale-5
                       PROPERTIES IMPORTED_LOCATION
                       ${CMAKE_SOURCE_DIR}/src/main/jni/ffmpeg/armeabi-v7a/libswscale-5.so)


find_library( # Sets the name of the path variable.
              log-lib  # Android内置的log模块, 用于将JNI层的log打到AS控制台

              # Specifies the name of the NDK library that
              # you want CMake to locate.
              log )

include_directories(src/main/jni/ffmpeg/include)

target_link_libraries( # Specifies the target library.  # 链接

                       wlffmpeg  
                       avcodec-58
                       avdevice-58
                       avfilter-7
                       avformat-58
                       avutil-56
                       swresample-3
                       swscale-5

                       # Links the target library to the log library
                       # included in the NDK.
                       ${log-lib} )

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;CMake&lt;/code&gt;配置可以参见&lt;a href=&quot;https://developer.android.com/studio/projects/configure-cmake&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在模块级别的&lt;code class=&quot;highlighter-rouge&quot;&gt;build.gradle&lt;/code&gt;下配置:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android {
    ...
    defaultConfig {
        ...
        externalNativeBuild {
            cmake {
                cppFlags &quot;&quot; 
            }
            ndk {
                abiFilters &quot;armeabi-v7a&quot; # 指定CPU架构
            }
        }
        sourceSets {
            main {
                jniLibs.srcDirs = ['src/main/jni/ffmpeg']  # 指定jni路径
            }
        }
    }
    externalNativeBuild {
        cmake {
            path 'CMakeLists.txt' # 指定cmake的配置文件路径
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;FFmpeg.java&lt;/code&gt;类, 使用静态代码块加载动态链接库, 定义&lt;code class=&quot;highlighter-rouge&quot;&gt;native&lt;/code&gt;方法&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;, 如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FFmpeg {
    static {
        System.loadLibrary(&quot;avutil-56&quot;);
        System.loadLibrary(&quot;swresample-3&quot;);
        System.loadLibrary(&quot;avcodec-58&quot;);
        System.loadLibrary(&quot;avformat-58&quot;);
        System.loadLibrary(&quot;swscale-5&quot;);
        System.loadLibrary(&quot;avfilter-7&quot;);
        System.loadLibrary(&quot;avdevice-58&quot;);
        System.loadLibrary(&quot;wlffmpeg&quot;); // 注意不要忘了加载这个库
    }

    public native void playMyMedia(String url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;playMyMedia()&lt;/code&gt;上快捷键&lt;code class=&quot;highlighter-rouge&quot;&gt;Alt + Enter&lt;/code&gt;选择&lt;code class=&quot;highlighter-rouge&quot;&gt;create function xxx&lt;/code&gt;, 可以自动创建对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件, 当然该&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;文件也可以自命名, 此处命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;player.c&lt;/code&gt;的完整代码如下: 该代码摘自&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;jni.h&amp;gt;
#include &quot;libavformat/avformat.h&quot;
#include &amp;lt;android/log.h&amp;gt;
#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);  // 输出到AS的log中
#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,&quot;HusterYP&quot;,FORMAT,##__VA_ARGS__);

JNIEXPORT void JNICALL
Java_com_gif_ping_jnidemo_FFmpeg_playMyMedia(JNIEnv *env, jobject instance, jstring url_) {
    const char *url = (*env)-&amp;gt;GetStringUTFChars(env, url_, 0);
    LOGI(&quot;url:%s&quot;, url);
    av_register_all();
    AVCodec *c_temp = av_codec_next(NULL);
    while (c_temp != NULL)
    {
        switch (c_temp-&amp;gt;type)
        {
            case AVMEDIA_TYPE_VIDEO:
                LOGI(&quot;[Video]:%s&quot;, c_temp-&amp;gt;name);
                break;
            case AVMEDIA_TYPE_AUDIO:
                LOGI(&quot;[Audio]:%s&quot;, c_temp-&amp;gt;name);
                break;
            default:
                LOGI(&quot;[Other]:%s&quot;, c_temp-&amp;gt;name);
                break;
        }
        c_temp = c_temp-&amp;gt;next;
    }
    (*env)-&amp;gt;ReleaseStringUTFChars(env, url_, url);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;MainActivity&lt;/code&gt;中使用, 也比较简单; 注意添加网络权限, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt;中就可以看到输出的视频信息啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class MainActivity extends AppCompatActivity {

    FFmpeg mFFmpeg;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        init();
    }

    private void init() {
        mFFmpeg = new FFmpeg();
        mFFmpeg.playMyMedia(&quot;http://video.xxx&quot;); // 随便找一个视频url啦~
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里, 项目应该就能跑起来啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-参考链接&quot;&gt;三. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://medium.com/@karthikcodes1999/cross-compiling-ffmpeg-4-0-for-android-b988326f16f2&quot;&gt;Cross Compiling FFmpeg 4.0 for Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yhaolpz/article/details/76408829&quot;&gt;Android 集成 FFmpeg (一) 基础知识及简单调用&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ywl5320/article/details/75136986&quot;&gt;Android Studio通过cmake创建FFmpeg项目&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 17 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/17/FFmpeg%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E6%8E%A5%E5%85%A5Android%E5%B7%A5%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>进程与线程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;操作系统之进程与线程总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-进程&quot;&gt;一. 进程&lt;/h2&gt;

&lt;p&gt;定义: 一个运行中的程序&lt;/p&gt;

&lt;p&gt;进程和程序的区别: 一个进程是某种类型的活动, 它有程序, 输入, 输出以及状态, 如果一个程序运行了两遍, 则算作两个进程&lt;/p&gt;

&lt;p&gt;进程地址空间见下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程地址空间.png&quot; alt=&quot;进程地址空间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内核模式和用户模式的实现: 通常是用某个控制寄存器中的一个模式位实现的&lt;/p&gt;

&lt;p&gt;进程有三种状态: 运行态, 就绪态, 阻塞态; 其相互之间的切换见下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/进程状态切换.png&quot; alt=&quot;进程状态切换&quot; /&gt;&lt;/p&gt;

&lt;p&gt;子进程的回收: 当一个进程由于某种原因终止时, 内核并不是立即把它从系统中清除, 相反, 进程被保持在已终止的状态, 知道被它的父进程回收, 一个终止但还未被回收的进程称为僵死进程, 即使僵死进程没有运行, 他们仍然消耗系统的内存资源; 如果一个父进程终止了, 内核会安排&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;进程成为它的孤儿进程的养父&lt;/p&gt;

&lt;h3 id=&quot;11-进程创建fork&quot;&gt;1.1 进程创建–fork()&lt;/h3&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;可以创建进程, 新创建的子进程与父进程几乎但不是完全相同的, 子进程得到与父进程用户级虚拟地址空间相同(但是独立)的副本, 包括代码和数据段, 堆, 共享库以及用户栈, 子进程还获得与父进程任何打开文件描述符相同的副本, 这就意味着当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, 子进程可以读写父进程中打开的任何文件; 其最大的区别就是具有不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;UID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通常子进程会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;execve&lt;/code&gt;或一个相同的系统调用以修改其内存映像并运行一个新的程序&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;函数调用一次但是返回两次, 一次是在父进程中, 另一次是在新创建的子进程中, 参见一下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int main() 
{
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0) // 子进程
    {
        printf(&quot;Child: x = %d\n&quot;, ++x); 
        exit(0);
    }
    printf(&quot;Parent: x = %d\n&quot;, --x); // 父进程
    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出(注意由于并发不定性, 所以输出顺序不定):&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parent: x = 0
Child: x = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意理解上述程序:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;调用一次, 返回两次&lt;/li&gt;
    &lt;li&gt;并发执行&lt;/li&gt;
    &lt;li&gt;相同但是独立的地址空间: 写时复制; 子进程共享父进程的所有内存, 但这块内存通过写时复制共享, 这意味着一旦两者之一想要修改部分内存, 则这块内存首先被明确的复制, 以确保修改发生在私有内存区域&lt;/li&gt;
    &lt;li&gt;共享文件: 当运行这个程序时, 我们注意到父进程和子进程都把他们的输出显示到屏幕上, 原因是子进程继承了父进程所有的打开文件, 当父进程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt;时, &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;文件是打开的, 并指向屏幕, 子进程继承了这个文件, 因此它的输出也是指向屏幕的(&lt;strong&gt;注意理解此处&lt;/strong&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-进程间通信&quot;&gt;1.2 进程间通信&lt;/h3&gt;

&lt;h4 id=&quot;121-如何保证临界区互斥&quot;&gt;1.2.1 如何保证临界区互斥&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;屏蔽中断: 在单处理器系统中, 最简单的方法是使每个进程在刚刚进入临界区后立即屏蔽所有中断, 并在要离开之前再打开中断&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁变量&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;严格的轮换法: 自旋锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Peterson&lt;/code&gt;解法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令: 测试并加锁; 读字和写字操作保证是不可分割的, 即该指令结束之前其他处理器均不允许访问该内存字; 执行&lt;code class=&quot;highlighter-rouge&quot;&gt;TSL&lt;/code&gt;指令的&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;锁住内存总线, 以禁止其他&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;在本指令结束之前访问内存(原子操作的更底层解释)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;122-生产者消费者问题&quot;&gt;1.2.2 生产者消费者问题&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;信号量: 用一个整型变量来累计唤醒次数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define N 100 // 缓冲区的槽数目
typedef int semaphore; // 信号量是一种特殊类型的整型数据
semaphore mutex = 1; // 控制对临界区的访问
semaphore empty = N; // 计数缓冲区的空槽数目
semaphore full = 0; // 计数缓冲区的满槽数目

void producer(void)
{   
    int item;

    while(true)
    {   
        item = produce_item();
        down(&amp;amp;empty); // 将空槽数目减一; 注意理解, 若交换这里两个down操作的顺序, 可能会造成死锁
        down(&amp;amp;mutex); // 进入临界区
        insert_item(item);
        up(&amp;amp;mutex); // 离开临界区
        up(&amp;amp;full); // 将满槽数目加一
    }
}

void consumer(void)
{
    int item;

    while(true)
    {
        down(&amp;amp;full);
        down(&amp;amp;mutex);
        item = remove_item();
        up(&amp;amp;mutex);
        up(&amp;amp;empty);
        comsume_item(item);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;互斥量: 没有计数能力, 可以处于两态之一: 解锁和加锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管程: 一个管程是一个由过程, 变量以及数据等组成的一个集合, 它们组成一个特殊的模块或软件包, 进程可以在任何需要的时候调用管程中的过程, 但是不能在管程之外声明的过程中直接访问管程内的数据结构&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/管程.png&quot; alt=&quot;管程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入管程的互斥由编译器负责, 但通常的做法是用一个互斥量或二元信号量&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;避免锁: 读-复制-更新&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-调度&quot;&gt;1.3 调度&lt;/h3&gt;

&lt;p&gt;进程切换做的工作: 首先用户态切换到内核态, 然后保存当前进程的状态, 包括在进程表中存储器值; 在许多系统中, 内存映像(如: 页表内内存访问位)也必须保存, 接着, 通过运行调度程序选择一个新进程, 之后, 将该新进程的内存映像装进&lt;code class=&quot;highlighter-rouge&quot;&gt;MMU&lt;/code&gt;, 最后新进程开始运行; 除此之外, 进程切换还要使整个内存高速缓存失效, 强迫缓存从内存中动态重新装入两次(进入内核一次, 离开内核一次)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/上下文切换.png&quot; alt=&quot;上下文切换&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;131-调度时机&quot;&gt;1.3.1 调度时机&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;什么时候调度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个新进程之后, 决定是运行子进程还是父进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在一个进程退出时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当一个进程阻塞在&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;和信号量上或由于其他原因阻塞时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;中断时&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;132-调度策略&quot;&gt;1.3.2 调度策略&lt;/h4&gt;

&lt;p&gt;有三种环境:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;批处理&lt;/li&gt;
    &lt;li&gt;交互式&lt;/li&gt;
    &lt;li&gt;实时&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;批处理&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;先来先服务&lt;/li&gt;
    &lt;li&gt;最短作业优先&lt;/li&gt;
    &lt;li&gt;最短剩余时间优先&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;交互式&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;轮转调度: 时间分片; 维护一个进程队列, 用完时间片后, 排到队列末尾&lt;/li&gt;
    &lt;li&gt;优先级调度&lt;/li&gt;
    &lt;li&gt;多级队列&lt;/li&gt;
    &lt;li&gt;最短进程优先&lt;/li&gt;
    &lt;li&gt;保证调度&lt;/li&gt;
    &lt;li&gt;彩票调度&lt;/li&gt;
    &lt;li&gt;公平分享调度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;133-读者-写者问题&quot;&gt;1.3.3 读者-写者问题&lt;/h4&gt;

&lt;p&gt;实现目标是: 可以多个读者&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;以数据库为例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef int semaphore;
semaphore mutex = 1; 
semaphore db = 1; // 控制对数据库的访问
int rc = 0; // 正在读或者即将读的进程数目

void reader(void)
{
    while(true)
    {
        down(&amp;amp;mutex); // 获得对rc的互斥访问权
        rc = rc + 1; // 多了一个读者
        if (rc == 1) // 如果是第一个读者
            down(&amp;amp;db);
        up(&amp;amp;mutex);
        read_data_base(); // 访问数据
        down(&amp;amp;mutex);
        rc = rc - 1; // 减少了一个读者
        if (rc == 0) // 如果是最后一个读者
            up(&amp;amp;db); 
        up(&amp;amp;mutex);
        use_data_read(); // 非临界区
    }
}

void writer(void) 
{   
    while(true)
    {
        think_up_data(); // 非临界区
        down(&amp;amp;db); // 获取互斥访问
        write_data_basae(); // 更新数据
        up(&amp;amp;db); // 释放互斥访问
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-线程&quot;&gt;二. 线程&lt;/h2&gt;

&lt;p&gt;为什么要使用线程:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;并行实体拥有共享同一个地址空间和所有可用数据的能力, 这是多进程无法表达的&lt;/li&gt;
    &lt;li&gt;线程比进程更轻量级, 它们比进程更容易创建, 也更容易撤销&lt;/li&gt;
    &lt;li&gt;若多个线程都是&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;密集型的, 那么并不能获得性能上的增强(考虑调度消耗时间), 但是如果存在大量的计算和大量的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;处理, 拥有多个线程允许这些活动彼此重叠进行, 从而会加快应用程序执行的速度&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在线程中有一个程序计数器, 用来记录接着要执行哪一条指令, 线程拥有寄存器, 用来保存线程当前的工作变量, 线程还拥有一个堆栈, 其中每一帧保存了一个已调用的但是还没有从中返回的过程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/CS/线程与进程.png&quot; alt=&quot;线程与进程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进程用于把资源集中到一起, 而线程则是在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;上被调度执行的实体(资源管理的单位是进程)&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java并发[三]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解锁等高级主题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-死锁及其避免&quot;&gt;一. 死锁及其避免&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;死锁出现的原因通常是出现锁环路造成的, 不管是显示的还是隐式的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过定义获取锁的顺序来避免死锁: 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;System.identityHashCode(object)&lt;/code&gt;来返回一个锁对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.hashCode()&lt;/code&gt;的返回值; 通过这个值来定义锁的顺序, 并在整个应用程序中都按照这个顺序来获取锁, 那么就不会形成锁环路了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        Object fromAcct = new Object(); // 这里的锁对象也可以是其他
        Object toAcct = new Object();
        Object tieLock = new Object();
        int fromHash = System.identityHashCode(fromAcct);
        int toHash = System.identityHashCode(toAcct);
        if (fromHash &amp;lt; toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    // doSomething
                }
            }
        } else if (fromHash &amp;gt; toHash) {
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    // doSomething
                }
            }
        } else { // 这种情况主要是避免Hash冲突, 此时需要额外的锁
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        // doSomething
                    }
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;使用开放调用(如果在调用某个方法时, 不需要持有锁, 那么这种调用就被成为开放调用)避免死锁: 这种情况下适用于持有不同锁的方法之间的相互调用(注意锁的级别是在方法上, 而不是代码块上)(相当于形成一个隐式的环); 将锁从方法上转移到需要同步的内部代码块上可以避免死锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock.tryLock()&lt;/code&gt;: 可以检测死锁和从死锁中恢复过来; 即指定一个超时时限, 在等待超过该时间后&lt;code class=&quot;highlighter-rouge&quot;&gt;tryLock()&lt;/code&gt;会返回一个失败信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的几点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;对象分配操作的开销比同步的开销更低(实际上, 现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;的分配操作已经比&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言的&lt;code class=&quot;highlighter-rouge&quot;&gt;malloc&lt;/code&gt;调用更快&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的以前实现中(现在实现不同咯)采用分段锁, 使用了一个包含&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个锁的数组, 每个锁保护散列桶的&lt;code class=&quot;highlighter-rouge&quot;&gt;1/16&lt;/code&gt;, 这样就能够支持多达&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个并发的写入器; &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;将对每个分段进行枚举并将每个分段中的元素数量相加, 而不是维护一个全局计数, 为了避免枚举每个计数, &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;为每个分段都维护了一个独立的计数, 并通过每个分段的锁来维护这个值(这个地方有两点需要注意: 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算是在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;操作都会改变一次, 这样虽然增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;的操作, 但是这会使得&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的计算从&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;变为&lt;code class=&quot;highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;; 另一个是为每个分段维护一个&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 而不是使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;, 如果使用一个全局的共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的话, ,实际上就破坏了分段锁的分段特性, 因为访问共享&lt;code class=&quot;highlighter-rouge&quot;&gt;size&lt;/code&gt;的时候, 需要同步)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 09 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/09/Java%E5%B9%B6%E5%8F%91-%E4%B8%89/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[二]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要讲解了&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;框架&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-executor框架&quot;&gt;一. Executor框架&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;线程池: 可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Executors&lt;/code&gt;中的静态工厂方法之一来创建一个线程池&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newFixedThreadPool&lt;/code&gt;: 创建一个固定长度的线程池, 每当提交一个任务时就创建一个线程, 直到达到线程池的最大数量, 这是线程池规模将不再变化(如果某个线程发生异常终止, 那么线程池会补充一个线程)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newCachedThreadPool&lt;/code&gt;: 创建一个可缓存的线程池, 如果线程池的当前规模超过了处理需求时, 那么将回收空闲的线程, 而当需求增加时, 则可以添加新的线程, 线程池的规模不存在任何限制&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;: 一个单线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;, 它创建单个工作者线程来执行任务, 如果这个线程异常结束, 会创建另一个线程来代替;&lt;code class=&quot;highlighter-rouge&quot;&gt;newSingleThreadExecutor&lt;/code&gt;能确保依照任务在队列中的顺序来执行(如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LIFO&lt;/code&gt;, 优先级)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newScheduledThreadPool&lt;/code&gt;: 创建了一个固定长度的线程池, 而且以延迟或定时的方式来执行任务, 类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;生命周期: 为了解决执行服务的生命周期问题, &lt;code class=&quot;highlighter-rouge&quot;&gt;Executor&lt;/code&gt;扩展了&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;接口; &lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;的生命周期有三种状态: 运行, 关闭, 已终止; 提供了如下方法:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown()&lt;/code&gt;: 执行平缓的关闭过程, 不再接受新任务, 同时等待已经提交的任务执行完成(包括那些还未开始执行的任务)&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shutdownNow()&lt;/code&gt;: 执行粗暴的关闭过程, 尝试取消所有运行中的任务, 并且不再启动队列中尚未开始执行的任务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;awaitTermination()&lt;/code&gt;: 等待&lt;code class=&quot;highlighter-rouge&quot;&gt;ExecutorService&lt;/code&gt;到达终止状态, 或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;isTerminated()&lt;/code&gt;来轮循是否已经终止&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;延迟任务与周期任务: &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;ScheduleThreadPoolExecutor&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;: 在执行所有定时任务时只会创建一个线程, 如果某个任务执行时间过长, 那么将破坏其他&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;的定时精确性; &lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;线程并不捕获异常, 因此当&lt;code class=&quot;highlighter-rouge&quot;&gt;TimerTask&lt;/code&gt;抛出未检查异常时将终止定时线程&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序, 运行&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;秒之后结束, 而不是运行&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;秒; 同时还会抛出异常&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class OutOfTime {
    public static void main(String[] args) throws InterruptedException {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 5);
        SECONDS.sleep(5);
    }

    public static class ThrowTask extends TimerTask {

        @Override
        public void run() {
            throw new RuntimeException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;携带结果的任务&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Callable&lt;/code&gt;任务主入口点(即&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;)将返回一个值, 并可能抛出一个异常&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future&lt;/code&gt;: 表示一个任务的生命周期, 并提供了相应的方法来判断是否已经完成或取消, 以及获取任务的结果和取消任务等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;二者区别参见其提供方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Callable&amp;lt;V&amp;gt; {
    V call() throws Exception;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Future&amp;lt;V&amp;gt; {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-中断&quot;&gt;二. 中断&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;有三个中断方法: &lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupted()&lt;/code&gt;, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.interrupted()&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;能中断目标线程, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;isInterrupt()&lt;/code&gt;能返回目标线程的中断状态, 静态的&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupted()&lt;/code&gt;将清除当前线程的中断状态并返回它之前的值; 这也是清除中断状态的唯一方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;阻塞库方法, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.sleep()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.wait()&lt;/code&gt;等, 都检查线程何时中断, 它们在响应中断时执行的操作包括: 清除中断状态, 抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;interrupt()&lt;/code&gt;并不意味着立即停止目标线程正在进行的工作, 而只是传递了请求中断的消息(由线程自己去决定如何处理中断)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中断是实现取消最合理的方式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;响应中断:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;传递异常&lt;/li&gt;
        &lt;li&gt;恢复中断状态&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;不可阻塞中断: 许多可阻塞的方法都是通过提前返回或者抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;InterruptedException&lt;/code&gt;来响应中断请求的; 但是并非所有的可阻塞方法或者阻塞机制都能响应中断, 有如下两种情况:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;当线程执行同步的&lt;code class=&quot;highlighter-rouge&quot;&gt;Socket I/O&lt;/code&gt;时&lt;/li&gt;
    &lt;li&gt;等待获得内置锁而阻塞时: 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Lock&lt;/code&gt;类中提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;lockInterruptibly&lt;/code&gt;方法来允许在等待一个锁的同时仍能响应中断&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-守护线程&quot;&gt;三. 守护线程&lt;/h2&gt;

&lt;p&gt;线程可以分为两种: 普通线程和守护线程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;启动时创建的所有线程中, ,除了主线程以外, 其他的线程都是守护线程(例如垃圾回收器以及其他执行辅助工作的线程); 当创建一个新线程时, 新线程将继承它的线程的守护状态&lt;/p&gt;

&lt;p&gt;普通线程与守护线程的区别仅在于当线程退出时发生的操作, 当一个线程退出时, &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会检查其他正在运行的线程, 如果这些线程都是守护线程, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会正常退出操作, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;停止时, 所有仍然存在的守护线程都将被抛弃–既不会执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finally&lt;/code&gt;代码块, 也不会执行回卷栈, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;只是直接退出&lt;/p&gt;
</description>
        <pubDate>Fri, 02 Nov 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/11/02/Java%E5%B9%B6%E5%8F%91-%E4%BA%8C/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java并发[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java并发编程实战第一部分总结&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;先检查后执行&lt;/strong&gt;: 首先观察到某个条件为真(例如文件X不存在), 然后根据这个观察结果采用相应的动作(创建文件X), 但事实上, 在你观察到这个结果以及开始穿件文件之间, 观察结果可能变得无效(另一个线程创建了文件X), 从而导致各种问题(未预期异常, 数据被覆盖, 文件被破坏等)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象都可以用作一个实现同步的锁, 这些锁被称为内置锁或监视锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不要在构造过程中使&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用逸出: 当且仅当对象的构造函数返回时, 对象才处于可预测的和一致的状态, 因此, 当从对象的构造函数中发布对象时, 只是发布了一个尚未构造完成的对象, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出, 那么这种对象就被认为是不正确的构造; 常见场景是:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在构造函数中创建线程: 在构造函数中创建线程并没有错, 但是最好不要立即启动它&lt;/li&gt;
    &lt;li&gt;在构造函数中注册事件监听: 依据是非静态内部类会持有外部类的引用&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑下列程序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() { // this逸出
            public void onEvent(Event e) { 
                doSomething(); 
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用静态工厂方法来防止&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;引用在构造过程中逸出&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething();
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener listener = new SafeListener();
        source.registerListener(listener.listener);
        return listener;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;一个正确构造的对象可以通过以下方式来安全的发布:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;在静态初始化函数中初始化一个对象引用&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的域或者&lt;code class=&quot;highlighter-rouge&quot;&gt;AtomicReferance&lt;/code&gt;对象中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到某个正确构造对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;类型域中&lt;/li&gt;
        &lt;li&gt;将对象的引用保存到一个由锁保护的域中&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要安全的发布一个静态构造的对象, 最简单和安全的方式是使用静态的初始化器: 静态初始化器由&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;在类的初始化阶段执行, 由于在&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;内部存在着同步机制, 因此通过这种方式初始化的任何对象都可以被安全的发布&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Holder holder = new Holder();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-synchronized&quot;&gt;二. synchronized&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;使用的是对象锁, 修饰方法, 代码块或局部执行代码时, 使用的是当前锁对象; 修饰静态方法时, 使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;XX.class&lt;/code&gt;锁对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内置锁(&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;)可重入; 可重入: 如果某个线程试图获得一个已经由它自己持有的锁, 那么这个请求就会成功, 而不会造成死锁
考虑如下代码, 子类改写了父类的&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;方法, 然后调用父类中的方法, 此时如果没有可重入的锁, 那么这段代码将产生死锁&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Widget {
    public synchronized void doSomething() {
        System.out.println(&quot;Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public synchronized void doSomething() {
        System.out.println(&quot;LoggingWidget&quot;);
        super.doSomething();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;不能被继承:
    &lt;blockquote&gt;
      &lt;p&gt;1、子类继承父类时, 如果没有重写父类中的同步方法, 子类同一对象, 在不同线程并发调用该方法时, 具有同步效果&lt;/p&gt;
      &lt;ol&gt;
        &lt;li&gt;子类继承父类, 并且重写父类中的同步方法,但没有添加关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;synchronized&lt;/code&gt;, 子类同一对象, 在不同线程并发调用该方法时, 不再具有同步效果&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Widget {
    public synchronized void doSomething() {
        System.out.println(Thread.currentThread() + &quot; Widget&quot;);
    }
}

class LoggingWidget extends Widget {
    @Override
    public void doSomething() { // 这里没有加synchronized
        System.out.println(Thread.currentThread() + &quot; LoggingWidget&quot;); // 由于子类的doSomething()没有加synchronized方法, 所以子类的doSomething()不可同步
        super.doSomething(); // 但是父类的doSomething()仍可同步
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-volatile&quot;&gt;三. volatile&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量用来确保将变量的更新操作通知到其他线程; 当把变量声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型后, 不会将该变量上的操作与其他内存操作一起重排序, &lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量不会被缓存在寄存器或者对其他处理器不可见的地方, 因此在读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的变量总会返回最新写入的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前大多数处理器架构上, 读取&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销只比读取非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;变量的开销略高一些&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;变量(&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位), &lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;允许将&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位的读操作或写操作分解为两个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位的操作; 当读取一个非&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;变量时, 如果对该变量的读操作和写操作在不同线程中执行, 那么很可能会读取到某个值的高&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位和另一个值的低&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位; 因此, 即使不考虑失效数据问题, 在多线程中使用共享且可变的&lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;等类型的变量也是不安全的, 除非用&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;来声明他们, 或者用锁保护起来&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-同步工具类&quot;&gt;四. 同步工具类&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;同步工具类可以根据其自身的状态来协调线程的控制流; 可以用作同步工具类的如: 阻塞队列, 信号量(Semaphore), 栅栏(Barrier), 闭锁(Latch)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;41-阻塞队列-blockingqueue&quot;&gt;4.1 阻塞队列-BlockingQueue&lt;/h3&gt;

&lt;p&gt;阻塞队列提供了可阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法, 以及支持定时的&lt;code class=&quot;highlighter-rouge&quot;&gt;offer&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;poll&lt;/code&gt;方法, 如果队列已经满了, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;方法将阻塞直到有空间可用; 如果队列为空, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;方法将阻塞直到有元素可用(实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;循环不断插入元素和获取元素, 以及结合信号量来实现的阻塞)&lt;/p&gt;

&lt;p&gt;常用的接口&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现有: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayBlockingQueue&lt;/code&gt;, 这两个是&lt;code class=&quot;highlighter-rouge&quot;&gt;FIFO&lt;/code&gt;队列, 分别与&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;类似; 还有一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;PriorityBlockingQueue&lt;/code&gt;, 是一个优先级队列, 可以按照元素的自然顺序来排列, 也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;来排列(如果它们实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;方法); 最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BlockingQueue&lt;/code&gt;的实现是&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;, 实际上它不是一个真正的队列, 因为它不会为队列中元素维护存储空间, 与其他队列不同的是, 它维护一组线程,
这些线程在等待这把元素加入或移出队列, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;SynchronousQueue&lt;/code&gt;没有存储功能, 因此&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;take&lt;/code&gt;会一直阻塞, 直到有另一个线程已经准备好参与到交付过程中, 仅当有足够多的消费者, 并且总是有一个消费者准备好获取交付工作时, 才适合使用同步队列&lt;/p&gt;

&lt;p&gt;这里再提一下&lt;strong&gt;双端队列&lt;/strong&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;Deque&lt;/code&gt;(可以在队列头和队列尾高效插入和移除), 具体实现包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedBlockingDeque&lt;/code&gt;; 双端队列适用于工作密取, 即每个消费者都有自己的双端队列, 如果一个消费者完成了自己双端队列的全部工作, 那么它可以从其他消费者双端队列末尾秘密的获取工作(因为可以首尾插入和获取, 所以互不影响)&lt;/p&gt;

&lt;h3 id=&quot;42-闭锁&quot;&gt;4.2 闭锁&lt;/h3&gt;

&lt;h4 id=&quot;421-countdownlatch&quot;&gt;4.2.1 CountDownLatch&lt;/h4&gt;

&lt;p&gt;作用: 可以延迟线程的进度直到其到达终止状态; 闭锁的作用相当于一扇门: 在闭锁到达结束状态之前, 这扇门一直是关闭的, 并且没有任何线程能通过, 当到达结束状态时, 这扇门会打开并允许所有的线程通过; 当闭锁到达结束状态后, 将不再改变状态, 因此这扇门永远保持打开状态; 闭锁可以用来确保某些活动直到其他活动都完成后才继续进行(可以使一个或多个线程等待一组事件发生)&lt;/p&gt;

&lt;p&gt;闭锁状态包括一个计数器, 该计数器被初始化为一个正数, 表示需要等待的事件数量, &lt;code class=&quot;highlighter-rouge&quot;&gt;countDown&lt;/code&gt;递减计数器 , 表示有一个事件已经发生了, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法等待计数器达到零, 这表示所有需要等待的事件都已发生; 如果计数器值非零, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;会一直阻塞直到计数器为零, 或者等待中的线程中断, 或者等待超时&lt;/p&gt;

&lt;p&gt;用法参见下列程序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class LatchTest {
    public long timeTasks(int nThreads, final Runnable task) throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);
        for (int i = 0; i &amp;lt; nThreads; i++) {
            Thread t = new Thread(() -&amp;gt; {
                try {
                    startGate.await(); // 等待所有线程准备完毕
                    task.run();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    endGate.countDown();
                }
            });
            t.start();
        }
        long start = System.nanoTime();
        startGate.countDown(); // 执行到这里, 说明所有线程准备好了, 可以开始执行了
        endGate.await(); // 主线程等待任务执行完毕
        long end = System.nanoTime();
        return end - start;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;422-futuretask&quot;&gt;4.2.2 FutureTask&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FutureTask&lt;/code&gt;也可以用作闭锁, 相当于一种可生成结果的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Future.get()&lt;/code&gt;: 如果任务已经完成, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;会立即返回结果, 否则&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;将阻塞直到任务进入完成状态, 然后返回结果或者抛出异常&lt;/p&gt;

&lt;p&gt;基本使用参见如下代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FutureTest {
    private final FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;String&amp;gt;(new Callable&amp;lt;String&amp;gt;() {
        @Override
        public String call() throws Exception {
            // 耗时操作
            return &quot;Hello&quot;;
        }
    });

    private final Thread thread = new Thread(futureTask);

    public void start() { // 不要在构造函数中构造和start线程: 参见上文安全发布
        thread.start();
    }

    public String get() throws ExecutionException, InterruptedException {
        return futureTask.get(); // 阻塞直到结束或者异常
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;43-信号量-semaphore&quot;&gt;4.3 信号量-Semaphore&lt;/h3&gt;

&lt;p&gt;计数信号量用来控制同时访问某个特定资源的操作数量, 或者同时执行某个指定操作的数量&lt;/p&gt;

&lt;p&gt;计算信号量的一种就简化形式是二值信号量, 即初始值为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Semaphore&lt;/code&gt;, 二值信号量可以用作互斥体, 并具备不可重入的加锁语义: 谁拥有这个唯一的许可, 谁就拥有了互斥锁&lt;/p&gt;

&lt;p&gt;使用信号量实现有界阻塞容器:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class BoundedHashSet&amp;lt;T&amp;gt; {
    private final Set&amp;lt;T&amp;gt; set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        set = Collections.synchronizedSet(new HashSet&amp;lt;T&amp;gt;());
        sem = new Semaphore(bound);
    }

    public boolean add(T t) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(t);
            return wasAdded;
        } finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(T o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;44-栅栏-barrier&quot;&gt;4.4 栅栏-Barrier&lt;/h3&gt;

&lt;p&gt;栅栏类似于闭锁, 它能阻塞一组线程直到某个事件发生, 栅栏与闭锁的关键区别在于, 所有线程必须同时到达栅栏位置, 才能继续执行, 闭锁用于等待事件, 而栅栏用于等待其他线程&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;可以使一定数量的参与方反复的在栅栏位置汇集, 它在并行迭代算法中非常有用; 当线程到达栅栏位置时将调用&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;方法, 这个方法将阻塞直到所有线程都到达栅栏位置; 如果所有线程都到达了栅栏位置, 那么栅栏将打开, 此时所有线程都被释放, 而栅栏将被重置以便下次使用; 如果对&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用超时, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;阻塞的线程被中断, 那么栅栏就被认为是打破了, 所有阻塞的&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;调用都将终止并抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;BrokenBarrierException&lt;/code&gt;; 如果成功通过栅栏, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;await&lt;/code&gt;将为每个线程返回一个唯一到达索引号;
&lt;code class=&quot;highlighter-rouge&quot;&gt;CyclicBarrier&lt;/code&gt;还可以使你将一个栅栏操作传递给构造函数, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 当成功通过栅栏时会(在一个子任务线程中)执行它, 但在阻塞线程被释放之前是不能执行的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-遗留&quot;&gt;五. 遗留&lt;/h2&gt;

&lt;p&gt;Vector, Hashtable, CopyOnWriteArrayList(写入时复制: Copy-On-Write), CopyOnWriteArraySet, BlockingQueue, ConcurrentLinkedQueue, PriorityQueue
Deque: ArrayDeque, LinkedBlockingDeque&lt;/p&gt;

&lt;p&gt;三个interrupt()理解&lt;/p&gt;
</description>
        <pubDate>Wed, 31 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/31/Java%E5%B9%B6%E5%8F%91%E4%B8%80/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>编译器笔记与实验记录</title>
        <description>&lt;h1 id=&quot;序言&quot;&gt;序言&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;编译器,教程: http://mooc.study.163.com/learn/1000002001?tid=1000003000#/learn/content?type=detail&amp;amp;id=1000023001&amp;amp;cid=1000019000&lt;/li&gt;
  &lt;li&gt;配套网站: http://staff.ustc.edu.cn/~bjhua/courses/compiler/2014/&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-编译器介绍&quot;&gt;一. 编译器介绍&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;概念: 编译器是一个程序,核心功能是把源程序代码翻译成为目标代码&lt;/li&gt;
  &lt;li&gt;编译器核心功能如下图: 其中&lt;strong&gt;静态计算&lt;/strong&gt;表示的是经过编译器后, 目标程序和源程序的功能需要相同&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/编译器核心功能.png&quot; alt=&quot;编译器核心功能&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解释器: 也是处理程序的一种程序;(解释器是在线的方式,也就是说解释器解释程序之后实际上还会执行该程序,而编译器只是生成可执行文件,称为离线形式, 编译器输出为可执行程序, 而解释器输出为程序执行结果)&lt;/li&gt;
  &lt;li&gt;结构: 前端–&amp;gt;代码优化–&amp;gt;后端; 词法分析–&amp;gt;语法分析–&amp;gt;语义分析–&amp;gt;代码生成; (流水线模式)&lt;/li&gt;
  &lt;li&gt;编译器结构: 如下图(一个没有优化的编译器结构)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/一个没有优化的编译器结构.png&quot; alt=&quot;一个没有优化的编译器&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;栈式计算机: 如:JVM&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-词法分析&quot;&gt;二. 词法分析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;编译器可以分为一个前端和后端, 前端又可细分为如下:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/前端.png&quot; alt=&quot;前端&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;作用: 字符流–&amp;gt;词法分析–&amp;gt;记号流; (字符,关键字的切分等)&lt;/li&gt;
  &lt;li&gt;记号流: 编译器内部定义的数据结构, 编码所识别出的词法单元; 如下是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;语言实现的记号流的数据结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/记号流的数据结构.png&quot; alt=&quot;记号流&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;词法分析的实现方法:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;手工编码实现方法: 是目前非常流行的实现方法,如:GCC,LLVM&lt;/li&gt;
        &lt;li&gt;词法分析器的自动生成器: 可以快速成型,但是难以控制细节&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;手工分析法: 转移图(实际上有点类似状态转移,需要注意的是有的地方需要回滚(回滚的实现: 一个可以通过文件指针的回退,另一个是可以将文件内容读取到一个字符数组中,然后需要回退时将索引减一即可))&lt;/li&gt;
  &lt;li&gt;关键字表算法: 对给定语言的所有关键字构造一个Hash表,也就是对所有的标识符和关键字,先统一按标识符的转移图进行识别,识别完成后,再进一步查表看是否是关键字(关键字的完美Hash表: 完美哈希函数是没有冲突的的哈希函数，也就是，函数 H 将 N 个 KEY 值映射到 M 个整数上，这里 M&amp;gt;=N ，而且，对于任意的 KEY1 ，KEY2 ，H( KEY1 ) != H( KEY2 ) ，并且，如果 M = = N ，则 H 是最小完美哈希函数（Minimal Perfect Hash Function，简称MPHF)&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-gperf.html&quot;&gt;参考博文&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;自动生成法(生成器): 通过一些转换工具,如: lex,flex,jlex等将正则表达式转换为词法分析器; 需要用到:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;正则&lt;/li&gt;
        &lt;li&gt;有限状态自动机: 输入的串是否能被状态机接受(DFA(确定的),NFA(不确定的))&lt;/li&gt;
        &lt;li&gt;正则表达式到&lt;code class=&quot;highlighter-rouge&quot;&gt;NFA&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Thompson&lt;/code&gt;算法,从&lt;code class=&quot;highlighter-rouge&quot;&gt;NFA&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;DFA&lt;/code&gt;是子集构造算法,从DFA到词法分析器是Hopcraft最小化算法&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;DFA: 确定状态有限自动机(只有一个状态)(词法分析器是一个DFA); NFA: 非确定有限状态自动机(有多个状态)&lt;/li&gt;
  &lt;li&gt;正则表达式转换为词法分析器:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/正则表达式转换为词法分析器.png&quot; alt=&quot;正则表达式转换为词法分析器&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DFA最小化算法: Hopcroft算法&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-语法分析&quot;&gt;三. 语法分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;语法分析器: 判断程序是否符合语法规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Compiler/语法分析器的作用.png&quot; alt=&quot;语法分析器的作用&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;语法分析的数据工具: 上下文无关文法(乔姆斯基文法体系: 为研究自然语言提供的一系列数学工具)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 28 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/28/Compiler/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/28/Compiler/</guid>
        
        <category>Compiler</category>
        
        
      </item>
    
      <item>
        <title>数字图像处理</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;数字图像处理笔记&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;可以使用Utrapdit软件查看图片的ASIIC值(可以看任何文件的ASIIC值)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一-第一讲-数字图像处理概述&quot;&gt;一. 第一讲 数字图像处理概述&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;图形和图像的区别:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;图形: 一条指令; 比如一条直线的表示&lt;/li&gt;
    &lt;li&gt;图像: 大矩阵, 里面的数据是每一点的颜色值&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;宽高相乘就是图像的像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图像空间分辨率和灰度级分辨率(表用多少位表示)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;jpg是压缩格式; 网上的视屏也是经过压缩后传输再解压缩播放的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-第二讲-图像存储格式&quot;&gt;二. 第二讲 图像存储格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;单色图像(黑白图像): 一位;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;8位索引图像: 有一个颜色表和一个像颜色表的序号的数据矩阵&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;8位索引灰度图像: 颜色表中的RGB相等&lt;/li&gt;
    &lt;li&gt;8位伪彩色索引图像: 颜色表中的RGB值不等&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;彩色图像: 分为伪彩色和真彩色(每个像素24位, RGB各占8位);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;BMP, GIF, TIF, JPEG&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;GIF: 主要用于不同平台上交流和传输, 而不是作为文件的存储格式&lt;/li&gt;
        &lt;li&gt;TIF: 最复杂&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-第三讲-bmp位图文件的存储格式&quot;&gt;三. 第三讲 BMP位图文件的存储格式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;BMP文件组成:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;位图文件头结构: BITMAPFILEHEADER&lt;/li&gt;
    &lt;li&gt;位图信息头结构: BITMAPINFOHEADER&lt;/li&gt;
    &lt;li&gt;位图颜色表: RGBQUAD(有的可能没有颜色表, 具体有没有, 参见第二讲)&lt;/li&gt;
    &lt;li&gt;位图像素数据&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;BMP文件头: 14个字节&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagBITMAPFILEHEADER
{
    WORD bfType; // BM: BMP文件标识(前两个字节), 一个字节是B, 一个字节是M
    DWORD bfSize; // 文件大小
    WORD bfReserved1; // 0
    WORD bfReserved2; // 0
    DWORD bfOffBits; // 位图数据的起始位置
} BITMAPFILEHEDADER; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;BMP信息头结构: 40个字节&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagBITMAPINFOHEADER
{
    DWORD biSize; // 本结构的大小: 40个字节
    LONG biWidth; // 位图宽度, 像素为单位
    LONG biHeight; // 位图高度, 像素为单位
    WORD biPlanes; // 位平面数, 是标准的一般是1
    WORD biBitCount; // 每个像素所需的位数
    DWORD biCompression; // 位图压缩类型: BMP位图一般不压缩, 取0
    DWORD biSizeImage; // 位图大小
    LONG biXpelsPerMeter; // 水平分辨率(像素点/米)
    LONG biYPelsPerMeter; // 垂直分辨率(像素点/米)
    DWORD biCIrUsed; // 颜色数: 如果是标准颜色, 如16, 24, 256等位颜色, 则是0; 如果是自己定义, 则需要将颜色数写在这
    DWORD biCIrImportant; // 重要的颜色数
} BITMAPINFOHEADER;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;颜色表:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct tagRGBQUAD 
{
    BYTE rgbBlue; // 蓝色
    BYTE rgbGreen; // 绿色
    BYTE rgbRed; // 红色
    BYTE rgbReserved; // 保留字节; 0
} RGBQUAD;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;位图信息 – BITMAPINFO结构: 图像显示时作为参数传入函数&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD bmiColors[1]; // 颜色表(上的第一项)
} BITMAPINFO;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-几何变换基础&quot;&gt;四. 几何变换基础&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;讲解平移, 缩放, 旋转, 镜像等的矩阵和原理&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 22 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/22/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</guid>
        
        <category>数字图像处理</category>
        
        
      </item>
    
      <item>
        <title>OpenGL笔记</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;阅读OpenGL中文文档笔记&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-入门&quot;&gt;一. &lt;a href=&quot;https://learnopengl-cn.github.io/01%20Getting%20started/01%20OpenGL/&quot;&gt;入门&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;11-opengl&quot;&gt;1.1 OpenGL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么是OpenGL: 并不是API, 而是一个规范; OpenGL规范严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定; OpenGL基于显卡, 所以OpenGL API大多由显卡厂商提供&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心模式与立即渲染模式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;立即渲染模式(固定渲染管线): 用于早期OpenGL; 封装性好, 使用方便, 但是效率低, 灵活性不够&lt;/li&gt;
    &lt;li&gt;核心模式: 从OpenGL3.2开始, 规范文档开始废弃立即渲染模式; 当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;状态机: OpenGL状态通常被成为OpenGL上下文; OpenGL本质上是一个大状态机(理解状态函数和状态使用函数)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-hello-window&quot;&gt;1.2 Hello Window&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;视口: ViewPort; OpenGL渲染窗口的尺寸大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;双缓冲: 应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。前缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在后缓冲上绘制。当所有的渲染指令执行完毕后，我们交换(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-hello-三角形&quot;&gt;1.3 Hello 三角形&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图形渲染管线: 又称为管线; 指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程;  在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素; 3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线管理的; 图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器: 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器; 而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如下为每个图形渲染管线的抽象展示; 其中蓝色部分是可以注入自定义着色器的部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/图形渲染管线.png&quot; alt=&quot;图形渲染管线&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;图元(Primitive): 为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点着色器(Vertex Shader): 顶点着色器主要的目的是把3D坐标转为另一种3D坐标, 同时顶点着色器允许我们对顶点属性进行一些基本处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图元装配(Primitive Assembly): 将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状; 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;光栅化阶段: 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;片段着色器: 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;标准化设备坐标: 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/标准化设备坐标.png&quot; alt=&quot;标准化设备坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;深度: 通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;着色器程序: 着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;glVertexAttribPointer&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/glVertexAttribPointer.png&quot; alt=&quot;glVertexAttribPointer&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;14-glsl&quot;&gt;1.4 GLSL&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GLSL基本数据类型: int, float, double, uint, bool&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容器类型: Vector, Matrix&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果我们打算从一个着色器向另一个着色器发送数据，我们必须在发送方着色器中声明一个输出，在接收方着色器中声明一个类似的输入。当类型和名字都一样的时候，OpenGL就会把两个变量链接到一起，它们之间就能发送数据了（这是在链接程序对象时完成的）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Uniform: Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果你声明了一个uniform却在GLSL代码中没用过，编译器会静默移除这个变量，导致最后编译出的版本中并不会包含它，这可能导致几个非常麻烦的错误，记住这点！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-纹理&quot;&gt;1.5 纹理&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理: 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;采样: 使用纹理坐标获取纹理颜色叫做采样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理坐标.png&quot; alt=&quot;纹理坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;纹理环绕方式: 纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/纹理环绕方式.png&quot; alt=&quot;纹理环绕方式&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纹理过滤: 纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标(Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色); 纹理过滤主要有两种: GL_NEAREST和GL_LINEAR; 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项(使用glTexParameteri())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;邻近过滤(GL_NEAREST): 默认纹理过滤方式; 当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性过滤(GL_LINEAR): 会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大(GL_LINEAR可以产生更真实的输出)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多级渐远纹理: 简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一; 多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好(glGenerateMipmaps())&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纹理单元: 一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元; 纹理单元的主要目的是让我们在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，我们可以一次绑定多个纹理，只要我们首先激活对应的纹理单元&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;15-变换&quot;&gt;1.5 变换&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向量: 有大小和方向; 其实就是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;N*1&lt;/code&gt;的矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量运算:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/向量与标量运算.png&quot; alt=&quot;向量与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;向量取反: 个分量都取反&lt;/li&gt;
    &lt;li&gt;向量之间加减: 各分量之间对应加减&lt;/li&gt;
    &lt;li&gt;向量乘积&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;点乘: 点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘.png&quot; alt=&quot;点乘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/点乘2.png&quot; alt=&quot;点乘2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;叉乘:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/叉乘.png&quot; alt=&quot;叉乘&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;矩阵运算&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵与标量运算&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与标量运算.png&quot; alt=&quot;矩阵与标量运算&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;矩阵之间加减: 对应项加减即可&lt;/li&gt;
    &lt;li&gt;矩阵数乘: 将该数和矩阵每一项想乘&lt;/li&gt;
    &lt;li&gt;矩阵相乘: 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘; 矩阵相乘不遵守交换律&lt;/li&gt;
    &lt;li&gt;矩阵与向量相乘:&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;缩放:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之缩放.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;位移:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之位移.png&quot; alt=&quot;矩阵与向量运算&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿x轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿x轴旋转.png&quot; alt=&quot;沿x轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿y轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿y轴旋转.png&quot; alt=&quot;沿y轴旋转&quot; /&gt;&lt;/p&gt;

&lt;p&gt;沿z轴旋转:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/矩阵与向量运算之沿z轴旋转.png&quot; alt=&quot;沿z轴旋转&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;16-坐标系统&quot;&gt;1.6 坐标系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对我们来说比较重要的有五类坐标系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;局部空间(Local Space，或者称为物体空间(Object Space))&lt;/li&gt;
    &lt;li&gt;世界空间(World Space)&lt;/li&gt;
    &lt;li&gt;观察空间(View Space，或者称为视觉空间(Eye Space))&lt;/li&gt;
    &lt;li&gt;裁剪空间(Clip Space)&lt;/li&gt;
    &lt;li&gt;屏幕空间(Screen Space)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型(Model)、观察(View)、投影(Projection)三个矩阵&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;顶点坐标起始于局部空间(Local Space)，在这里它称为局部坐标(Local Coordinate)，它在之后会变为世界坐标(World Coordinate)，观察坐标(View Coordinate)，裁剪坐标(Clip Coordinate)，并最后以屏幕坐标(Screen Coordinate)的形式结束; 如下图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/坐标系统.png&quot; alt=&quot;坐标系统&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;局部空间: 物体所在的坐标空间，即对象最开始所在的地方&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;世界空间: 物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;观察空间: 观察空间经常被人们称之OpenGL的摄像机(Camera); 观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果; 因此观察空间就是从摄像机的视角所观察到的空间; 这通常用一个观察矩阵(View Matrix)完成，它被用来将世界坐标变换到观察空间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;裁剪空间:  在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来; 为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection
Matrix)，它指定了一个范围的坐标(如果只是图元(Primitive)，例如三角形，的一部分超出了裁剪体积(Clipping Volume)，则OpenGL会重新构建这个三角形为一个或多个三角形让其能够适合这个裁剪范围)(一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;透视投影: 离你越远的东西看起来更小; 使用透视投影矩阵来完成的; 一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上, 即将顶点坐标中的每个分量除以w分量; 透视投影如下图; 位于视景体之内的物体被投影到金字塔的顶点, 也就是照相机或观察点的位置; 靠近观察点的物体看上去更大一些, 因为和远处的物体相比, 它占据了视景体中相对较大的区域(实际上从相机(观察点)的角度看顶面和底面, 其占据的空间大小相同, 都是视口大小); 平截头体的四个侧面, 顶面和底面对应与视景体的6个裁剪平面, 位于这些平面之外的物体将被裁剪掉, 不会出现在最终的图像中;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/透视投影.png&quot; alt=&quot;透视投影&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个顶点坐标会根据以下过程被变换到裁剪坐标(注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法)): 最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/裁剪坐标.png&quot; alt=&quot;裁剪坐标&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;OpenGL存储深度信息在一个叫做Z缓冲(Z-buffer)的缓冲中，它允许OpenGL决定何时覆盖一个像素而何时不覆盖&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Z缓冲(深度缓冲): 深度值存储在每个片段里面（作为片段的z值），当片段想要输出它的颜色时，OpenGL会将它的深度值和z缓冲进行比较，如果当前的片段在其它片段之后，它将会被丢弃，否则将会覆盖。这个过程称为深度测试(Depth Testing)，它是由OpenGL自动完成的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视景体 : 管线会确定的一个可视空间区域, 由 上平面(up), 下平面(down), 左平面(left), 右平面(right), 远平面(far), 近平面(near) 六个平面组成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视景体与投影 : 视景体内的物体会投影到近平面, 视景体之外的内容会被裁减掉, 例如眼睛看不到的范围就是处于视景体外即被裁减掉的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;17-摄像机&quot;&gt;1.7 摄像机&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-光照&quot;&gt;二. 光照&lt;/h2&gt;

&lt;h3 id=&quot;21-颜色&quot;&gt;2.1 颜色&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;物体的颜色为物体从一个光源反射各个颜色分量的大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;物体的颜色是其和光源颜色的向量乘积&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/颜色.png&quot; alt=&quot;颜色&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-基础光照&quot;&gt;2.2 基础光照&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;冯氏光照模型(Phong Lighting Model): 冯氏光照模型的主要结构由3个分量组成：环境(Ambient)、漫反射(Diffuse)和镜面(Specular)光照&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/冯氏光照模型.png&quot; alt=&quot;冯氏光照模型&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个十分常见的错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每当我们应用一个不等比缩放时（注意：等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变了法线的长度，而这很容易通过标准化来修复），法向量就不会再垂直于对应的表面了，这样光照就会被破坏; 如下图; 修复这个行为的诀窍是使用一个为法向量专门定制的模型矩阵。这个矩阵称之为法线矩阵(Normal Matrix)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/OpenGL/缩放导致法向量破坏.png&quot; alt=&quot;缩放导致法向量破坏&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-材质&quot;&gt;2.3 材质&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在现实世界里，每个物体会对光产生不同的反应; 有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义一个材质(Material)属性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以用这三个分量来定义一个材质颜色(Material Color)：环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting), 再添加一个反光度(Shininess), 就能够对物体的颜色输出有着精细的控制了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们为每个冯氏光照模型的分量都定义一个颜色向量。ambient材质向量定义了在环境光照下这个物体反射得是什么颜色，通常这是和物体颜色相同的颜色。diffuse材质向量定义了在漫反射光照下物体的颜色。（和环境光照一样）漫反射颜色也要设置为我们需要的物体颜色。specular材质向量设置的是镜面光照对物体的颜色影响（或者甚至可能反射一个物体特定的镜面高光颜色）。最后，shininess影响镜面高光的散射/半径&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体材质的该四个分量可以参见: http://devernay.free.fr/cours/opengl/materials.html&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;物体过亮的原因是环境光、漫反射和镜面光这三个颜色对任何一个光源都会去全力反射。光源对环境光、漫反射和镜面光分量也具有着不同的强度&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-光照贴图&quot;&gt;2.4 光照贴图&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;漫反射贴图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;镜面光贴图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;25-投光物&quot;&gt;2.5 投光物&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;平行光: 当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点光源: 定向光对于照亮整个场景的全局光源是非常棒的，但除了定向光之外我们也需要一些分散在场景中的点光源(Point Light)。点光源是处于世界中某一个位置的光源，它会朝着所有方向发光，但光线会随着距离逐渐衰减&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;聚光: 聚光是位于环境中某个位置的光源，它只朝一个特定方向而不是所有方向照射光线。这样的结果就是只有在聚光方向的特定半径内的物体才会被照亮，其它的物体都会保持黑暗。聚光很好的例子就是路灯或手电筒。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/13/OpenGL%E7%AC%94%E8%AE%B0/</guid>
        
        <category>OpenGL</category>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Activity生命周期</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期讲解&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;本文将分析和总结各种情况下, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的生命周期情况, 包括正常情况下, 异常情况下(如: 用户屏幕旋转, 资源分配不足等)以及特殊情况下(如: 当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;上覆盖对话框或者透明&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 当按下&lt;code class=&quot;highlighter-rouge&quot;&gt;Home&lt;/code&gt;键回到桌面时, 当屏幕熄灭时)&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期的调用情况; 同时还将简述各个方法下适于做什么工作等&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-正常情况&quot;&gt;二. 正常情况&lt;/h2&gt;

&lt;h3 id=&quot;21-单独的activity分析&quot;&gt;2.1 单独的Activity分析&lt;/h3&gt;

&lt;p&gt;如下为一张典型的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;生命周期图(摘自官方文档); 也是正常情况下, 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的经历&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Activity/Activity生命周期.png&quot; alt=&quot;Activity生命周期&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;记忆的时候可以通过两两配对来记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面将结合上图讲解各个状态:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;: 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;启动时只调用一次, 表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;创建; 可以进行一些数据绑定, 类变量初始化或者上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;恢复等工作(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;savedInstanceState&lt;/code&gt;实现)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onStart()&lt;/code&gt;: 可见, 处于后台, 不能交互&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;: 可见, 处于前台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;: 时间短暂, 处于后台; 如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;的时候再快速的回到当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume&lt;/code&gt;会被调用(一般用户操作很难实现这一场景); 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android7.0&lt;/code&gt;或者更高, 应用可以在多窗口模式下运行, 但是只要每个时刻只有一个应用可以得到焦点, 那么此时就需要暂停另一个应用(处于&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;状态); (一个处于onPause状态的Activity可能仍然是完全可见的, 比如说在多窗口模式下); 不应该在&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;执行数据保存工作, 因为该阶段非常短暂, 同时只有&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;执行完,
新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;才会执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop()&lt;/code&gt;: 不可见, 可以执行一些稍微重量级的工作, 比如资源释放与数据保存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy()&lt;/code&gt;: 表示&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁, 可以做一些最终的回收工作和资源释放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestart()&lt;/code&gt;: 表示当当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;从不可见重新变为可见状态时调用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-activity启动新activity分析&quot;&gt;2.2 Activity启动新Activity分析&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里以Activity A正常启动Activity B的情况分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;启动&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;的时候, 会依次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;A.onPause()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onCreate()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onStart()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;B.onResume()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;A.onStop()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看出, 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;方法执行完成之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;的一系列方法才会调用; 这也说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;方法中不能执行耗时操作, 因为新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume()&lt;/code&gt;是在其之后执行的, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause()&lt;/code&gt;中执行太耗时的操作的话, 会影响新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的显示; 我们应当尽量在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop()&lt;/code&gt;中操作, 使新&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;尽快显示出来并出现在前台&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-异常情况&quot;&gt;三. 异常情况&lt;/h2&gt;

&lt;h3 id=&quot;31-资源相关系统配置改变导致activity被杀死并重新创建&quot;&gt;3.1 资源相关系统配置改变导致Activity被杀死并重新创建&lt;/h3&gt;

&lt;p&gt;默认情况下, 如果不做特殊处理, 当系统配置发生改变之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;就会被杀死并重建; 比如: 当手机进行横竖屏切换的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;默认就会被销毁重建&lt;/p&gt;

&lt;p&gt;在这种情况下, &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;会依次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStart&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onResume&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是这里和正常情况下不同的是, 需要等到&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁之后才能开始重新创建; 另一个就是, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁的时候, 会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;来保存当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的状态, 该方法的调用在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;之前, 但是和&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;没有既定的时序关系; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;的调用确是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStart&lt;/code&gt;之后, 有既定的时序关系;&lt;/p&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;销毁重建保存数据的方法是: 委托下级子元素调用其自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;来保存自己的状态和数据; 即让其关联&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;保存数据, &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;再委托子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行数据保存, 最终会调用每个子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onSaveInstanceState()&lt;/code&gt;来保存自己的数据&lt;/p&gt;

&lt;p&gt;当进行数据恢复的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle savedInstanceState&lt;/code&gt;参数不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 可以在此处进行数据恢复, 但是推荐在&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;中进行数据恢复&lt;/p&gt;

&lt;h3 id=&quot;32-资源内存不足导致低优先级activity被杀死&quot;&gt;3.2 资源内存不足导致低优先级Activity被杀死&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;优先级:&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;前台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 正在和用户交互的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 优先级最高&lt;/li&gt;
    &lt;li&gt;可见但非前台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中弹出了一个对话框, 导致&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可见但是位于后台, 无法与用户直接交互&lt;/li&gt;
    &lt;li&gt;后台&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;: 已经被暂停的&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;, 比如执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;, 优先级最低&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;被杀死的可能性如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Activity/系统杀死Activity.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-特殊情况&quot;&gt;四. 特殊情况&lt;/h2&gt;

&lt;h3 id=&quot;41-按下home键或者当屏幕熄灭&quot;&gt;4.1 按下Home键或者当屏幕熄灭&lt;/h3&gt;

&lt;p&gt;这种情况下会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;; 需要注意的是这里仍然调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;; 但是该情况下是不会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;, 原因下面说明&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;调用的几点说明:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;的调用: &lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;会在当&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;有可能被销毁的时候调用, 用于进行数据保存; 注意, 只要是&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;有可能被销毁都会调用方法; 比如: 按下&lt;code class=&quot;highlighter-rouge&quot;&gt;Home&lt;/code&gt;键或者屏幕熄灭&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;进行后台的时候, 该&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可能被回收, 所以此时会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;的调用和&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;的调用不一定是成对的, &lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;要调用的前提是当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;&lt;strong&gt;确实&lt;/strong&gt;被系统销毁了&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;42-透明对话框或者透明activity&quot;&gt;4.2 透明对话框或者透明Activity&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;上覆盖一层透明对话框的时候, 不会使&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;进入后台(不会调用任何方法), 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;不可和当前用户交互&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当当前&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;启动一个透明&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的时候, 会调用前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onPause&lt;/code&gt;, 但是不会调用前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;, 此时前一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;可见但是处于后台&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-注&quot;&gt;五. 注&lt;/h2&gt;

&lt;p&gt;验证代码参见: &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/lifecycle/ReadMe.md&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 13 Oct 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/10/13/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/10/13/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
        
        <category>Android</category>
        
        
      </item>
    
  </channel>
</rss>
