<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 28 Sep 2018 22:03:34 +0800</pubDate>
    <lastBuildDate>Fri, 28 Sep 2018 22:03:34 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Java垃圾收集器与内存分配策略</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文为«深入理解Java虚拟机»第三章以及部分博客内容总结, 权作个人笔记~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自: http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-对象是否死亡&quot;&gt;一. 对象是否死亡&lt;/h2&gt;

&lt;p&gt;进行垃圾收集首先需要的就是判断对象是否死亡, 也就是是否可以清除收集, 下面将讲解判断对象是否死亡的方法&lt;/p&gt;

&lt;h3 id=&quot;11-引用计数算法&quot;&gt;1.1 引用计数算法&lt;/h3&gt;

&lt;h4 id=&quot;111-原理&quot;&gt;1.1.1 原理&lt;/h4&gt;

&lt;p&gt;给对象添加一个引用计数, 每当有一个地方引用它, 计数器值就加&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 当引用失效时, 计数器值就减&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;; 任何时刻计数器值为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的对象就是不可能再被使用的&lt;/p&gt;

&lt;h4 id=&quot;112-优缺点&quot;&gt;1.1.2 优缺点&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;: 实现简单, 效率高&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;: 无法解决循环引用的问题, 如下;&lt;/p&gt;

&lt;p&gt;主流&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有使用引用计数来管理内存的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ReferenceCountingGC {

    public Object instance = null;
    private final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB]; // 占用内存, 以便GC日志中看清楚是否被回收过

    public static void main(String[] args) {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        System.gc();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12-可达性分析算法&quot;&gt;1.2 可达性分析算法&lt;/h3&gt;

&lt;h4 id=&quot;121-原理&quot;&gt;1.2.1 原理&lt;/h4&gt;

&lt;p&gt;通过一系列成为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象作为起始点, 从这些节点开始往下搜索, 搜索走过的路径称为引用链, 当一个对象到&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;没有任何引用链相连时, 则证明此对象是不可引用的; 如下图(&lt;a href=&quot;https://llag9810.github.io/2017/12/04/Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/&quot;&gt;图片来自&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/GcRoot.png&quot; alt=&quot;GC Root&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可作为&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;的对象:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中类静态属性引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法区中常量引用的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地方法栈中&lt;code class=&quot;highlighter-rouge&quot;&gt;JNI&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法)引用的变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用可达性分析算法时, 至少需要经过两次标记过程才能宣告一个对象真正死亡: 如果对象在进行可达性分析后发现没有与&lt;code class=&quot;highlighter-rouge&quot;&gt;GC Root&lt;/code&gt;相连接的引用链, 那它会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 当对象没有覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;放啊发, 或者&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法已经被虚拟机调用过, 虚拟机将这两种情况都视为没有必要执行(也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法最多执行一次, 这点需要注意~);
如果这个对象被判定为有必要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法, 那么这个对象将会放置在一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;F-Queue&lt;/code&gt;的队列中, 并在稍后由一个由虚拟机自动建立, 低优先级的&lt;code class=&quot;highlighter-rouge&quot;&gt;Finalizer&lt;/code&gt;线程去执行它, 但并不承诺会等待&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;方法运行结束(这里也需要注意, 这是为了防止&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中出现耗时操作甚至死循环); 在&lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;中对象可以使自己再次加入引用链中, 逃脱&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; &lt;strong&gt;但是不建议使用该方法来逃脱GC&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class FinalizeEscapeGC {
    public static FinalizeEscapeGC finalizeEscapeGC = null;

    int count = 0;

    public void isAlive() {
        System.out.println(&quot;Yes, I am alive :) &quot;);
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;finalize method executed&quot;);
        FinalizeEscapeGC.finalizeEscapeGC = this; // 再次进入引用链
        // 经过验证, 虚拟机不会等待finalize()执行完毕
//        while (true) {
//            System.out.println(count++);
//        }
    }

    public static void main(String[] args) throws InterruptedException {
        finalizeEscapeGC = new FinalizeEscapeGC();
        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }

        finalizeEscapeGC = null;
        System.gc();
        Thread.sleep(500);
        if (finalizeEscapeGC == null) {
            System.out.println(&quot;No, I am dead :(&quot;);
        } else {
            finalizeEscapeGC.isAlive();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述程序运行结果为: 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;finalize()&lt;/code&gt;确实被调用了, 而且只被调用了一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;finalize method executed
Yes, I am alive :)
No, I am dead :(
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-再谈引用&quot;&gt;1.3 再谈引用&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;以前, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;引用很传统: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;reference&lt;/code&gt;类型的数据中存储的数值代表的是另一块内存的起始地址, 就称这块内存代表着一个引用&lt;/p&gt;

&lt;p&gt;但是实际我们希望的是: 当内存空间还足够时, 能够保留在内存中; 当内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃某些对象&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.2&lt;/code&gt;之后, 扩充了引用概念:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 以下引用强度递减&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;强引用: 类似&lt;code class=&quot;highlighter-rouge&quot;&gt;Object obj = new Object()&lt;/code&gt;的引用; 这类引用永远不会被垃圾收集器回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软引用: 有用但非必需的对象; 在系统将要发生内存溢出之前, 将回收这部分对象, 如果回收之后内存仍然不够, 才会内存溢出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;弱引用: 无论当前内存是否足够都会回收掉只被弱引用关联的对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虚引用: 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过一个虚引用来取得对象实例; 为一个对象设置虚引用关联的唯一目的是能在这个对象被收集器回收之前收到一个系统通知&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;14-方法区回收&quot;&gt;1.4 方法区回收&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;的主要区域是堆, 但是方法区也会进行&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;; 方法区的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;主要是废弃常量和无用的类&lt;/p&gt;

&lt;p&gt;废弃常量好理解, 和堆中对象回收一样, 没有引用即回收&lt;/p&gt;

&lt;p&gt;无用类需要满足条件:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;该类的所有实例都已经被回收, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中不存在该类的任何实例&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载该类的&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassLoader&lt;/code&gt;已经被回收&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;该类对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Class&lt;/code&gt;对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-垃圾收集算法&quot;&gt;二. 垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&quot;21-标记-清除算法mark-sweep&quot;&gt;2.1 标记-清除算法(Mark-Sweep)&lt;/h3&gt;

&lt;h4 id=&quot;211-原理&quot;&gt;2.1.1 原理&lt;/h4&gt;

&lt;p&gt;先标记, 后回收咯&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记清除算法.png&quot; alt=&quot;标记清除算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;212-优缺点&quot;&gt;2.1.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;标记和清除的效率都不高&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;产生大量不连续的内存碎片&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-复制算法&quot;&gt;2.2 复制算法&lt;/h3&gt;

&lt;p&gt;多用于新生代&lt;/p&gt;

&lt;h4 id=&quot;221-原理&quot;&gt;2.2.1 原理&lt;/h4&gt;

&lt;p&gt;将内存分成相等的两块, 每次只使用其中一块, 当这一块用完了, 就将还存活的对象复制到另一块, 然后把使用过的内存空间一次清掉&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/复制算法.png&quot; alt=&quot;复制算法&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;222-优缺点&quot;&gt;2.2.2 优缺点&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;效率高, 无碎片&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每次可使用内存减半&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;23-标记-整理算法&quot;&gt;2.3 标记-整理算法&lt;/h3&gt;

&lt;p&gt;多用于老年代&lt;/p&gt;

&lt;h4 id=&quot;231-原理&quot;&gt;2.3.1 原理&lt;/h4&gt;

&lt;p&gt;让所有存活对象都向一端移动, 然后清理掉端边界以外的内存&lt;/p&gt;

&lt;p&gt;如下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/标记整理算法.png&quot; alt=&quot;标记整理算法&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-分代收集算法&quot;&gt;2.4 分代收集算法&lt;/h3&gt;

&lt;h4 id=&quot;241-分代&quot;&gt;2.4.1 分代&lt;/h4&gt;

&lt;p&gt;分代的依据是: 不同对象的生命周期不同; 因此不同对象可以采用不同的回收方式, 以便提高回收效率; 因为如果每次都对整个堆进行回收遍历的话, 对于生命周期较长的对象而言, 实际上有很多次回收都是不必要和没用的&lt;/p&gt;

&lt;p&gt;分代:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/分代.png&quot; alt=&quot;分代&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分为年轻代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Young Generation&lt;/code&gt;), 老年代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Old Generation&lt;/code&gt;)和永久代(&lt;code class=&quot;highlighter-rouge&quot;&gt;Permanent Generation&lt;/code&gt;); 永久代主要存放的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;类的类信息, 与垃圾收集要收集的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;对象关系不大; 年轻代和老年代的划分是对垃圾收集影响比较大的&lt;/p&gt;

&lt;h4 id=&quot;242-原理&quot;&gt;2.4.2 原理&lt;/h4&gt;

&lt;p&gt;新生代采用复制算法, 有老年代作空间担保; 老年代中因为对象存活率高, 没有额外空间对它进行分配担保, 就必须使用&lt;strong&gt;标记-清理&lt;/strong&gt;或者&lt;strong&gt;标记-整理&lt;/strong&gt;算法&lt;/p&gt;

&lt;p&gt;关于分代收集算法更详细信息, 可以参见博客: http://hllvm.group.iteye.com/group/wiki/2863-JVM&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-内存分配与回收策略&quot;&gt;三. 内存分配与回收策略&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对象优先在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;分配, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;没有足够空间时, 将发起一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;(指发生在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;GC&lt;/code&gt;, 较为频繁, 但是速度也快)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大对象直接进入老年代, 这是为了防止在新生代的&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;和两个&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区之间发生大量的内存复制&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;长期存活的对象直接进入老年代; 虚拟机给每个对象定义一个年龄计数器, 如果对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Eden&lt;/code&gt;区出生并经过第一&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;后仍然存活, 并且能被&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区容纳, 将被移到&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中, 并且对象年龄设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 对象在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;区中没度过一次&lt;code class=&quot;highlighter-rouge&quot;&gt;Minor GC&lt;/code&gt;, 年龄就增&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 当其年龄达到一定程度(默认&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;岁), 则移入老年代&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;动态对象年龄判定, 如果在&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间中相同年龄所有对象大小的总和大于&lt;code class=&quot;highlighter-rouge&quot;&gt;Survivor&lt;/code&gt;空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 而不必等到年龄达到阈值&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 28 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/28/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/28/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之常用工具</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将要讲解的是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中常用的一些工具类&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-canvas&quot;&gt;一. Canvas&lt;/h2&gt;

&lt;p&gt;drawXXX: 绘制相关&lt;/p&gt;

&lt;p&gt;clipXXX: 裁剪; 使用裁剪的时候, 通常需要配合save()和restore()一起使用, 否则之后所有的绘制都会被裁剪
范围裁切有两个方法： clipRect() 和 clipPath()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;几何变换(平移, 旋转, 伸缩等):&lt;/p&gt;

&lt;p&gt;几何变换的使用大概分为三类：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 Canvas 来做常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Matrix 来做常见和不常见的二维变换；&lt;/li&gt;
  &lt;li&gt;使用 Camera 来做三维变换。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Matrix; 或者自带的translate(), rotate(), scale(), skew()(错切); 
需要注意的是, Canvas自带的几何变换是倒序的, 比如: 如果translate()在rotate()前面, 则实际执行顺序是先rotate(), 再translate(); 
Canvas自带的几何变换内部其实也是使用的Matrix
Matrix可以自定义执行顺序, 通常Matrix的方法都是成对的, 比如: preTranslate()(往前插入)和postTranslate()(往后插入)
Camare可以用于辅助Matrix计算; 比如: 如下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onDraw(Canvas canvas) {
    canvas.save();

    camare.save();
    camare.rotateX(30);
    canvas.translate(centerX, centerY); // 注意这里的顺序要倒着, 因为上面说了, Canvas几何变换的顺序是倒着的
    camare.applyToCanvas(canvas); // 同时, 由于camare执行旋转操作的时候, 是以原点为中心的, 所以, 如果这里不配合canvas的平移操作来使用的话, 最终图像是歪的; 但是camare又不支持设置中心, 所以就只能先将图像平移到原点, camare作用完之后再平移回原来的位置; 注意, 虽然Camare也有translate()方法, 但是Camare的变换是会带着整个三维坐标系一起的, 而且它在变换结束之后才会做投影, 而不是一旋转完就立即投影到Canvas上去, 这样如果用Camare做移动,
    那么绘制出来的结果就完全不是预期的样子了(这里的解释不是很懂)
    canvas.translate(-centerX, -centerY);
    camare.restore();

    canvas.restore();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Camare坐标系: 使用的是三维坐标系, 原点也是View左上角; x轴右正左负, y轴上正下负(注意y轴不一样咯, 和View坐标系相反), z轴垂直于View, 内正外负(朝屏幕里面为正, 朝屏幕外面为负); 还包含了一个虚拟的Camare对象, 即一个虚拟的相机, 默认在z轴负向, 即View坐标原点的正上方
Camare的旋转方向没有规律, 见Download文件夹下照片
Camare也是可以沿着x, y, z轴平移的, 比如沿着z轴平移, 就相当于将物体远离或者靠近相机, 即起到放大缩小的作用, 但是由于这种情况也可以直接使用Canvas的scale()等来做到, 所以实际开发中一般都用Canvas自带的方法来实现
Camare还可以通过setLocation()来设置虚拟相机的位置, 这种的使用情况是, 比如进行旋转时会造成物体投影太大(因为相机离物体太近), 此时可以通过setLocation()来设置相机位置远离物体, 使投影缩小; 一般使用时都是沿着z轴移动Camare, 不常见沿着x, y轴移动的
Camare变换的时候也需要save()和restore()&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;重写其他方法体现遮盖(联系draw过程, 如: 绘制前景, 绘制背景等)&lt;/p&gt;

&lt;p&gt;drawColor: 可以用于填充背景或者设置半透明蒙版&lt;/p&gt;

&lt;h2 id=&quot;二-paint&quot;&gt;二. Paint&lt;/h2&gt;

&lt;p&gt;关于Paint, 请参见: https://hencoder.com/ui-1-2/&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;颜色: 
setColor()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;setShader(): 着色器, 着色器设置的是一个颜色方案，或者说是一套着色规则; 当设置了 Shader 之后，Paint 在绘制图形和文字时就不使用 setColor/ARGB() 设置的颜色了，而是使用  Shader 的方案中的颜色。LinearGradient RadialGradient SweepGradient BitmapShader ComposeShader&lt;/p&gt;

&lt;p&gt;setColorFilter(): ColorFilter; 共有三个子类：LightingColorFilter PorterDuffColorFilter 和 ColorMatrixColorFilter&lt;/p&gt;

&lt;p&gt;setXfermode(): Xfermode 指的是你要绘制的内容和 Canvas 的目标位置的内容应该怎样结合计算出最终的颜色; 唯一子类: PorterDuffXfermode&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抗锯齿、填充/轮廓、线条宽度等&lt;/p&gt;

&lt;p&gt;setAntiAlias()&lt;/p&gt;

&lt;p&gt;setStyle()&lt;/p&gt;

&lt;p&gt;线条形状: setStrokeWidth(float width),  setStrokeCap(Paint.Cap cap), setStrokeJoin(Paint.Join join),  setStrokeMiter(float miter)&lt;/p&gt;

&lt;p&gt;色彩优化: setDither(boolean dither) 和  setFilterBitmap(boolean filter)&lt;/p&gt;

&lt;p&gt;setPathEffect(): PathEffect 分为两类，单一效果的 CornerPathEffect DiscretePathEffect DashPathEffect PathDashPathEffect ，和组合效果的 SumPathEffect ComposePathEffect&lt;/p&gt;

&lt;p&gt;什么是硬件加速: https://developer.android.com/guide/topics/graphics/hardware-accel&lt;/p&gt;

&lt;p&gt;setShadowLayer(): 在绘制层下方添加效果
setMaskFilter(): 在绘制层上方添加效果; BlurMaskFilter 和 EmbossMaskFilter&lt;/p&gt;

&lt;p&gt;获取绘制的 Path&lt;/p&gt;

&lt;h3 id=&quot;drawtext相关&quot;&gt;drawText()相关&lt;/h3&gt;

</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>Java内存区域与内存溢出异常</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文是对«深入理解Java虚拟机»第二章以及其他博客的阅读总结&lt;/p&gt;

&lt;p&gt;重点是需要去理解各区域存储的是什么, 以此从底层理解对象的创建与引用等过程; 同时还需要明确的一点是各部分会产生的异常, 以及产生异常的原因&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 文中部分图片来自网络, 但是忘了出处, 侵删~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-基本概念&quot;&gt;一. 基本概念&lt;/h2&gt;

&lt;p&gt;在开始讲解之前, 需要先明确关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;的一些基本概念&lt;/p&gt;

&lt;p&gt;我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;是一个跨平台的语言, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;跨平台的基本支撑其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;对操作系统底层细节的屏蔽, 相当于加了一个中间层(计算机中的任何问题都可以加一个中间层解决~), &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;不再像&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;等语言一样直接翻译为针对特殊平台的机器码, 而是翻译为字节码, 也即是我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 下图大概可以比较简明的概括了~; 字节码就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;世界中的汇编, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;则不是跨平台的, 只是不同平台的&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;都能识别和运行标准格式的字节码文件而已&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/Java编译.png&quot; alt=&quot;Java编译&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;文件, 我觉得下图已经可以比较准确的表达了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们下面要讲的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Runtime Data Area&lt;/code&gt;部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-运行时数据区&quot;&gt;二. 运行时数据区&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;会在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;程序的时候把它所管理的内存划分为若干个不同的数据区, 如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/JVM/JVM内存区域.png&quot; alt=&quot;JVM&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-程序计数器&quot;&gt;2.1 程序计数器&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;211-存储数据类型&quot;&gt;2.1.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;指向下一条需要执行的字节码指令; 如果线程正在执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法, 该计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法, 该计数器值则为空(&lt;code class=&quot;highlighter-rouge&quot;&gt;Undefined&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&quot;212-异常情况&quot;&gt;2.1.2 异常情况&lt;/h4&gt;

&lt;p&gt;该区域是是唯一一个在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;虚拟机中没有规定任何&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;情况的区域&lt;/p&gt;

&lt;h3 id=&quot;22-java虚拟机栈&quot;&gt;2.2 Java虚拟机栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;221-存储数据类型&quot;&gt;2.2.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;描述&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;方法执行的内存模型, 每个方法调用就对应着一个栈帧的入栈和出栈; 一个栈帧里面存储了局部变量表, 操作数栈, 动态链接, 方法出口等信息&lt;/p&gt;

&lt;p&gt;局部变量表存储了编译器可知的各种基本数据类型, 对象引用, &lt;code class=&quot;highlighter-rouge&quot;&gt;returnAddress&lt;/code&gt;; 局部变量表的大小在编译期间即可确定, 运行期间大小不变&lt;/p&gt;

&lt;h4 id=&quot;222-异常情况&quot;&gt;2.2.2 异常情况&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;StackOverflowError&lt;/strong&gt;: 线程请求栈深度大于虚拟机允许深度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackSOF {

    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF sof = new JavaVMStackSOF();
        try {
            sof.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;Stack Length: &quot; + sof.stackLength);
            throw e;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;OutOfMemoryError&lt;/strong&gt;: 虚拟机栈动态扩展时无法申请到足够内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;异常示例代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {
        }
    }

    public void stackLeakByThread() {
        while (true) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    dontStop();
                }
            }).start();
        }
    }

    public static void main(String[] args) {
        JavaVMStackOOM oom = new JavaVMStackOOM();
        oom.stackLeakByThread();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 由于操作系统分配给每个进程的内存空间是有限制的, 所以如果是由于建立过多的线程导致内存溢出, 在不能减少线程数或者更换&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位虚拟机的情况下, 可以选择通过减少最大堆和减少栈容量来换取更多的线程&lt;/p&gt;

&lt;h3 id=&quot;23-本地方法栈&quot;&gt;2.3 本地方法栈&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;线程私有&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;231-存储数据类型&quot;&gt;2.3.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;和虚拟机栈类似, 只是本地方法栈提供的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;方法服务&lt;/p&gt;

&lt;h4 id=&quot;232-异常情况&quot;&gt;2.3.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StackOverflowError&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;24-java堆&quot;&gt;2.4 Java堆&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;垃圾收集管理的主要区域&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;241-存储数据类型&quot;&gt;2.4.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;几乎所有的对象实例都在这里分配&lt;/p&gt;

&lt;h4 id=&quot;242-异常情况&quot;&gt;2.4.2 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class JavaVMHeapOOM {

    static class HeapOOM {
    }

    public static void main(String[] args) {
        List&amp;lt;HeapOOM&amp;gt; list = new ArrayList();
        while (true) {
            list.add(new HeapOOM());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25-方法区&quot;&gt;2.5 方法区&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;线程共享&lt;/li&gt;
    &lt;li&gt;该区域的垃圾回收目标主要是针对常量池的回收和对类型的卸载&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;251-存储数据类型&quot;&gt;2.5.1 存储数据类型&lt;/h4&gt;

&lt;p&gt;存储已被虚拟机加载的类信息, 常量, 静态变量, 即使编译器编译后的代码等数据&lt;/p&gt;

&lt;h4 id=&quot;252-运行时常量池&quot;&gt;2.5.2 运行时常量池&lt;/h4&gt;

&lt;p&gt;运行时常量池是方法区的一部分, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK6&lt;/code&gt;之后, 常量池被放入了堆中;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件中也有常量池部分, 即编译期生成的各种字面量和符号引用, 这部分将在类加载后进入方法区的运行时常量池中, 此外还会把翻译出来的直接引用也存储在运行时常量池中&lt;/p&gt;

&lt;p&gt;运行时常量池相对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;文件常量池的另外一个最重要的特征是具备动态性, 即运行期间也可以将新的常量放入池中, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;intern()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;String.intern()&lt;/code&gt;作用是: 如果字符串常量池中已经包含一个等于此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的字符串, 则返回代表池中这个字符串的&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象; 否则, 将此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象包含的字符串添加到常量池中, 并且返回此&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;对象的引用&lt;/p&gt;

&lt;p&gt;同样, 收方法区的限制, 当常量池无法再申请到内存时会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;253-异常情况&quot;&gt;2.5.3 异常情况&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;: 方法区无法满足内存分配需求&lt;/p&gt;

&lt;p&gt;异常示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class RuntimeConstantPoolOOM {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int i = 0;
        while (true) {
            list.add(String.valueOf(i++).intern());
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;26-直接内存&quot;&gt;2.6 直接内存&lt;/h3&gt;

&lt;p&gt;直接内存不是虚拟机运行时数据区的一部分, 但是也被频繁使用, 如: 在&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK1.4&lt;/code&gt;中新加入了&lt;code class=&quot;highlighter-rouge&quot;&gt;NIO&lt;/code&gt;类, 引入了一种基于通道(&lt;code class=&quot;highlighter-rouge&quot;&gt;Chanel&lt;/code&gt;)和缓冲区(&lt;code class=&quot;highlighter-rouge&quot;&gt;Buffer&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;方式, 它可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;函数库直接分配堆外内存, 然后通过一个存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆中的&lt;code class=&quot;highlighter-rouge&quot;&gt;DirectByteBuffer&lt;/code&gt;对象作为这块内存的引用进行操作, 避免了在&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;堆和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;堆中来回复制数据, 提高性能&lt;/p&gt;

&lt;p&gt;同样会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-常见问题&quot;&gt;三. 常见问题&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 下文摘自文末参考链接, 权作个人笔记~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序运行永远都是在栈中进行的，因而参数传递时, 只存在传递基本类型和对象引用的问题, 不会直接传对象本身;  但是传引用的错觉是如何造成的呢? 在运行栈中, 基本类型和引用的处理是一样的, 都是传值, 所以, 如果是传引用的方法调用, 也同时可以理解为“传引用值”的传值调用, 即引用的处理跟基本类型是完全一样的; 但是当进入被调用方法时, 被传递的这个引用的值, 被程序解释(或者查找)到堆中的对象, 这个时候才对应到真正的对象; 如果此时进行修改; 修改的是引用对应的对象; 而不是引用本身; 即: 修改的是堆中的数据; 所以这个修改是可以保持的了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我产生的对象不多呀, 为什么还会产生&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;答: 你继承层次忒多了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Heap&lt;/code&gt;中产生的对象是先产生父类, 然后才产生子类, 明白不?&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemory&lt;/code&gt;错误分几种?
答: 分两种, 分别是&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError:java heap size&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutOfMemoryError: PermGen space&lt;/code&gt;, 两种都是内存溢出, &lt;code class=&quot;highlighter-rouge&quot;&gt;heap size&lt;/code&gt;是说申请不到新的内存了, 这个很常见，检查应用或调整堆内存大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;PermGenspace&lt;/code&gt;是因为永久存储区满了, 这个也很常见, 一般在热发布的环境中出现, 是因为每次发布应用系统都不重启, 久而久之永久存储区中的死对象太多导致新对象无法申请内存, 一般重新启动一下即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么不建议在程序中显式的生命&lt;code class=&quot;highlighter-rouge&quot;&gt;System.gc()&lt;/code&gt;?
答: 因为显式声明是做堆内存全扫描, 也就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Full GC&lt;/code&gt;, 是需要停止所有的活动的(&lt;code class=&quot;highlighter-rouge&quot;&gt;Stop The World Collection&lt;/code&gt;), 你的应用能承受这个吗?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.importnew.com/1993.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.cnblogs.com/dolphin0520/p/3783345.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/2905-JVM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://hllvm.group.iteye.com/group/wiki/?show_full=true&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 27 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/27/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java之IO流</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中一个比较重要的模块–&lt;code class=&quot;highlighter-rouge&quot;&gt;I/O&lt;/code&gt;流&lt;/p&gt;

&lt;p&gt;以下内容是对&lt;strong&gt;Java核心技术卷II&lt;/strong&gt;的总结, 权做个人笔记~&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java I/O&lt;/code&gt;流指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.io&lt;/code&gt;包和&lt;code class=&quot;highlighter-rouge&quot;&gt;java.nio&lt;/code&gt;包提供的各种操作文件和输入输出等的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 具体可以分为两大类: 一类是面向字节的, 一类是面向字符的; 面向字节的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;是以&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStream&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStream&lt;/code&gt;类为基类, 每次以一个字节为单位进行读写操作; 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;指的是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt;为基类, 每次以两个字节为单位进行读写操作, 面向字符的&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;主要是针对文本操作设计的&lt;/p&gt;

&lt;p&gt;可以参见下图:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字节&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字节.png&quot; alt=&quot;面向字节&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向字符&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_IO/面向字符.png&quot; alt=&quot;面向字符&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: &lt;a href=&quot;https://blog.csdn.net/zhoupenglei/article/details/46312405&quot;&gt;图片来源&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-重要概念&quot;&gt;二. 重要概念&lt;/h2&gt;

&lt;h3 id=&quot;21-流嵌套&quot;&gt;2.1 流嵌套&lt;/h3&gt;

&lt;p&gt;即将不同功能的流嵌套起来, 过滤; 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中流默认是不被缓冲区缓存的, 也就是说每个&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;的调用都会请求操作系统再分发一个字节, 相比之下, 请求一个数据块并将其置于缓冲区中会显得更加高效, 如果我们想使用缓冲机制, 以及用于文件输入方法, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;            BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(&quot;file&quot;));&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-glob模式匹配&quot;&gt;2.2 Glob模式匹配&lt;/h3&gt;

&lt;p&gt;即使用正则筛选文件, 如筛选文件后缀名为&lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;的文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;), &quot;*.java&quot;);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Glob&lt;/code&gt;模式见下表:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;模式&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;示例&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;*&lt;/td&gt;
      &lt;td&gt;匹配路径组成部分中0个或多个字符&lt;/td&gt;
      &lt;td&gt;*.java匹配当前目录中的所有Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;**&lt;/td&gt;
      &lt;td&gt;匹配跨目录边界的0个或多个字符&lt;/td&gt;
      &lt;td&gt;**.java匹配在所有子目录中的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;?&lt;/td&gt;
      &lt;td&gt;匹配一个字符&lt;/td&gt;
      &lt;td&gt;????.java匹配所有四个字符的Java文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[…]&lt;/td&gt;
      &lt;td&gt;匹配一个字符集合&lt;/td&gt;
      &lt;td&gt;Test[0-9A-F].java匹配Testx.java, 其中x是一个十六进制数字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;{…}&lt;/td&gt;
      &lt;td&gt;匹配由逗号隔开的多个可选项之一&lt;/td&gt;
      &lt;td&gt;*.{java, class}匹配所有的Java文件和类class文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\&lt;/td&gt;
      &lt;td&gt;转移上述任意模式中的字符&lt;/td&gt;
      &lt;td&gt;&lt;em&gt;*&lt;/em&gt;匹配所有文件名中包含*的文件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;23-常用工具类&quot;&gt;2.3 常用工具类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Files&lt;/strong&gt;: 使得读写文件和操作文件及文件夹变得简单; 旧的&lt;code class=&quot;highlighter-rouge&quot;&gt;File&lt;/code&gt;类中有一个方法可以用来获取一个目录下的所有文件构成的数组, 但是当目录中包含大量文件时, 这个方法的性能非常低, &lt;code class=&quot;highlighter-rouge&quot;&gt;Files&lt;/code&gt;类设计了一个方法可以产生&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterable&lt;/code&gt;对象, 如下示例代码:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DirectoryStream&amp;lt;Path&amp;gt; entries = Files.newDirectoryStream(Paths.get(&quot;/&quot;));
Iterator&amp;lt;Path&amp;gt; iterator = entries.iterator();
for (Path path : entries) {
    System.out.println(path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Paths&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths&lt;/code&gt;可以用来构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Path&lt;/code&gt;对象: &lt;code class=&quot;highlighter-rouge&quot;&gt;Paths.get(args)&lt;/code&gt;, 可以接收一个或多个字符串, 并将它们用默认文件系统分隔符连接起来&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;24-内存映射文件&quot;&gt;2.4 内存映射文件&lt;/h3&gt;

&lt;p&gt;大多数操作系统都可以利用虚拟内存实现来将一个文件或者文件的一部分”映射”到内存中, 然后这个文件就可以当做是内存数组一样的访问, 中比传统的文件操作要快得多; 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;FileChannel&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;25-易忘类&quot;&gt;2.5 易忘类&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;InputStreamReader&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;OutputStreamWriter&lt;/code&gt;: 可以指定编码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PrintWriter&lt;/code&gt;: 以文本格式写出数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccessFile&lt;/code&gt;: 在任何位置查找或写入数据; 可以用于实现断点续传&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DataInputStream&lt;/code&gt;: 读取数字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectInputStream&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectOutputStream&lt;/code&gt;: 读取对象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;26-文件操作处理效率&quot;&gt;2.6 文件操作处理效率&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;普通输入流&lt;/td&gt;
      &lt;td&gt;110s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;带缓冲的输入流&lt;/td&gt;
      &lt;td&gt;9.9s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;随机方访问文件&lt;/td&gt;
      &lt;td&gt;162s&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内存映射文件&lt;/td&gt;
      &lt;td&gt;7.2s&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 25 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Java%E4%B9%8BIO%E6%B5%81/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View绘制流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之绘制流程&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的绘制流程分为三大步: &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;即测量, 测量&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;即布局, 按照一定的规则排布&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;即绘制, 绘制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的外形; 这三步是和我们自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;息息相关的, 熟悉和掌握这三大流程, 我们才能随心所欲的定制&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;; 本文也将从这三个方面入手, 结合源码讲解&lt;/p&gt;

&lt;p&gt;在开始之前, 需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制的整体流程, 如下图;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View绘制流程.png&quot; alt=&quot;View绘制流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 图片来自: https://www.jianshu.com/p/dc0b039e7c4f&lt;/p&gt;

&lt;p&gt;可以看出, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;三大流程直接相关的是从&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的; 大致流程如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performTraversals() {
    ...
    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ...
    performLayout(lp, mWidth, mHeight);
    ...
    performDraw();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-measure过程&quot;&gt;二. measure过程&lt;/h2&gt;

&lt;p&gt;在开始讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之前, 我们需要先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程的理解还是很重要的&lt;/p&gt;

&lt;h3 id=&quot;21-measurespec&quot;&gt;2.1 MeasureSpec&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的值, 是&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;的位组合; 高&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;, 低&lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;位表示&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 这样设计其实是为了节约空间; 关于二者如何组合, 可以参见以下代码; 可以看出, 其实就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MODE_MASK&lt;/code&gt;掩码以及位操作实现将两个&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型整合为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;位&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;类型的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;; 当然, 要分别提取这两个值的话, 也可以很简单的用位操作实现, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public static int makeMeasureSpec(@IntRange(from = 0, to = (1 &amp;lt;&amp;lt; MeasureSpec.MODE_SHIFT) - 1) int size,
                                          @MeasureSpecMode int mode) {
            if (sUseBrokenMakeMeasureSpec) {
                return size + mode;
            } else {
                return (size &amp;amp; ~MODE_MASK) | (mode &amp;amp; MODE_MASK); // MODE_MASK  = 0x3 &amp;lt;&amp;lt; 30; 
            }
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;即测量模式, 一共有三类:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;: 父容器不对&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;有任何限制, 要多大给多大, 这种情况一般用于系统内部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;: 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和具体数值这两种模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;: 父容器指定了一个可用大小即&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的大小不能大于该值, 对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;的类型区别可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的确定受&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;的影响, 但是也要分情况: 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;RootView&lt;/code&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;来说, 由于其没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由窗口尺寸和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定; 对于普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;来说, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;由父容器传递的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;和自身的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;共同决定&lt;/p&gt;

&lt;p&gt;普通&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;创建规则见下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;childLayoutParams&lt;/strong&gt; \ &lt;strong&gt;parentSpecMode&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;EXACTLY&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;AT_MOST&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;UNSPECIFIED&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;dp/px&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;childSize&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;match_parent&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;EXACTLY&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;strong&gt;wrap_content&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;AT_MOST&lt;br /&gt;parentSize&lt;/td&gt;
      &lt;td&gt;UNSPECIFIED&lt;br /&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 摘自«Android开发艺术探索»&lt;/p&gt;

&lt;p&gt;上面表格中展现的规则需要好好理解:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸是明确的值时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_height&lt;/code&gt;有确定的值, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;是什么, &lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;都保持规定尺寸不变; 这点比较好理解, 因为明确指定&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸之后, 我们肯定希望显示的也是指定尺寸&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;时, 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是确定尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸也能确定, 也就是父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, parentSize&lt;/code&gt;也可以理解; 如果父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸不确定, 此时父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;只知道一个最大尺寸, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;, 也只能知道一个最大尺寸, 而且该最大尺寸不应该超过&lt;code class=&quot;highlighter-rouge&quot;&gt;parentSize&lt;/code&gt;, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout_xxx&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;, 即尺寸大小不确定的话, 那么不管父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是具有确定尺寸还是尺寸不确定, 反正&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;的尺寸始终是不确定的, 所以此时应该为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;, 而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Child&lt;/code&gt;尺寸也不应该超过父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;尺寸, 故综上为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, parentSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-decorview的measure过程&quot;&gt;2.2 DecorView的measure过程&lt;/h3&gt;

&lt;p&gt;我们知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;是整个&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;树的&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;, 我们首先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的测量过程; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getRootMeasureSpec()&lt;/code&gt;来获取&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;, 如下; 结合上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则可以理解&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建规则如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;MATCH_PARENT&lt;/code&gt;, 由于&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;没有父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以其尺寸就为窗口尺寸, &lt;code class=&quot;highlighter-rouge&quot;&gt;SpecMode&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;LayoutParams&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;WRAP_CONTENT&lt;/code&gt;, 此时&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;尺寸不确定, 最大尺寸不应该超过窗口尺寸, 所以为&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST, windowSize&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;明确规定了自己的尺寸, 那么就不受窗口尺寸的影响, 为&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY, rootDimension&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;构建好&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;之后, 就直接传入了&lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;中, &lt;code class=&quot;highlighter-rouge&quot;&gt;performMeasure()&lt;/code&gt;的代码如下; 可以看出, 接下来就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;进行测量, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的, 不可重写, 所以应该追溯到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;(继承链为: &lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;)的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure()&lt;/code&gt;方法中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeausre()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;不是&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的,
所以我们应该去分析的是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        if (mView == null) {
            return;
        }
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的在&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;中将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;进行处理和判断之后, 调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;super.onMeasure()&lt;/code&gt;, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;; 如下, 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onMeasure()&lt;/code&gt;方法中处理了&lt;code class=&quot;highlighter-rouge&quot;&gt;Margin&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;)和&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;getPaddingXXX&lt;/code&gt;), 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;measureChildWithMargins()&lt;/code&gt;中会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;child.measure()&lt;/code&gt;, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递(即递归测量), 这样就将测量工作传递到了子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// DecorView.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    ...
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    ...
}

// FrameLayout.onMeasure()
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int count = getChildCount();
        for (int i = 0; i &amp;lt; count; i++) {
            final View child = getChildAt(i);
            if (mMeasureAllChildren || child.getVisibility() != GONE) {
                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();
                maxWidth = Math.max(maxWidth,
                        child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
                maxHeight = Math.max(maxHeight,
                        child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
                childState = combineMeasuredStates(childState, child.getMeasuredState());
                if (measureMatchParentChildren) {
                    if (lp.width == LayoutParams.MATCH_PARENT ||
                            lp.height == LayoutParams.MATCH_PARENT) {
                        mMatchParentChildren.add(child);
                    }
                }
            }
        }

        // Account for padding too
        maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
        maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
        ...
}

// FrameLayout.measureChildWithMargins()
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
            ....
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程分为&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量过程&lt;/p&gt;

&lt;h3 id=&quot;23-viewgroup的measure过程&quot;&gt;2.3 ViewGroup的measure过程&lt;/h3&gt;

&lt;p&gt;我们来看子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时的测量过程; 其实对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 不同的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;有不同的布局规则, 比如&lt;code class=&quot;highlighter-rouge&quot;&gt;LinearLayout&lt;/code&gt;, 有竖直布局和水平布局两种, 而这两种不同的布局测量方式也不同; 所以我们这里只是简单的看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;对子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的通用测量方式&lt;/p&gt;

&lt;p&gt;代码如下; 测量逻辑比较简单, 也是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后将&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;往下传递, 实现递归测量, 不做细讲啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
        final int size = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i &amp;lt; size; ++i) {
            final View child = children[i];
            if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
            }
        }
}


protected void measureChild(View child, int parentWidthMeasureSpec,
            int parentHeightMeasureSpec) {
        final LayoutParams lp = child.getLayoutParams();
            
        // 获取child的MeasureSpec, 同时考虑Padding
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 递归调用, 又回到了这里
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的一点是子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构建, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getChildMeasureSpec()&lt;/code&gt;为例, 如下; 其构造规则除了考虑了&lt;code class=&quot;highlighter-rouge&quot;&gt;Padding&lt;/code&gt;以外, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;的构造规则表是相同的, 可以结合代码注释再次理解该表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        case MeasureSpec.EXACTLY: // 如果父View尺寸确定
            if (childDimension &amp;gt;= 0) { // childDimension &amp;gt;= 0, 表示的是子View的layout_xxx设置了具体的数值, 因为wrap_content = -2
                                       // match_parent = -1
                resultSize = childDimension; // 那么集合MeasureSpec的构造规则及对应解释, 这里应该为childDimension, EXACTLY
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 同时父View尺寸也确定
                resultSize = size;  // 说明子View尺寸确定, 且为父View尺寸
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸确定
                resultSize = size;  // 说明子View尺寸不确定, 最大不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.AT_MOST: // 如果父View尺寸不确定
            if (childDimension &amp;gt;= 0) {
                resultSize = childDimension; // 如果子View的layout_xxx设置了明确的值
                resultMode = MeasureSpec.EXACTLY; // 那么子View有确定尺寸, 即为设置的值
            } else if (childDimension == LayoutParams.MATCH_PARENT) { // 如果子View的layout_xxx为match_parent, 但是父View的尺寸不定
                resultSize = size; // 那么子View的尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) { // 如果子View的layout_xxx为wrap_content, 父View尺寸不定
                resultSize = size; // 那么子View尺寸也不定, 最大尺寸不应该超过父View尺寸
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        case MeasureSpec.UNSPECIFIED:
            if (childDimension &amp;gt;= 0) {
                // Child wants a specific size... let him have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-view的measure过程&quot;&gt;2.4 View的measure过程&lt;/h3&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;啦~, 只是一个单纯的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;控件而已; 其默认测量规则如下; 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getSuggestedMinimumWidth()&lt;/code&gt;为例, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;指的是&lt;code class=&quot;highlighter-rouge&quot;&gt;android:minWidth&lt;/code&gt;属性, 默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 如果设置了背景, 则返回背景宽度和指定&lt;code class=&quot;highlighter-rouge&quot;&gt;mMinWidth&lt;/code&gt;中的最大值; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;则是返回默认尺寸, 我们只需关心&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;两种情况即可(因为&lt;code class=&quot;highlighter-rouge&quot;&gt;UNSPECIFIED&lt;/code&gt;一般用于系统, 不常用), 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对于这两种情况默认都是返回的&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即传入的尺寸,
我们上面说了&lt;code class=&quot;highlighter-rouge&quot;&gt;AT_MOST&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;模式, &lt;code class=&quot;highlighter-rouge&quot;&gt;EXACTLY&lt;/code&gt;对应&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;和指定数值情况, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getDefaultSize()&lt;/code&gt;将这两种情况都默认返回了&lt;code class=&quot;highlighter-rouge&quot;&gt;specSize&lt;/code&gt;, 即父&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;可用空间, 很明显, 这对于&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;是不支持的(因为此时的&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;就相当于&lt;code class=&quot;highlighter-rouge&quot;&gt;match_parent&lt;/code&gt;), 所以在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 需要自己根据逻辑实现&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的情况, 具体实现可以参见&lt;code class=&quot;highlighter-rouge&quot;&gt;TextView&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ImageView&lt;/code&gt;等对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
}

// 这里以Width为例
protected int getSuggestedMinimumWidth() {
        return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
}

public static int getDefaultSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, 最终我们确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的尺寸之后, 还需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;正真设置和作用到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;上; 需要注意的是, 此时只是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高, 可能不是实际宽高, 实际宽高在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中才能确定, 出现测量宽高和实际宽高不相等的原因 主要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中改变了&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;实际布局的位置尺寸等造成的, 但是一般情况下二者都是相等的&lt;/p&gt;

&lt;h3 id=&quot;25-自定义view时measure过程注意事项&quot;&gt;2.5 自定义View时measure过程注意事项&lt;/h3&gt;

&lt;p&gt;到这里, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;绘制过程中的&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程就已经讲解完了; 但是笔者还想提一下在实际使用, 即自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 还需要注意哪些方面; 这里需要提前声明的是, 下面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不包含&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;, 只是单纯的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;~&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;需要自己实现对&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap_content&lt;/code&gt;的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要自己处理&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;的情况, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;还需要处理&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记住使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setMeasuredDimension()&lt;/code&gt;使测量尺寸生效, 否则会抛异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-layout过程&quot;&gt;三. layout过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程会确定&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;最终的位置和尺寸, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程才是真正实现不同布局的关键; &lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的传递是从&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewRootImp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;开始的, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;开始往下传递&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performLayout()&lt;/code&gt;中则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.layout(0, 0, mView.getMeasuredWidth(), mView.getMeasuredHeight());&lt;/code&gt;, 前面我们已经说过了&lt;code class=&quot;highlighter-rouge&quot;&gt;mView&lt;/code&gt;其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;,
但是这里我们并不去分析&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 因为这是针对某一具体布局而言的; 我们这里选择具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;而言, 其&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法如下; 可以看出其调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;View.layout()&lt;/code&gt;中, 可以看出调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;View.onLayout()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 同时还需要注意一点就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法是由&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;修饰的, 这也就意味着自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的时候, 不能重写&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法, 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;是一个抽象方法, 也就是说我们必须自己去是实现; 其实这也很好理解, 因为对于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;来说, 我们需要实现自己的布局,
这里实现逻辑其实就是写在&lt;code class=&quot;highlighter-rouge&quot;&gt;onLayout()&lt;/code&gt;中即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ViewGroup.layout()
public final void layout(int l, int t, int r, int b) {
    ...
    super.layout(l, t, r, b);
    ...
}

// View.layout()
public void layout(int l, int t, int r, int b) {
    ...
    boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
    ...
    onLayout(changed, l, t, r, b);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 还需要注意一点的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;layout()&lt;/code&gt;方法中还调用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;setFrame()&lt;/code&gt;, 该方法的作用其实是设置&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mRight&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mTop&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mBottom&lt;/code&gt;的值; 这里反应的其实是上文说过的一句话, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程中确定测量宽高, 实际宽高需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程中确定; 这里就是记录&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的实际宽高; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的测量宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredHeight()&lt;/code&gt;来获取, 这在&lt;code class=&quot;highlighter-rouge&quot;&gt;measure&lt;/code&gt;过程之后即可得到; 实际宽高可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getHeight()&lt;/code&gt;来得到,
这在&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程之后可以获取; 至于二者的区别, 这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;为例, 如下; 可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;getMeasuredWidth()&lt;/code&gt;获取的其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MeasureSpec&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;SpecSize&lt;/code&gt;, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;getWidth()&lt;/code&gt;获取的则是实际宽高(因为是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的右边界减去左边界); 上面已经说过了测量宽高和实际宽高的区别, 这里就不再赘述啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final int getMeasuredWidth() {
    return mMeasuredWidth &amp;amp; MEASURED_SIZE_MASK;
}

public final int getWidth() {
    return mRight - mLeft;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程比较简单, 也是一个递归调用的过程, 至于自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时主要是在自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;需要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;layout&lt;/code&gt;过程的设计, 需要考虑的还是要&lt;code class=&quot;highlighter-rouge&quot;&gt;padding&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;margin&lt;/code&gt;的影响啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-draw过程&quot;&gt;四. draw过程&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw&lt;/code&gt;过程其实就是其&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt;中, 最终会调用到&lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;(实际上调用栈是: &lt;code class=&quot;highlighter-rouge&quot;&gt;performTraversals()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;performDraw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;drawSoftware()&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mView.draw()&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时官方并不建议去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法, 而是建议重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;去实现自己的逻辑, &lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中实际上是一个空实现; 我们这里先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;的实现逻辑&lt;/p&gt;

&lt;p&gt;官方文档注释中已经说明了&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;过程的实现逻辑, 如下; 可以看出, 主要绘制逻辑为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;绘制背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制内容(即自己)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;绘制装饰, 如滚动条等前景&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 第&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;步和第&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;步一般会跳过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// View.draw()
public void draw(Canvas canvas) {
        ...
        /*
         *      1. Draw the background
         *      2. If necessary, save the canvas' layers to prepare for fading
         *      3. Draw view's content
         *      4. Draw children
         *      5. If necessary, draw the fading edges and restore layers
         *      6. Draw decorations (scrollbars for instance)
         */
        ...
         // Step 1, draw the background, if needed
         if (!dirtyOpaque) {
             drawBackground(canvas);
         }
         // skip step 2 &amp;amp; 5 if possible (common case)
         // Step 3, draw the content
         if (!dirtyOpaque) 
            onDraw(canvas);
         // Step 4, draw the children
         dispatchDraw(canvas);
         // Step 6, draw decorations (foreground, scrollbars)
         onDrawForeground(canvas);
         ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们知道, 绘制内容这一步是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;onDraw()&lt;/code&gt;, 即我们自己自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时需要实现的内容; 另外, 这里需要注意的一点是绘制子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchDraw()&lt;/code&gt;去传递绘制绘制过程, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中是一个空实现, 一般用于&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;时; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;中其实现如下; 其实就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后依次调用子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;draw()&lt;/code&gt;方法绘制出子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void dispatchDraw(Canvas canvas) {
    ...
    for (int i = 0; i &amp;lt; childrenCount; i++) {
        ...
        more |= drawChild(canvas, transientChild, drawingTime); // 在drawChild()中调用child.draw(canvas, this, drawingTime)将绘制过程传递
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的整个绘制流程就讲解完成啦~, 当然这对于我们随心所欲的实现炫酷的自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;还是第一步理论基础, 真正要做到还是需要靠自己多动手去画咯~&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/24/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>自定义View之View事件分发机制</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;源码分析之&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列之事件分发机制&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的触摸事件分发是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;系列中的一个重难点, 主要需要掌握的是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的传递规则和处理规则, 这是自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中冲突处理的理论来源~&lt;/p&gt;

&lt;p&gt;触摸事件分发的处理主要是对&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;的处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;封装了用户的一系列行为, 如: &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指刚触摸屏幕), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指在屏幕上滑动), &lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;(手指抬起)等; 以及事件发生的坐标(通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getX()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent.getY()&lt;/code&gt;可以得到)等&lt;/p&gt;

&lt;p&gt;在开始讲解之前需要明确的一些概念是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个事件序列: 指的是一次完整的触摸过程, 即从&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;(手指触摸屏幕)开始, 到中间的一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;(手指滑动), 最后到&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;为止(手指抬起); 总结起来就是&lt;code class=&quot;highlighter-rouge&quot;&gt;down...move...move..up&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触摸事件的分发其实是一个从上到下不断递归传递和拦截的过程; 一个大致的传递流程是: &lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt; –&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 当然如果向下传递但是&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;又没有消耗的话, 又会逐层返回, 最终将没有消耗的&lt;code class=&quot;highlighter-rouge&quot;&gt;MotionEvent&lt;/code&gt;交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;处理&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-事件分发之源&quot;&gt;二. 事件分发之源&lt;/h2&gt;

&lt;p&gt;触摸事件产生和分发的源头是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中处理的, 即在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;中; 如下; 处理思路也很简单, 只是单纯的向下分发而已, 如果事件没有得到处理, 那么最终就交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理; 另外, 这里还为用户提供了一个监听和拦截事件的方法, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;onUserInteraction()&lt;/code&gt;, 该方法在&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中是一个空实现, 可以重写该方法在事件向下传递之前进行特殊拦截和处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();  // 自定义事件拦截
        }
        if (getWindow().superDispatchTouchEvent(ev)) {  // 通过Window向下分发事件
            return true;
        }
        return onTouchEvent(ev);  // 如果事件最终没有被处理, 那么交给Activity自己的onTouchEvent()来处理
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Window&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow&lt;/code&gt;, 这里通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PhoneWindow.superDispatchTouchEvent()&lt;/code&gt;传递实际上是只是简单调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor.superDispatchTouchEvent(event)&lt;/code&gt;, 而这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mDecor&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;, 是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;FrameLayout&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;), 在&lt;code class=&quot;highlighter-rouge&quot;&gt;DecorView&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;superDispatchTouchEvent()&lt;/code&gt;方法中, 也只是简单的将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行分发(即&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;); 到这里就将事件传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了, 也是事件分发处理中最主要的一部分&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-viewgroup分发事件&quot;&gt;三. ViewGroup分发事件&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup.dispatchTouchEvent()&lt;/code&gt;中对事件的分发处理过程比较长, 实际上大致分成了三个部分来处理&lt;/p&gt;

&lt;h3 id=&quot;31-事件拦截&quot;&gt;3.1 事件拦截&lt;/h3&gt;

&lt;p&gt;首先, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;会判断是否进行事件拦截, 如下; 从后面将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的条件可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截, 那么该事件序列将不再向下分发; 这里还需要注意的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;判断是否进行事件拦截的条件一个是为&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget != null&lt;/code&gt;时; 也就是说一个事件序列的在开始时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;(当然, 还有一个影响因素是&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 我们稍后讲解); 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的赋值是在后面分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;时, 如果有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值;&lt;/p&gt;

&lt;p&gt;上面是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截的基本思路, 简单总结起来就是:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行了事件拦截(&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;), 那么同一事件序列将不再向下分发(因为之后的&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_MOVE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_UP&lt;/code&gt;到来时, 由于之前&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时进行了事件拦截, &lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;没有机会赋值, 所以仍然为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 故直接走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;语句, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;intercepted = true&lt;/code&gt;);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;将会被赋值, 即不为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 此时仍然会继续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;判断是否进行事件拦截, 需要注意的是此时仍然在同一事件序列中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 并且在事件向下分发时, 也没有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;仍为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 即走&lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt;, 交由&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不处理事件时, &lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;才只会调用一次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            // ViewGroup是否进行事件拦截
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                final boolean disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0;
                if (!disallowIntercept) {
                    intercepted = onInterceptTouchEvent(ev);
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
            }

            if (!canceled &amp;amp;&amp;amp; !intercepted) { // 如果拦截事件, 将不再分发给子View
                // 事件分发给子View
                ....
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 上面还讲了, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;时, 一定会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent&lt;/code&gt;, 这里还有一个影响因素是标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;FLAG_DISALLOW_INTERCEPT&lt;/code&gt;, 该标志位是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;requestDisallowInterceptTouchEvent()&lt;/code&gt;设置的, 作用是在子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中强制父&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截, 但是该标志位不能影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;, 因为在一个事件序列开始之前会先进行状态重置, 如下; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;resetTouchState()&lt;/code&gt;中会将该标志位重置, 所以就不会影响&lt;code class=&quot;highlighter-rouge&quot;&gt;ACTION_DOWN&lt;/code&gt;啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);
                resetTouchState(); // 状态重置
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-事件分发&quot;&gt;3.2 事件分发&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;不进行事件拦截的话, 会将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理; 事件分发的主要代码如下; 逻辑也比较简单, 就是遍历所有的子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;进行将事件传递给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                    if (!canceled &amp;amp;&amp;amp; !intercepted) {
                        ...
                        for (int i = childrenCount - 1; i &amp;gt;= 0; i--) {
                            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                                // Child wants to receive touch within its bounds.
                                mLastTouchDownTime = ev.getDownTime();
                                if (preorderedList != null) {
                                    // childIndex points into presorted list, find original index
                                    for (int j = 0; j &amp;lt; childrenCount; j++) {
                                        if (children[childIndex] == mChildren[j]) {
                                            mLastTouchDownIndex = j;
                                            break;
                                        }
                                    }
                                } else {
                                    mLastTouchDownIndex = childIndex;
                                }
                                mLastTouchDownX = ev.getX();
                                mLastTouchDownY = ev.getY();
                                newTouchTarget = addTouchTarget(child, idBitsToAssign); // 设置mFirstTouchTarget的值
                                alreadyDispatchedToNewTouchTarget = true;
                                break;
                            }
                        }
                        ...
                    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续来看&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;的处理过程, 如下; 从上面的代码中我们可以看出, 将事件分发给子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的时候, 调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;非空, 所以应该调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 这样就将事件传递到子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中去了; 这里关于子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTouchEvent()&lt;/code&gt;处理在后文继续讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        ...
        if (newPointerIdBits == oldPointerIdBits) {
            if (child == null || child.hasIdentityMatrix()) {
                if (child == null) {
                    handled = super.dispatchTouchEvent(event); // child非null
                } else {
                    final float offsetX = mScrollX - child.mLeft;
                    final float offsetY = mScrollY - child.mTop;
                    event.offsetLocation(offsetX, offsetY);

                    handled = child.dispatchTouchEvent(event); // 调用child.dispatchTouchEvent(event)

                    event.offsetLocation(-offsetX, -offsetY);
                }
                return handled;
            }
            transformedEvent = MotionEvent.obtain(event);
        } else {
            transformedEvent = event.split(newPointerIdBits);
        }
        ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面我们说过, 如果子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 将会去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;mFirstTouchTarget&lt;/code&gt;的值, 该值的设置其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;中, 也就是说, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即有子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理了事件的话, 就会去调用该函数, 也就证明了我们前面所说的; 我们来看&lt;code class=&quot;highlighter-rouge&quot;&gt;addTouchTarget()&lt;/code&gt;, 如下; 可以看出这里实际上相当于一个单链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget; 
        mFirstTouchTarget = target; // 设置mFirstTouchTarget
        return target;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-viewgroup处理事件&quot;&gt;3.3 ViewGroup处理事件&lt;/h3&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;拦截了事件或者子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有进行事件处理, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;将进行事件处理, 如下; 可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件处理也是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;, 只是传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, 那么从上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchTransformedTouchEvent()&lt;/code&gt;代码中我们可以看出, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;child&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;调用的应该就是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;进行事件处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;            if (mFirstTouchTarget == null) {
                // No touch targets so treat this as an ordinary view.
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent(event)&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent(event)&lt;/code&gt;, 调用的其实都是&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;, 所以接下来我们要看的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中对事件的处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-view事件处理&quot;&gt;四. View事件处理&lt;/h2&gt;

&lt;p&gt;需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;中没有&lt;code class=&quot;highlighter-rouge&quot;&gt;onInterceptTouchEvent()&lt;/code&gt;方法来进行事件拦截; 我们这里关注的, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;进行事件拦截之后对事件的处理以及子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;对事件的处理; 因为从前面我们已经说了, 不管是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;super.dispatchTouchEvent()&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;处理事件)还是&lt;code class=&quot;highlighter-rouge&quot;&gt;child.dispatchTouchEvent()&lt;/code&gt;(子&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;处理事件), 其实都是调用的&lt;code class=&quot;highlighter-rouge&quot;&gt;View.dispatchTouchEvent()&lt;/code&gt;; 所以二者对事件的处理实际上是一样的, 同时需要注意的是, 这一节不包括事件的分发了,
事件分发在上一节中已经讲解完啦~&lt;/p&gt;

&lt;p&gt;触摸事件的处理主要涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;的处理优先级&lt;/p&gt;

&lt;p&gt;主要代码如下; 可以看出先处理的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;没有设置&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;View.setOnTouchListener()&lt;/code&gt;)的话, 再去处理&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;,  所以&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的优先级比&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;高; 同时还要注意的一点是, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnTouchListener&lt;/code&gt;的话, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;将不再调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean dispatchTouchEvent(MotionEvent event) {
    ...
    if (li != null &amp;amp;&amp;amp; li.mOnTouchListener != null
            &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED
            &amp;amp;&amp;amp; li.mOnTouchListener.onTouch(this, event)) {  // OnTouchListener
        result = true;
    }
    if (!result &amp;amp;&amp;amp; onTouchEvent(event)) { // onTouchEvent
        result = true;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick()&lt;/code&gt;其实是在&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;中处理的; 如下; &lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;是在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中触发的, 可以看出, 要触发&lt;code class=&quot;highlighter-rouge&quot;&gt;onClick&lt;/code&gt;需要的条件是: &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;是可以点击的(&lt;code class=&quot;highlighter-rouge&quot;&gt;clickable&lt;/code&gt;), 这里的可点击包括了&lt;code class=&quot;highlighter-rouge&quot;&gt;CLICKABLE&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LONG_CLICKABLE&lt;/code&gt;, 注意&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;enable&lt;/code&gt;属性不影响&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent&lt;/code&gt;的返回值, 只要它可点击, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;就会处理该点击事件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean onTouchEvent(MotionEvent event) {
    if (clickable || (viewFlags &amp;amp; TOOLTIP) == TOOLTIP) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                ...
                if (!mHasPerformedLongPress &amp;amp;&amp;amp; !mIgnoreNextUpEvent) {
                    if (!focusTaken) {
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) {
                            mPerformClick = new PerformClick();
                        }
                        if (!post(mPerformClick)) {
                            performClickInternal();
                        }
                    }
                }
                ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClickInternal()&lt;/code&gt;中, 则是去调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;进行处理, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performClick()&lt;/code&gt;会判断, 如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 则会去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;OnClickListener&lt;/code&gt;, 代码比较简单, 就不贴啦~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的事件分发和处理流程就分析结束啦~; 我们最开始讲&lt;strong&gt;事件分发之源&lt;/strong&gt;时讲&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;对事件的传递的时候, 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;getWindow().superDispatchTouchEvent()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;的话, 就最终将事件交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Activity&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;onTouchEvent()&lt;/code&gt;处理, 这种情况其实对应的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewGroup&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;都不进行事件处理, 那么就逐层回传咯~&lt;/p&gt;

&lt;p&gt;当然理论学习完了, 就应该实际测试一下, 这里笔者写了一个测试的&lt;code class=&quot;highlighter-rouge&quot;&gt;Demo&lt;/code&gt;, &lt;a href=&quot;https://github.com/HusterYP/UI/blob/master/UIList/app/src/main/java/com/example/yuanping/uilist/touch/TouchActivity.java&quot;&gt;参见Github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后将上述流程总结为下图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/View/View事件分发.png&quot; alt=&quot;View事件分发机制&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/20/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8BView%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/</guid>
        
        <category>Android</category>
        
        <category>View</category>
        
        
      </item>
    
      <item>
        <title>Handler</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Android消息机制分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Handler源码分析&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;算是我们平时开发中比较常用的一个, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所代表的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中重要的一部分, 即消息机制; 本文将分析&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的运行机制&lt;/p&gt;

&lt;h3 id=&quot;11-使用场景&quot;&gt;1.1 使用场景&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程切换: 这个是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见和最频繁的场景了; 我们都知道, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中不允许执行耗时操作, 那么当我们需要先去获取数据(耗时)再进行&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;展示或者交互的时候, 线程切换就必不可少了&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;任务延时: 即在未来某个时刻再执行任务, 这个主要是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.postDelayed()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessageDelayed()&lt;/code&gt;完成的(实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;postDelayed()&lt;/code&gt;也是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessageDelayed()&lt;/code&gt;完成的)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-为什么会有handler&quot;&gt;1.2 为什么会有Handler&lt;/h3&gt;

&lt;p&gt;我们都知道&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的作用主要是用于切换线程, 那么为什么会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;喃; 我们以&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中执行耗时操作为例, 对于耗时操作, 特别是在需要实时交互的应用中, 肯定是需要设计为多线程的, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;设计之初为什么不使用多线程去访问&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;呢, 最致命的一点就是, 多线程存在并发访问的不确定性, 这就会造成&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;表现的不可预期性, 造成用户体验极差; 当然, 对于多线程并发的问题还是有很多方式去避免和解决的, 最常见的一个就是加锁, 那么为什么不采用多线程访问,
对&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;加锁的方式实现呢, 一个是加锁会使&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;逻辑变得复杂, 另一个是加锁会降低效率, 阻塞某些线程的执行&lt;/p&gt;

&lt;p&gt;所以, 基于很多方面的考虑, 特别是对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;应用这样交互性很强的场景而言, 使得需要去实现自己的一套异步通信机制, 需要达到的目标是, 线程之间的独立性保持和数据交互的便利性, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实现的&lt;/p&gt;

&lt;h3 id=&quot;13-概述&quot;&gt;1.3 概述&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;消息机制中, 有非常重要的几个部分, 也是我们分析的切入点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;: 单链表, 实现消息存储; 是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层和&lt;code class=&quot;highlighter-rouge&quot;&gt;Native&lt;/code&gt;层的连接纽带&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Looper&lt;/strong&gt;: 无限循环查询是否有新消息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Handler&lt;/strong&gt;: 消息接受和分发处理的中转站&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;最常见的一种写法, 我们通常会重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;来实现自己的逻辑; 当在其他线程中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMessage()&lt;/code&gt;来发送消息时, 我们就会在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中接收到该消息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private final Handler mHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            // do somthing with msg
            super.handleMessage(msg);
        }
    };

    new Thread() {
        @Override
        public void run() {
           mHandler.sendEmptyMessage(0);
        }
    }.start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行线程切换和消息传递的一个大致流程是, 当我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sendMessage()&lt;/code&gt;发送消息的时候, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;负责存储该消息, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;会无限循环的去检查&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 如果有则调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage()&lt;/code&gt;进行消息分发, 最终会回到&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;p&gt;在开始讲解之前, 需要先明确几个结论(在稍后会验证): 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是默认没有创建(除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程外); &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所必须的(否则会抛异常); &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是一一对应的关系, 也就是说每个线程会有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;在哪个线程中创建就在哪个线程中处理消息, 其他线程发送的消息存储在对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;所对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-构造函数&quot;&gt;二. 构造函数&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;提供了七个构造函数, 如下表&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler()&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(Looper looper)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback)&lt;/td&gt;
      &lt;td&gt;Handler(boolean async)&lt;/td&gt;
      &lt;td&gt;Handler(Callback callback, boolean async)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Handler(Looper looper, Callback callback, boolean async)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这七个构造函数最常用的是默认构造函数(即不带参数那个), 其他几个, 一类是带&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;的, 是提供的消息处理函数, 我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;一般都会重写其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;方法来处理消息, 但是也可以不重写&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;, 而是在构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;回调, &lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的一个接口, 如下; 另一类是带标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;的, 是设置消息是否为异步处理, &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;中的消息默认是同步处理的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public interface Callback {
        public boolean handleMessage(Message msg);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们以构造函数&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler(Callback callback, boolean async)&lt;/code&gt;进行分析, 如下; 可以看出, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;mLooper&lt;/code&gt;是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;获取的, 如果我们获取为&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;也就是说当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛出异常, 这个异常也是我们大多数初学者会遇到的; 这里也验证了上面所说的, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造所必须的, 如果当前线程没有&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的话, 会抛异常(至于为什么说是当前线程, 接下来马上分析~)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public Handler(Callback callback, boolean async) {
        ...
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread &quot; + Thread.currentThread()
                        + &quot; that has not called Looper.prepare()&quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.myLooper()&lt;/code&gt;又是如何获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的呢; 如下, 可以看出是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;获取的, &lt;code class=&quot;highlighter-rouge&quot;&gt;sThreadLocal&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;类型的实例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;不是一个线程, 而是用于在每个线程中存储数据的, &lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal&lt;/code&gt;可以在不同的线程中互不干扰的存储并提供数据; 那么它是如何实现在不同线程中互不干扰的存取数据的呢, 我们先来看其&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;方法, 可以看出, 其实际上会先去检查当前线程是否持有&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;, 如果有的话, 直接将&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;存储进去即可, 否则, 初始化当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocalMap&lt;/code&gt;然后再存放值, 这样就可以根据不同的线程来存取各自线程的值了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们要构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;就必须获取当前线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么我们又是什么时候构造和存储的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;喃; 前面我们说了, 每个线程都可以有自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 但是除了&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程以外都默认没有创建; 我们先来看&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中是什么时候创建的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ActivityThread&lt;/code&gt;, 在其&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数中, 我们发现了如下与&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;相关的语句, 这实际上是开启了主线程的消息处理(因为要处理各种事件, 所以一开始就开启了)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
    ...
    Looper.prepareMainLooper();
    ...
    Looper.loop();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们继续看&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.prepareMainLooper()&lt;/code&gt;, 其中实际上是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;prepare()&lt;/code&gt;, 如下; 这里我们看到了熟悉的&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadLocal.set()&lt;/code&gt;, 而且存储的是一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么这里就将线程和各自的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;联系起来了, 我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;构造函数中获取的也就是和各个线程相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里我们知道了, &lt;code class=&quot;highlighter-rouge&quot;&gt;perpare&lt;/code&gt;实际上是在准备&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;又是在做啥呢, 其实&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是开启消息处理循环, 前面我们说了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;不断的去检测&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中是否有消息, 实际上就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;中开启的&lt;/p&gt;

&lt;p&gt;这里我们暂时不讲&lt;code class=&quot;highlighter-rouge&quot;&gt;loop()&lt;/code&gt;, 而是放到后面讲消息处理的时候讲; 我们平时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候, 大多是在&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;
线程中创建的, 因为上面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中默认是创建了&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的, 所以不需要我们再去手动创建, 但是我们如何在子线程中构造和使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;呢; 其实在&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的文档中已经给出了示例, 如下; 其实, 和上面&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程中&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的处理过程差不多, 只是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;UI&lt;/code&gt;线程的特殊性, 所以单独给它准备了一个方法~(实际上是做一些其他特殊判断和处理)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class LooperThread extends Thread {
      public Handler mHandler;

      public void run() {
          Looper.prepare();
 
          mHandler = new Handler() {
              public void handleMessage(Message msg) {
                  // process incoming messages here
              }
          };

          Looper.loop();
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;三-消息发送&quot;&gt;三. 消息发送&lt;/h3&gt;

&lt;p&gt;当我们需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;发送消息时, 可以使用两个系列, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;系列, 一个&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;系列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;postXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列主要是发送一个自定义的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件, 然后去执行(延迟执行)自定义事件&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;post(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtTime(Runnable r, Object token, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postDelayed(Runnable r, Object token, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;postAtFrontOfQueue(Runnable r)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;sendXXX&lt;/strong&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列主要是发送封装的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;, 然后根据&lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;带的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;或者数据在&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;中进行处理&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessage(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessage(int what)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageDelayed(int what, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendEmptyMessageAtTime(int what, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageDelayed(Message msg, long delayMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtTime(Message msg, long uptimeMillis)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;sendMessageAtFrontOfQueue(Message msg)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;但是, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;系列最终还是将&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;事件封装为了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;系列处理, 而不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;postXXX&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;sendXXX&lt;/code&gt;, 最终转到的都是&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;进行处理; 另外, 不管是&lt;code class=&quot;highlighter-rouge&quot;&gt;post&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;send&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;int what&lt;/code&gt;等其他类型, 其实最终都会将每一条消息封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;对象进行传递&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-消息存储&quot;&gt;四. 消息存储&lt;/h2&gt;

&lt;p&gt;前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;会对发送的消息进行存储, 这一步就是在&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueMessage()&lt;/code&gt;中处理的; 如下; 需要注意的是这里传入的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;是在创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;时创建, 也就是说和&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关, 因为涉及到多线程的处理, 所以需要清楚&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;的来源, 不然消息处理的时候就混了~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this;
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里我们简单看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的组织方式, 如下, &lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.enqueueMessage()&lt;/code&gt;, 可以看出是很明显的单链表的存储方式, 之所以用单链表, 是因为单链表在增加和删除节点上有优势&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean enqueueMessage(Message msg, long when) {
    ...
    needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
    Message prev;
    for (;;) {
        prev = p;
        p = p.next;
        if (p == null || when &amp;lt; p.when) {
            break;
        }
        if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
            needWake = false;
        }
    }
    msg.next = p; // invariant: p == prev.next
    prev.next = msg;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-消息处理&quot;&gt;五. 消息处理&lt;/h2&gt;

&lt;p&gt;还记得前面我们还有一个问题没有解决吗, 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;过程实际上就是开启循环处理消息的过程~&lt;/p&gt;

&lt;p&gt;该函数如下; 首先获取消息处理线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;, 前面我们已经看到了, &lt;code class=&quot;highlighter-rouge&quot;&gt;Looper.loop()&lt;/code&gt;是在消息处理线程中调用的, 所以这里获取到的, 也就是消息处理线程, 即创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的线程; 之后获取对应线程的消息队列, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 需要注意这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;关联的, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;的获取是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Thread.currentThread()&lt;/code&gt;来判断和获取的, 那么这里就能获取到和对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;相关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 当我们在不同线程中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.sendMsg&lt;/code&gt;的时候, 插入的也是和该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;, 这样, 一整条完整的线就串成了:  不同的线程往需要发送消息的线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中插入&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;, 而和线程关联的&lt;code class=&quot;highlighter-rouge&quot;&gt;Looper&lt;/code&gt;又从该&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中不断获取&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;处理, 这样就完成了线程的切换 !!&lt;/p&gt;

&lt;p&gt;接下来就是用一个死循环(&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;)开始消息处理了; 逻辑也比较简单, 其实就是不断的从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息(&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;), 然后回调&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler.dispatchMessage(msg)&lt;/code&gt;分发, 需要注意的是, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;msg.target&lt;/code&gt;实际上是存储的对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void loop() {
    final Looper me = myLooper();
    ...
    final MessageQueue queue = me.mQueue;
    ...

     for (;;) {
        Message msg = queue.next(); // might block
        // 如果消息为null, 不处理咯
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        ...
        msg.target.dispatchMessage(msg);
     }

}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatchMessage&lt;/code&gt;的处理逻辑, 如下; 逻辑也很简单, 就是消息处理的优先级: 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;自身设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;, 就直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Message&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;(这种情况对应前面说的&lt;code class=&quot;highlighter-rouge&quot;&gt;post(Runnable)&lt;/code&gt;的情况); 如果构造&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的时候设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;那么交给该&lt;code class=&quot;highlighter-rouge&quot;&gt;Callback&lt;/code&gt;处理, 否则回调&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void dispatchMessage(Message msg) {
        if (msg.callback != null) {
            handleCallback(msg);
        } else {
            if (mCallback != null) {
                if (mCallback.handleMessage(msg)) {
                    return;
                }
            }
            handleMessage(msg);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里还要注意的一点是从&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中获取消息时, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue.next()&lt;/code&gt;, 这是一个阻塞方法, 也就是说当&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中没有消息的时候, 会阻塞在这里, 直到&lt;code class=&quot;highlighter-rouge&quot;&gt;MessageQueue&lt;/code&gt;中再次存储消息&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-总结&quot;&gt;六. 总结&lt;/h2&gt;

&lt;p&gt;到这里&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;的整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;层面的运行机制我们就讲解完啦~ , 到这里我们对整个&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;的消息传递和处理机制也有了比较详细的了解了; 为加深记忆, 可以对着源码自己再过一遍过程~&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/15/Handler/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/15/Handler/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Linux开机启动流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux开机启动流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中实验基于&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;版本（&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.x&lt;/code&gt;版本都可以，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS7.x&lt;/code&gt;版本会有所区别）&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-启动流程&quot;&gt;一. 启动流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;开关电源（&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;）在开机之后将&lt;code class=&quot;highlighter-rouge&quot;&gt;AC&lt;/code&gt;信号转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;DC&lt;/code&gt;信号，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;会进行电压的检测，如果正常，&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;将会发送&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt; 信号给主板定时器，主板定时器接收到&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt;信号之后，将会停止发送&lt;code class=&quot;highlighter-rouge&quot;&gt;reset&lt;/code&gt;指令给&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;，这意味着电脑可以正常启动&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;的设置中有一些值是固定的，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;才知道从哪里开始读取指令，在&lt;code class=&quot;highlighter-rouge&quot;&gt;X86&lt;/code&gt;计算机中，第一条指令是&lt;code class=&quot;highlighter-rouge&quot;&gt; FFFF:0000h &lt;/code&gt;，指向&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;的最后一个字节，该指令因为只有一个字节，所以只是简单的包含一个跳转指令，该跳转指令指向的是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;所在的地址（&lt;code class=&quot;highlighter-rouge&quot;&gt;EPROM&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;中）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;就是基本输入输出系统，其功能主要有两个：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;POST：&lt;code class=&quot;highlighter-rouge&quot;&gt;Power On Self Test&lt;/code&gt;；硬件自检；即在&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中有一个硬件设备的列表，为了检测某一个硬件设备是否可用，就发送一个电脉冲给每一个设备，如果该脉冲被设备返回，说明设备可用，否则，不可用；如果有新的硬件接入，那么会使用同样的检测过程，同时会更新&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中的列表，用于下次启动过程&lt;/li&gt;
    &lt;li&gt;选择第一个启动设备：&lt;code class=&quot;highlighter-rouge&quot;&gt; BIOS&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;里面的记录的启动顺序以及上一步硬件自检过程中，设备的可用装态，确定最终的可启动设备顺序，具体的过程是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;将磁盘的第一扇区（磁盘最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节）载入内存，放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X0000:0X7C00&lt;/code&gt;处，然后检查这个扇区的最后两个字节是不是&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;，如果是则认为这是一个有效的启动扇区，如果不是就会尝试下一个启动介 质，如果找到可以启动的程序就会从这一介质启动，如果所有的启动介质都判断过后仍然没有找到可启动的程序那么&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;会给出错误提示&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 我们平时所说的更改&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;设置，实际上是错的，我们更改的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;中存储的设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中信息不能被用户改变，需要厂商提供闪存程序&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;MBR&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;确定好第一个启动设备之后，去该设备磁盘的第一个扇区读取最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节到内存（通过硬件的&lt;code class=&quot;highlighter-rouge&quot;&gt;INT 13&lt;/code&gt;中断功能来读取的），该&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;，即主引导记录；这&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节中有&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节才是正真的主引导加载代码（&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，即可以安装引导加载程序的地方），还有&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;字节用于存放磁盘分区表信息，以及最后两个字节用于校验（&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;)是否为有效的启动扇区；每个分区需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节用于存储分区的开始，结束位置，分区类型等（由于每个分区信息需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节，所以对于采用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;型分区结构的硬盘(其磁盘卷标类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;MS-DOS&lt;/code&gt;)，最多只能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个主要分区。所以对于一个采用此种分区结构的硬盘来说，想要得到&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个以上的主要分区是不可能的。这里就需要引出了扩展分区。扩展分区也是主分区（&lt;code class=&quot;highlighter-rouge&quot;&gt;Primary partition&lt;/code&gt;）的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;结构类似的扩展引导记录(&lt;code class=&quot;highlighter-rouge&quot;&gt;EBR&lt;/code&gt;) ）（&lt;code class=&quot;highlighter-rouge&quot;&gt; MBR&lt;/code&gt;分区方案无法支持超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;容量的磁盘。因为这一方案用&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节存储分区的总扇区数，最大能表示&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;次方的扇区个数，按每扇区&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节计算，每个分区最大不能超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，如果磁盘容量超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，那分区的起始位置 就无法表示了）&lt;/li&gt;
  &lt;li&gt;继续之前，我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;的信息，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;为例（后文不再声明），使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;dd if=/dev/sda of=mbr bs=512 count=1&lt;/code&gt;，将第一个扇区的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节内容转存到&lt;code class=&quot;highlighter-rouge&quot;&gt;mbr&lt;/code&gt;文件中，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt;表示大小；然后可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;file mbr&lt;/code&gt;来查看分区信息等，输出如下；其中&lt;code class=&quot;highlighter-rouge&quot;&gt;partition x&lt;/code&gt;表示第&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;个分区的信息，上面说了，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;时最多只能有四个分区，而且这四个分区中最多只能有一个活动分区，也就是下面被标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;active&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;partition 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 19451904 sectors; partition 2: ID=0x5, starthead 254, startsector 19455998, 2093058 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage1&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;中的前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节存储着引导加载程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;为例；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;有两个阶段（实际上应该是三个阶段，后面会解释），实际上这&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中存储的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;的第一阶段，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节的空间实在有限，做不了太多事情；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;第一阶段的作用主要是加载第二阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;实际上分为三个阶段：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1 -- stage1.5 -- stage2&lt;/code&gt;）&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;是存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中的引导加载程序；&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1.5&lt;/code&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;：扇区编号从0开始，但是真正的磁盘分区一般是从第63个扇区开始的，也就是说从1-63扇区是空闲的（第0个扇区存储&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;），这段空间叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;），因为&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;）存储于磁盘上，但是读取文件系统需要驱动，&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GA&lt;/code&gt;P中主要存储的就是读取文件系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;driver&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;读取该部分内容之后，就可以去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;grub&lt;/code&gt;配置文件，即&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage2&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件，主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;，这里我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.conf&lt;/code&gt;的内容，如下&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;：这个必须和下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;对应，在配置文件中有几个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;，启动的时候就会有几个菜单可以选择；&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;表示使用第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;选项来启动，&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;表示在读秒时间结束前都没有按键，则使用默认选项启动&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout=5&lt;/code&gt;：读秒时间，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;秒钟内没有按键，则使用默认选项启动；当然可以自行调整时间&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;splashimage=(hd0,0)/grub/splash.xpm.gz&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS&lt;/code&gt;启动的时候，后台不是黑白而是彩色变化的，就是这个文件提供的后台图示&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hidemenu&lt;/code&gt;：是否显示提示菜单，默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;hide&lt;/code&gt;的，但是笔者这里将这个选项注释掉了，在选择开机启动项的时候还会显示提示菜单&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;：这部分指定的是菜单选项，开机时有多少个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;就会有多少个菜单选项；每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;下的内容，一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;文件及设置，另一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;位置&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/grub_conf.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;加载：&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loade&lt;/code&gt;根据用户的选项，去加载相应的磁盘映像到内存，内核是一个压缩文件，解压缩后，内核会再一次进行测试与驱动周边设备；之后，内核需要去加载各个模块，&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;内核可以动态加载内核模块，这些内核模块放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;目录下，由于模块放置到磁盘根目录下，所以内核要去读取这些模块的话，需要挂载到根目录，这样才能读取内核模块加载驱动程序的功能，但是内核根本不认识&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘，所以需要加载&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘的驱动程序，否则根本无法挂载根目录，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;的驱动程序是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;内，这就出现了两难的问题，所以为了去挂载根目录，就出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;这个东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;initrd&lt;/strong&gt;：虚拟文件系统，一般位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/initrd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;在将内核加载到内存的同时，也会将&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;加载到内存中，并仿真成为一个根目录；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;的作用就是去加载必要的驱动，以便内核可以访问真正的根文件系统（如：磁盘控制器驱动，文件系统驱动（&lt;code class=&quot;highlighter-rouge&quot;&gt;ext3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt;等）），然后去挂载真正的根文件系统，进行根切换操作，用真正的根文件系统进行启动；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;完成上述任务之后，会清除掉自己在内存中的痕迹，让出空间&lt;/li&gt;
  &lt;li&gt;内核及其必要模块加载完毕之后，会主动执行第一个程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;，这也是第一个启动的进程；&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;的主要功能是根据其配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;）去准备软件的执行环境（系统服务等）；这里我们看一下其配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;的内容；如下；前面的注释是对该配置文件的描述，在笔者的该系统中，&lt;code class=&quot;highlighter-rouge&quot;&gt;inittab&lt;/code&gt;中只有一项配置，即运行级别（&lt;code class=&quot;highlighter-rouge&quot;&gt;runlevel&lt;/code&gt;）的设置，所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;的设置来启动不同的服务，让&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;的运行环境不同；至于&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;，分为七个等级：如下；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0 -- halt&lt;/code&gt;：系统直接关机&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 -- single user mode&lt;/code&gt;：单用户维护模式，用在系统出问题时的维护&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 -- Multi-user， without NFS&lt;/code&gt;：类似下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;，只是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;NFS&lt;/code&gt;服务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3 -- Full multi-user mode&lt;/code&gt;：完整含有网络功能的纯文本模式&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4 -- unused&lt;/code&gt;：系统保留功能&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5 -- X11&lt;/code&gt;：与&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;类似，但是加载使用&lt;code class=&quot;highlighter-rouge&quot;&gt;X Window&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6 -- reboot&lt;/code&gt;：重新启动&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里笔者将运行级别设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;，所以是以纯文本形式启动，即纯命令行模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/inittab.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;到这里系统就启动起来啦 ~ ，这也是系统启动的大致流程 ~&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-参考链接&quot;&gt;二. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;鸟哥私房菜基础学习篇第三版&lt;/li&gt;
  &lt;li&gt;https://www.slashroot.in/linux-booting-process-step-step-tutorial-understanding-linux-boot-sequence&lt;/li&gt;
  &lt;li&gt;https://www.linuxnix.com/linux-booting-process-explained/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Linux</category>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之Queue</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;的实现类, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;集合框架系列博客&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;Java集合框架概述&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/&quot;&gt;Java集合框架之List&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/&quot;&gt;Java集合框架之Set&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/&quot;&gt;Java集合框架之Queue&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;是一个双端队列, 内部使用数组实现, 既可以作为栈使用, 也可以作为队列使用(当作为栈使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;快; 当作为队列使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;快); 既然是双端队列, 那么自然支持首尾插入删除等操作; &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;不是线程安全的, 不允许插入&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;内部使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object[] elements&lt;/code&gt;来容纳元素, 默认初始容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, 需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量大小需要为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数幂次方, 这是为了使用位运算去代替普通的乘除运算来提高效率; 下面将从两个方面讲解其有关知识点: 即基本方法和扩容规则&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-基本方法&quot;&gt;二. 基本方法&lt;/h2&gt;

&lt;h3 id=&quot;21-构造函数&quot;&gt;2.1 构造函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;提供了三个构造函数, 这里只挑其中一个比较难的讲解; 如下, 该构造函数允许提供自定义初始容量, 但是并不是说, 我们传进去多少容量, 最初就会分配多少容量, 因为传进去的值还经过了&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的处理; &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的作用是, 找出不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;numElements&lt;/code&gt;的最小的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的整数, 因为上面已经说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量需要都是&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂; 这点和&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的扩容规则比较相像, 具体分析可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;中对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;扩容规则一节的讲解; 另外, 值得一提的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;的时候还进行了边界值的判断, 一个是初始容量最小为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 最大不得超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2^30&lt;/code&gt;, 如下代码;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void allocateElements(int numElements) {
        elements = new Object[calculateSize(numElements)];
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static int calculateSize(int numElements) {
        int initialCapacity = MIN_INITIAL_CAPACITY;  // 初始最小容量为8
        // Find the best power of two to hold elements.
        // Tests &quot;&amp;lt;=&quot; because arrays aren't kept full.
        if (numElements &amp;gt;= initialCapacity) {
            initialCapacity = numElements;
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
            initialCapacity++;

            if (initialCapacity &amp;lt; 0)   // Too many elements, must back off
                initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements // 最大容量为2^30
        }
        return initialCapacity;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-元素增删&quot;&gt;2.2 元素增删&lt;/h3&gt;

&lt;p&gt;双端队列的难点在于数据元素增删的时候, 如何通过首尾指针的关系判断当前队列是满还是空, 以及插入和删除元素后首尾指针的变化情况; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中的处理是, &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针指向队列首元素, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向队列尾元素的后一个位置, 那么比如在队列头部插入元素时,  通过判断&lt;code class=&quot;highlighter-rouge&quot;&gt;(head - 1) &amp;amp; (elements.length - 1) == tail&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的时候队列就满了, 这样, 虽然双端队列在队列满和空的情况下, 都是&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;, 但是仍然能够分辨&lt;/p&gt;

&lt;p&gt;下面我们通过具体的元素添加来看, 如下, 为在队列头添加元素, 这里需要注意的一点是先添加元素, 再判断队列是否已满, 这是因为上面我们说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向的是队尾元素的下一个位置, 一定是空位置, 否则在上一次添加元素的时候就会引起扩容了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addFirst(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e;
        if (head == tail)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里讲一下&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;的运算规则, 比如, 当我们的数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 本次插入之前&lt;code class=&quot;highlighter-rouge&quot;&gt;head = 0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail = 7&lt;/code&gt;的时候, 执行该插入操作, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;元素, 即 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1 &amp;amp; 7&lt;/code&gt;, 转换为二进制就是(&lt;code class=&quot;highlighter-rouge&quot;&gt;1111 &amp;amp; 0111 = 0111&lt;/code&gt;), 最终运算结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;, 所以可以判断队列满了, 需要扩容 ~&lt;/p&gt;

&lt;p&gt;其实这里使用位运算也是利用了数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的特点&lt;/p&gt;

&lt;p&gt;同理, 在队列尾插入元素也是一样的, 如下; 就不再分析啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addLast(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[tail] = e;
        if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于删除元素来说, 这里举一个例子, 如下; 主要看&lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针的变化规则, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (h + 1) &amp;amp; (elements.length - 1);&lt;/code&gt;, 其实就是和插入元素相反的过程而已&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public E pollFirst() {
        int h = head;
        E result = (E) elements[h];
        // Element is null if deque empty
        if (result == null)
            return null;
        elements[h] = null;     
        head = (h + 1) &amp;amp; (elements.length - 1);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-扩容规则&quot;&gt;三. 扩容规则&lt;/h2&gt;

&lt;p&gt;什么时候会扩容呢, 我们注意到, 上面我们讲解插入元素指针变化规则的时候, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;也就是队列满了的时候, 会调用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;
函数, 其实该函数就是用于扩容的&lt;/p&gt;

&lt;p&gt;那么根据上面的分析, 什么时候会发生扩容呢, 其实就是当队列满的时候; 扩容的规则又是怎样的呢, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;的函数名我们猜测, 就是将数组容量加倍而已; 如下, 思路也比较简单, 就是创建一个扩容的新数组进行旧元素的复制罢了, 比较简单, 不再赘述&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void doubleCapacity() {
        assert head == tail;
        int p = head;
        int n = elements.length;
        int r = n - p; // number of elements to the right of p
        int newCapacity = n &amp;lt;&amp;lt; 1; // 左移一位, 相当于容量加倍
        if (newCapacity &amp;lt; 0)
            throw new IllegalStateException(&quot;Sorry, deque too big&quot;); // 这是因为左移溢出之后会变成负值, 说明队列太大啦~
        Object[] a = new Object[newCapacity];
        System.arraycopy(elements, p, a, 0, r);
        System.arraycopy(elements, 0, a, r, p);
        elements = a;
        head = 0;
        tail = n;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四-总结&quot;&gt;四. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的源码就分析完啦~; 最后笔者还想补充解释一点的是, 最开始我们提过, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为栈来使用的时候, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;要快, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;, 我们在&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;Java集合框架概述&lt;/a&gt;中粗略的提过, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java 2&lt;/code&gt;以前的几个遗留&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 其内部也是使用数组实现的, 但是由于其加了锁, 支持多线程访问, 所以会比&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;要慢; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为队列使用的时候,
比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;要快是因为在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;内部是使用链表节点实现的, 不具备数组的索引定位, 当然也就是慢啦~&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Fresco源码解析</title>
        <description>&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化Fresco: Fresco.initialize(this); 最好在Application中初始化, 多次初始化是无意义的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心类为: SimpleDraweeView; 在layout中使用该类, 然后在代码中, 剩下的Fresco自动完成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;);
SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);
draweeView.setImageURI(uri);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Fresco会自动完成:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;显示占位图直到加载完成；&lt;/li&gt;
        &lt;li&gt;下载图片；&lt;/li&gt;
        &lt;li&gt;缓存图片；&lt;/li&gt;
        &lt;li&gt;图片不再显示时，从内存中移除；&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;关键概念&quot;&gt;关键概念&lt;/h2&gt;

&lt;h3 id=&quot;一-drawees&quot;&gt;一. Drawees&lt;/h3&gt;

&lt;p&gt;分为三个主要部分, 有点像MVC模式&lt;/p&gt;

&lt;h4 id=&quot;11-draweeview&quot;&gt;1.1 DraweeView&lt;/h4&gt;

&lt;p&gt;一般情况下使用SimpleDraweeView即可&lt;/p&gt;

&lt;h4 id=&quot;12-draweehierarchy&quot;&gt;1.2 DraweeHierarchy&lt;/h4&gt;

&lt;p&gt;用于组织和维护最终绘制和呈现的 Drawable 对象, 可通过它来自定义图片显示效果&lt;/p&gt;

&lt;h4 id=&quot;13-draweecontroller&quot;&gt;1.3 DraweeController&lt;/h4&gt;

&lt;p&gt;负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的), 对所要显示的图片做更多的控制&lt;/p&gt;

&lt;p&gt;如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类&lt;/p&gt;

&lt;h4 id=&quot;14-draweecontrollerbuilder&quot;&gt;1.4 DraweeControllerBuilder&lt;/h4&gt;

&lt;p&gt;由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改&lt;/p&gt;

&lt;h4 id=&quot;15-listeners&quot;&gt;1.5 Listeners&lt;/h4&gt;

&lt;p&gt;使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。&lt;/p&gt;

&lt;h3 id=&quot;二-image-pipeline&quot;&gt;二. Image Pipeline&lt;/h3&gt;

&lt;p&gt;负责图片的获取和管理&lt;/p&gt;

&lt;p&gt;压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。Image pipeline 会首先从内存中搜寻图片，然后是磁盘缓存，再然后是网络或其他来源&lt;/p&gt;

&lt;p&gt;在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。&lt;/p&gt;

&lt;p&gt;SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline&lt;/p&gt;

&lt;p&gt;Image pipeline 默认有3个线程池:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;3个线程用于网络下载&lt;/li&gt;
    &lt;li&gt;2个线程用于磁盘操作: 本地文件的读取，磁盘缓存操作。&lt;/li&gt;
    &lt;li&gt;2个线程用于CPU相关的操作: 解码，转换，以及后处理等后台操作。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;uri格式&quot;&gt;URI格式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/supported-uris.html&quot;&gt;URI支持格式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;drawee的各种效果配置fresco支持的各种图片层级&quot;&gt;Drawee的各种效果配置(Fresco支持的各种图片层级)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/drawee-branches.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置要加载的图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;占位图(Placeholder)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置加载失败占位图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击重新加载图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示进度条&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置叠加图(Overlay)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置按压状态下的叠加图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓存策略&quot;&gt;缓存策略&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/caching.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/getting-started.html&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Fresco/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Fresco/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
  </channel>
</rss>
