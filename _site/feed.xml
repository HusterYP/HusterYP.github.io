<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 10 Mar 2019 01:03:06 +0800</pubDate>
    <lastBuildDate>Sun, 10 Mar 2019 01:03:06 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS疑难点</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;iOS疑难点总结，部分摘自参考链接&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;selfvar还是_var&quot;&gt;self.var还是_var?&lt;/h2&gt;

&lt;p&gt;在iOS中常见到如下写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Demo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Demo&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//    self.name = @&quot;&quot;;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上述写法中，&lt;code class=&quot;highlighter-rouge&quot;&gt;self.name&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;_name&lt;/code&gt;有什么区别呢?&lt;/p&gt;

&lt;p&gt;在解释其区别之前，需要先了解一下OC中的属性和实例变量，实例变量具有私有性，一般仅在类内部使用，为了方便给外界读写这个实例变量，就有了属性（@property）&lt;/p&gt;

&lt;p&gt;在iOS第一版中，需要同时声明属性和底层实例变量，那时，属性是oc语言的一个新的机制，并且要求必须声明与之对应的实例变量；如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MyViewController.h
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIViewController&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UIButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 实例变量
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UIButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 属性
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之后，苹果将默认编译器从GCC转换为LLVM(low level virtual machine)，从此不再需要为属性声明实例变量了。如果LLVM发现一个没有匹配实例变量的属性，它将自动创建一个以下划线开头的实例变量（即&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;属性及与其对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;_var&lt;/code&gt;实例变量），如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MyViewController.h
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UIButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 将自动创建一个_myButton实例变量与之对应
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MyViewController.m中可以直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;_myButton&lt;/code&gt;实例变量，也可以通过self.myButton来访问，二者的区别也是下面要讲解的；&lt;/p&gt;

&lt;p&gt;再来看下面一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MyViewController.h
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIViewController&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 实例变量
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在MyViewController.m文件中，如果通过self.name访问的话，编译器会报错，Xcode会提示使用-&amp;gt;，即使用self-&amp;gt;name，这是因为OC中点表达式表示调用方法，而这里的name是一个实例变量，没有与其对应的name方法&lt;/p&gt;

&lt;p&gt;另外，还有一个与@property合用的@synthesize，通过@synthesize还可以指定与属性对应的实例变量名，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// MyViewController.h
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;UIViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;retain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UIButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// MyViewController.m
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MyViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@synthesize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myButton&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherButton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，与属性myButton对应的实例变量名为otherButton了，默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;_myButton&lt;/code&gt;就不能使用了；还需要注意的一点是，如果只是声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;@synthesize myButton;&lt;/code&gt;，那么此时默认与myButton对应的实例变量名为myButton，&lt;code class=&quot;highlighter-rouge&quot;&gt;_myButton&lt;/code&gt;也不能用了&lt;/p&gt;

&lt;p&gt;到这里我们应该知道了使用&lt;code class=&quot;highlighter-rouge&quot;&gt;self.var&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;_var&lt;/code&gt;的区别，即self.var实际上是调用了属性方法，即getter和setter方法，而&lt;code class=&quot;highlighter-rouge&quot;&gt;_var&lt;/code&gt;是直接调用的实例变量，不会走getter和setter方法；因此，这里需要注意的是，当我们要重写getter方法时，在getter方法中必须使用&lt;code class=&quot;highlighter-rouge&quot;&gt;_var&lt;/code&gt;实例变量，否则会造成getter方法的递归调用；同理，重写setter方法时，在setter方法中也只能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;_var&lt;/code&gt;实例变量，否则也会造成settter方法的递归调用；另外，直接访问实例变量的话，就不会调用其setter方法，这样就绕过了为相关属性所定义的内存管理语义。例如：在ARC下直接访问一个语义为copy的属性，那么并不会copy该属性，而仅仅是保留新值并释放旧值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://www.jianshu.com/p/48056965ddce&lt;/li&gt;
  &lt;li&gt;http://www.cnblogs.com/crazypebble/archive/2013/11/23/3439261.html&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;property与synthesize&quot;&gt;@property与@synthesize&lt;/h2&gt;

&lt;p&gt;我们知道@property可用于在头文件中声明getter和settter方法，@synthesize方法可用于.m文件中实现getter和setter方法；但是实际情况是，如果我们只是在头文件中使用了@property，而没有在.m文件中使用@synthesize，编译器实际上还是会为我们生成getter和setter方法；这是因为从Xcode 4.4 开始，@synthesize属性是默认声明了的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://stackoverflow.com/questions/7496463/objective-c-property-declaration-without-implementation-synthesize&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;扩展extension与分类category&quot;&gt;扩展(extension)与分类(category)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://www.jianshu.com/p/9e827a1708c6&lt;/li&gt;
  &lt;li&gt;https://blog.csdn.net/hherima/article/details/44242469&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;宏定义中的dowhile0使用&quot;&gt;宏定义中的do{}while(0)使用&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;https://blog.csdn.net/luoweifu/article/details/38563162&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 27 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/27/iOS%E7%96%91%E9%9A%BE%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/27/iOS%E7%96%91%E9%9A%BE%E7%82%B9/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS数据存储</title>
        <description>&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;沙盒&lt;/li&gt;
    &lt;li&gt;Plist&lt;/li&gt;
    &lt;li&gt;Preference偏好设置&lt;/li&gt;
    &lt;li&gt;NSKeyedArchiver归档 / NSKeyedUnarchiver解档&lt;/li&gt;
    &lt;li&gt;SQLite3的使用&lt;/li&gt;
    &lt;li&gt;FMDB&lt;/li&gt;
    &lt;li&gt;Core Data&lt;/li&gt;
    &lt;li&gt;Realm: https://realm.io/cn/docs/swift/latest/&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-沙盒&quot;&gt;一. 沙盒&lt;/h2&gt;

&lt;p&gt;文件系统：
&lt;code class=&quot;highlighter-rouge&quot;&gt;APFS&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;macOS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;watchOS&lt;/code&gt;, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;tvOS&lt;/code&gt;的默认文件系统；从&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS 10.3&lt;/code&gt;及其之后，&lt;code class=&quot;highlighter-rouge&quot;&gt;APFS&lt;/code&gt;就替代&lt;code class=&quot;highlighter-rouge&quot;&gt;HFS+&lt;/code&gt;作为默认的文件系统&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS App&lt;/code&gt;的沙盒目录如下
&lt;img src=&quot;/img/post/iOS_Storage/iOS_App_SandBox.png&quot; alt=&quot;&quot; /&gt;
应用程序通常不能在自己的沙盒之外进行文件操作，但是可以通过通过系统接口来获取信息，如通过系统接口获取联系人信息和音乐等&lt;/p&gt;

&lt;p&gt;常用沙盒文件夹：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;目录&lt;/th&gt;
      &lt;th&gt;详情&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AppName.app&lt;/td&gt;
      &lt;td&gt;App Bundle，该目录包括了app及其所有资源文件；用户拥有只读权限（无写权限），该目录在app安装时被签名，如果强行写入该目录会破坏该签名，使得应用无法启动；该文件目录下内容不会被iTunes或iCloud备份&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Documents&lt;/td&gt;
      &lt;td&gt;用于存储用户生成的文件，该目录下的文件可以共享给其他用户；该文件目录下内容会被iTunes和iCloud备份&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Documens/Inbox&lt;/td&gt;
      &lt;td&gt;用来保存由外部应用请求当前应用程序打开的文件；应用程序可以读取和删除该目录下文件，但是无法创建新文件和写入已经存在的文件；该目录下内容会被iTunes和iCloud备份&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Library&lt;/td&gt;
      &lt;td&gt;用于存储非用户数据的文件，可以将不想暴露给用户的数据存储在该目录下；该目录下有一个Caches子目录，用于缓存，以及一个Application Supportm目录，用于存储应用生成的一些文件，如配置文件等；该目录下内容（除了Caches下内容外）会被iTunes和iCloud备份&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;temp&lt;/td&gt;
      &lt;td&gt;用于存储临时文件，当应用程序没有运行时，该目录下内容可能会被系统清空；该目录下内容不会被iTunes或iCloud备份&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt; :
&lt;strong&gt;Bundle&lt;/strong&gt; ：&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;是将可执行程序代码和相关资源文件（如图片，声音等）组合在一起的一个文件目录；在&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;OS X&lt;/code&gt;中，应用程序，&lt;code class=&quot;highlighter-rouge&quot;&gt;frameworks&lt;/code&gt;，插件和其他形式的软件都是&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;（应用程序是第三方开发者能够在&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS&lt;/code&gt;上创建的唯一&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;）；使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;可以使安装和定位应用程序更加方便，同时方便做国际化(&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle&lt;/code&gt;目录结构如下图)；每个应用程序都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;main bundle&lt;/code&gt;，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;NSBundle&lt;/code&gt;来获取&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Storage/bundle.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;获取各目录路径：&lt;a href=&quot;https://www.jianshu.com/p/dd3f120eb249&quot;&gt;摘自博客&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 获取沙盒主目录路径
NSString *homeDir = NSHomeDirectory();
// 获取Documents目录路径
NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
// 获取Library的目录路径
NSString *libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject];
// 获取Caches目录路径
NSString *cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject];
// 获取tmp目录路径
NSString *tmpDir =  NSTemporaryDirectory();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;core-data&quot;&gt;Core Data&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;fmdb&quot;&gt;FMDB&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;realm&quot;&gt;Realm&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;plist&quot;&gt;Plist&lt;/h3&gt;

&lt;p&gt;只能存储&lt;code class=&quot;highlighter-rouge&quot;&gt;OC&lt;/code&gt;常用数据类型(&lt;code class=&quot;highlighter-rouge&quot;&gt;NSString&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDictionary&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSArray&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSData&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNumber&lt;/code&gt;等类型)而不能直接存储自定义模型对象；如果想存储自定义模型对象只能将自定义模型对象转换为字典存储（实现&lt;code class=&quot;highlighter-rouge&quot;&gt;writeToFile&lt;/code&gt;方法）&lt;/p&gt;

&lt;h3 id=&quot;preference&quot;&gt;Preference&lt;/h3&gt;

&lt;p&gt;每个应用都有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSUserDefaults&lt;/code&gt;实例，可用于快速存储键值对，如：用户名，密码，开关状态等&lt;/p&gt;

&lt;h3 id=&quot;nskeyedarchiver归档--nskeyedunarchiver解档&quot;&gt;NSKeyedArchiver归档 / NSKeyedUnarchiver解档&lt;/h3&gt;

&lt;p&gt;归档和解档会在写入、读出数据之前进行序列化、反序列化，数据的安全性相对高一些；但是归档不能存储大批量数据（相比较&lt;code class=&quot;highlighter-rouge&quot;&gt;Sqlite&lt;/code&gt;而言），存储数据到文件是将所有的数据一下子存储到文件中，从文件中读取数据也是一下子读取所有的数据；归档的类需要实现&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCoding&lt;/code&gt;协议&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.jianshu.com/p/e88880be794f&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.jianshu.com/p/14fd706b632d&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 26 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/26/iOS%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/26/iOS%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS多线程与网络</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;iOS多线程编程各种方式总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;iOS中多线程的实现方式有如下四种：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Thread/多线程实现方案的比较.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本文主要总结常用的两种方式&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-gcd&quot;&gt;二. GCD&lt;/h2&gt;

&lt;h3 id=&quot;21-gcd概述&quot;&gt;2.1 GCD概述&lt;/h3&gt;

&lt;p&gt;GCD即Grand Central Dispatch，是苹果公司为多核的并行运算提出的解决方案，能自动合理地利用多核CPU（比如双核、四核），同时还能自动管理线程的生命周期（创建线程、调度任务、销毁线程），不需要手动管理；由C语言实现&lt;/p&gt;

&lt;h3 id=&quot;22-gcd使用&quot;&gt;2.2 GCD使用&lt;/h3&gt;

&lt;h4 id=&quot;221-主要方法&quot;&gt;2.2.1 主要方法&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)&lt;/code&gt; ：同步&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async(dispatch_queue_t queue, dispatch_block_t block)&lt;/code&gt; ：异步&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)&lt;/code&gt; ：等待前面的任务执行完成之后才执行，且它后面的任务等它执行完成之后才会执行；这里的 queue 不能是全局的并发队列（可用于解决读写锁的问题；如数据库操作中，读操作可以并行提高效率，写操作需要等待前面的读操作完成之后再执行，写操作执行完之后，之后的读操作又可以实现并行，如下）&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	dispatch_async(queue, ^{
            // reading
        });
        dispatch_async(queue, ^{
            // reading
        });
        dispatch_barrier_sync(queue, ^{
            // writing
        });
        dispatch_async(queue, ^{
            // reading
        });
        dispatch_async(queue, ^{
            // reading
        });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;222-队列&quot;&gt;2.2.2 队列&lt;/h4&gt;

&lt;p&gt;GCD中有两个重要的概念：任务和队列&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;任务有两种执行方式：同步执行和异步执行，他们之间的区别是否会创建新的线程&lt;/li&gt;
    &lt;li&gt;队列：用于存放任务。有两种队列， 串行队列和并行队列；区别如下：&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Thread/串行队列和并行队列.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以通过如下方式获取或者创建队列：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue_create&lt;/code&gt; 创建（串行或并行）&lt;/li&gt;
    &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_get_global_queue&lt;/code&gt; 获取全局并发队列（所有应用程序都可用，且区分优先级）&lt;/li&gt;
    &lt;li&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_get_main_queue&lt;/code&gt; 获得主队列&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 自己创建队列：第一个参数是标识符，用于 DEBUG 的时候标识唯一的队列；
// 第二个参数用来表示创建的队列是串行的还是并行的，传入 DISPATCH_QUEUE_SERIAL 或 NULL 表示创建串行队列。传入 DISPATCH_QUEUE_CONCURRENT 表示创建并行队列

  //串行队列
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, NULL);
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_SERIAL);
  //并行队列
  dispatch_queue_t queue = dispatch_queue_create(&quot;tk.bourne.testQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 全局并行队列：
  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;223-队列组dispatch-group&quot;&gt;2.2.3 队列组(Dispatch Group)&lt;/h4&gt;

&lt;p&gt;可用于实现当并行执行block时，监听所有block执行结束&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        dispatch_group_t group = dispatch_group_create();
        dispatch_group_async(group, queue, ^{
            NSLog(@&quot;Block 1&quot;);
        });
        dispatch_group_async(group, queue, ^{
            NSLog(@&quot;Block 2&quot;);
        });
        dispatch_group_async(group, queue, ^{
            NSLog(@&quot;Block 3&quot;);
        });
        dispatch_group_notify(group, dispatch_get_main_queue(), ^{
            NSLog(@&quot;Done&quot;);
        });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;应用举例：分别执行两个耗时的操作，等两个异步操作都执行完之后，回到主线程执行操作；如果想要高效实现上述需求，可用队列组；如下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_group_t group =  dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    // 执行1个耗时的异步操作
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    // 等前面的异步操作都执行完毕后，回到主线程...
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;224-其他&quot;&gt;2.2.4 其他&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;延迟执行：通过&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_walltime&lt;/code&gt;生成绝对时间&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC); // ull表示：unsigned long long 
        dispatch_after(time, dispatch_get_main_queue(), ^{
            
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;dipatch_apply：相当于dipatch_sync和dispatch group的关联API，该函数将指定的block追加到指定的queue中，并等待全部处理执行结束；其也会阻塞直到执行完毕，可用其替代for循环
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(10, queue, ^(size_t index) { // index表示当前索引，自动增加
  NSLog(@&quot;%zu&quot;, index);
});
NSLog(@&quot;Done&quot;); // 最后执行
&lt;/code&gt;&lt;/pre&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dispatch_suspend / dispatch_resume：用于挂起和恢复queue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dispatch Semaphore：计数为0时等待，计数为1或大于1时，减1而不是等待&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dispatch_once：保证在应用程序中只执行一次指定处理的API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Dispatch IO：当读取大文件时，将文件分成合适的大小并使用Global Queue读取的话，会快很多，如果想尝试提高文件读取速度，可以使用Dispatch IO&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;225-备注&quot;&gt;2.2.5 备注&lt;/h4&gt;

&lt;p&gt;在iOS6.0之前，在GCD中每当使用带creat单词的函数创建对象之后，都应该对其进行一次release操作。在iOS6.0之后，GCD被纳入到了ARC的内存管理机制中，在使用GCD的时候我们就像对待普通OC对象一样对待GCD,因此不再需要我们调用release方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-nsoperation&quot;&gt;三. NSOperation&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;本身是个抽象类，需要使用其子类：NSInvocationOperation，NSBlockOperation，或自定义子类&lt;/li&gt;
    &lt;li&gt;默认情况下，调用 NSInvocationOperation 的 start 方法并不会开一条新线程去执行，而是在当前线程执行；需要把 NSOperation 放到一个 NSOperationQueue 中才会执行异步操作&lt;/li&gt;
    &lt;li&gt;NSBlockOperation：只要 NSBlockOperation 封装的操作数 &amp;gt; 1，就会异步执行操作&lt;/li&gt;
    &lt;li&gt;支持取消，暂停和恢复，还可以设置依赖来保证执行顺序，如 &lt;code class=&quot;highlighter-rouge&quot;&gt;[operationB addDependency:operationA]; // 操作B依赖于操作A&lt;/code&gt;；还可以在不同 queue 的 NSOperation 之间创建依赖关系&lt;/li&gt;
    &lt;li&gt;支持监听一个操作的执行完毕：通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;completionBlock&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;setCompletionBlock&lt;/code&gt; 实现&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-网络请求&quot;&gt;四. 网络请求&lt;/h2&gt;

&lt;p&gt;网络请求常用类：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;NSURL：请求地址&lt;/li&gt;
    &lt;li&gt;NSURLRequest：一个NSURLRequest对象就代表一个请求，它包含的信息有：一个 NSURL 对象，请求方法，请求头，请求体，请求超时等&lt;/li&gt;
    &lt;li&gt;NSMutableURLRequest：NSURLRequest的子类&lt;/li&gt;
    &lt;li&gt;NSURLConnection：负责发送请求；支持发送同步请求（sendSynchronousRequest）和异步请求（sendAsynchronousRequest）；还可以设置代理监听网络请求过程（开始响应，接收数据，结束响应，请求出错）&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;第三方框架：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;ASIHttpRequest&lt;/li&gt;
    &lt;li&gt;AFNetworking&lt;/li&gt;
    &lt;li&gt;MKNetworkKit&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;iOS中发送 HTTP 请求的方案：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;苹果原生
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;NSURLConnection：用法简单，坑较多&lt;/li&gt;
        &lt;li&gt;NSURLSession：功能比 NSURLConnection 强大，苹果推荐使用(但是NSURLSessionTask是一个抽象类，本身不能使用，只能使用它的子类：NSURLSessionDataTask\NSURLSessionUploadTask\NSURLSessionDownloadTask)&lt;/li&gt;
        &lt;li&gt;CFNetwork：NSURL*的底层实现，纯C语言&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种为NSURLConnection设置代理方式的区别：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    //第一种设置方式：
    //通过该方法设置代理，会自动的发送请求
    // [[NSURLConnection alloc]initWithRequest:request delegate:self];

    //第二种设置方式：
    //设置代理，startImmediately为NO的时候，该方法不会自动发送请求
    NSURLConnection *connect = [[NSURLConnection alloc]initWithRequest:request delegate:self startImmediately:NO];
    //手动通过代码的方式来发送请求
    //注意该方法内部会自动的把connect添加到当前线程的RunLoop中在默认模式下执行
    [connect start];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-数据解析&quot;&gt;五. 数据解析&lt;/h2&gt;

&lt;p&gt;Json解析（转OC数据类型）：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;第三方框架：JSONKit、SBJson、TouchJSON（性能从左到右，越差）&lt;/li&gt;
    &lt;li&gt;苹果原生：NSJSONSerialization（性能最好）&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Thread/Json转OC数据类型.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;XML解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解析方式有两种：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;DOM：一次性将整个XML文档加载进内存，比较适合解析小文件&lt;/li&gt;
        &lt;li&gt;SAX：从根元素开始，按顺序一个元素一个元素往下解析，比较适合解析大文件&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;解析API：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;官方原生：NSXMLParser，SAX方式解析&lt;/li&gt;
        &lt;li&gt;libxml2：纯C语言，默认包含在iOS SDK中，同时支持DOM和SAX方式解析&lt;/li&gt;
        &lt;li&gt;GDataXML：DOM方式解析，由Google开发，基于libxml2&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-runloop&quot;&gt;六. RunLoop&lt;/h2&gt;

&lt;p&gt;RunLoop是iOS中比较重要的一点，较短篇幅无法讲完，后面有机会再另起新篇总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;七-参考博客&quot;&gt;七. 参考博客&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;https://www.jianshu.com/p/0b0d9b1f1f19&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 24 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/24/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/24/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>常用算法思想</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;常见算法及其思想与对应题目总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-分治算法&quot;&gt;一. 分治算法&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;11-基本思想与适用场景&quot;&gt;1.1 基本思想与适用场景&lt;/h3&gt;

&lt;p&gt;分治法，顾名思义，即分而治之，适用于当一个问题很复杂，难以解决，但是可以分解为许多容易解决的相似子问题，且子问题解合并起来即为原复杂问题解时的情况&lt;/p&gt;

&lt;p&gt;从上面的描述中我们可以提取出分治法适用的几个&lt;strong&gt;要点&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;原问题可分解为许多&lt;strong&gt;相似&lt;/strong&gt;子问题&lt;/li&gt;
    &lt;li&gt;子问题&lt;strong&gt;解可合&lt;/strong&gt;并为原问题解&lt;/li&gt;
    &lt;li&gt;子问题独立，即子问题之间无公共子问题（非必须，涉及到分治法效率问题，若子问题之间不独立，分治法效率较低，一般使用动态规划）&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面的要点&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;是适用分治法的关键，也是判断一个问题是否可以使用分治法解决的关键，如果一个问题不满足第二条，可以考虑使用贪心或者动态规划；从其特征可以看出，分治法通常伴随着递归（因为有相似子问题，明显的递归解决思路），递归也是我们通常解决此类问题的常用手段&lt;/p&gt;

&lt;h3 id=&quot;12-应用举例&quot;&gt;1.2 应用举例&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;二分搜索&lt;/li&gt;
    &lt;li&gt;大整数乘法&lt;/li&gt;
    &lt;li&gt;Strassen矩阵乘法&lt;/li&gt;
    &lt;li&gt;棋盘覆盖&lt;/li&gt;
    &lt;li&gt;合并排序&lt;/li&gt;
    &lt;li&gt;快速排序&lt;/li&gt;
    &lt;li&gt;线性时间选择&lt;/li&gt;
    &lt;li&gt;最接近点对问题&lt;/li&gt;
    &lt;li&gt;循环赛日程表&lt;/li&gt;
    &lt;li&gt;汉诺塔&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;13-参考链接&quot;&gt;1.3 参考链接&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-动态规划&quot;&gt;二. 动态规划&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;11-基本思想与适用场景-1&quot;&gt;1.1 基本思想与适用场景&lt;/h3&gt;

&lt;p&gt;动态算法的核心是记住已经求过的解，在已知解的基础上继续求解；记住求解的方式有两种：一是&lt;strong&gt;自顶向下的备忘录法&lt;/strong&gt;，二是&lt;strong&gt;自底向上&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自顶向下一般涉及到递归，通常需要传递一个容器来存储结果，在分治算法中也提到了，当子问题不独立时，此时可以考虑使用动态规划（效率问题，用空间换取时间），该容器存储的结果实际上就是用于结束重复的递归计算&lt;/p&gt;

&lt;p&gt;自底向上即最开始就从子问题计算起，逐步往上，相当于递归的拆解（循环）&lt;/p&gt;

&lt;p&gt;参见&lt;a href=&quot;https://www.zhihu.com/question/23995189&quot;&gt;动态规划的意义&lt;/a&gt;，将动态规划视为状态的转移来进行理解和区别&lt;/p&gt;

&lt;p&gt;特征：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到–最优子结构&lt;/li&gt;
    &lt;li&gt;不管之前这个状态是如何得到的–无后效性&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;12-应用举例-1&quot;&gt;1.2 应用举例&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Fibonacci数列问题&lt;/li&gt;
    &lt;li&gt;钢条切割问题&lt;/li&gt;
    &lt;li&gt;小朋友过桥问题&lt;/li&gt;
    &lt;li&gt;背包模型&lt;/li&gt;
    &lt;li&gt;最长单调子序列&lt;/li&gt;
    &lt;li&gt;最大M子段和&lt;/li&gt;
    &lt;li&gt;线性模型&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;13-参考链接-1&quot;&gt;1.3 参考链接&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;https://blog.csdn.net/u013309870/article/details/75193592&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;https://www.zhihu.com/question/23995189&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-贪心算法&quot;&gt;三. 贪心算法&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-回溯法&quot;&gt;四. 回溯法&lt;/h2&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-分支限界法&quot;&gt;五. 分支限界法&lt;/h2&gt;
</description>
        <pubDate>Sat, 16 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/16/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</guid>
        
        <category>Algorithm</category>
        
        
      </item>
    
      <item>
        <title>iOS读书笔记</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;iOS 各类书籍读书笔记&lt;/p&gt;

&lt;p&gt;摘要各本书中重难点&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;objective-c-编程之道ios-设计模式&quot;&gt;Objective-C 编程之道：iOS 设计模式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;中介者模式是至用一个对象来封装一组对象之间的交互逻辑，中介者通过避免对象间显示的相互引用来增进不同对象间的松耦合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;备忘录模式允许对象按其想要的任何（或者任意复杂的）方式将自己的壮状态保存为一个对象，根据此模式这个对象被称为备忘录对象，然后某个其他对象，比如看管人对象，将备忘录对象保管在某处，通常是文件系统或内存中；看管人对象不知道有关备忘录对象的任何细节的格式，一段时间之后，接收到请求时，看管人对象将备忘录对象传回给原来的对象，让他根据在备忘录对象中保存的信息恢复其状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代理模式的一个特点是同归虚拟代理，在接到请求时实现重型资源的懒加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件设计的黄金法则：变动需要抽象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更；抽象层定义了供客户端使用的上层抽象接口；可以&lt;a href=&quot;https://www.jianshu.com/p/e986af029490&quot;&gt;参见博客&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外观模式为子系统中一组不同的接口提供统一的接口呢，外观模式定义了上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用（其实就是对一系列复杂操作再次进行封装，隐藏调用或者实现细节）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中介者模式用于定义一个集中的场所，对象间的交互可以在一个中介者对象中处理；其他对象不必彼此交互，因此减少了它们之间的依存关系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;观察者模式：iOS 中观察者模式可以通过通知和键值观察(KVO)来实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;迭代器模式：迭代器（Iterator）提供了一种顺序访问聚合对象(集合)中元素的方法，而无需暴露结构的底层表示和细节&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装饰模式：即动态的为一个对象添加额外的指责，是继承的替代方案，属于结构型模式（继承是编译时静态绑定，装饰模式是可以在运行是动态绑定，即定义一个接口，然后动态的注入不同的实现类）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;责任链模式：即如果一个对象不知道如何处理一个请求，则将该请求传递给另一个对象，这样继续传递下去&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;策略模式：提取公共接口，不同实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令模式：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;享元模式：实现享元模式需要两个关键组件，通常是可共享的享元对象和保存他们的池&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代理模式：代理是一种替代或占位，它控制对另一些对象的访问，而这些对象可能是远程对象，创建的开销较大的对象，或者是对安全性有要求的对象（NSProxy）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;uicollectionview解析&quot;&gt;UICollectionView解析&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;UICollectionViewCell 的层级结构见下图；UICollectionViewCell 有三个子 View ，下图中黑色矩形是 CollectioView Cell 自身，绿色矩形是 contentView，我们应该在contentView上面添加子 View，中间的两层 selectedBackgroundView 和 backgroundView 是可选的，并且可以在任何时候进行设置（当 backgroundView 被设置的时候，将会永远显示；selectedBackgroundView 在 Cell 被选中的时候设置，在 Cell 取消选中的时候移除，并且还可以为其设置动画）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/UICollectionViewCell_Hierarchy.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ios-drawing-practical-uikit-solution&quot;&gt;iOS Drawing: Practical UIKit Solution&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Context：包含了绘图的上下文环境；主要使用的有两种：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;Bitmap Context：使用像素数据来绘制&lt;/li&gt;
        &lt;li&gt;PDF Contexta：矢量数据，以矢量的形式来绘制&lt;/li&gt;
        &lt;li&gt;Core Image Context：帮助进行图像处理，如数字图像处理和计算机视觉等，通过GPU加速&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;iOS绘图程序主要基于UIKit和QuartzCore框架(QuertzCore框架通常被称作Quartz或者Quartz 2D)，它由新的Objective-C界面（UIKit提供）和老旧一些的C语言方法和核心基础类（QuartzCore）组成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在绘制图像的时候，有一个很重要的概念是上下文（Context），其实类似于一个大的状态机，每次改变都会改变其当前状态，可以通过 CGContextSaveGState 来暂存当前状态，之后通过 CGContextRestoreCState 来恢复状态；可以改变 Context 的属性如下图：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/Context_State.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要注意的是 UIKit 中坐标系原点为屏幕坐上点，在Quartz中，原点位于左下点，如下图；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/坐标系.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Quartz 和 UIKit 绘图方法都是线程安全的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;以CG开头Ref结尾的类型是指，指向对象的指针&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坐标系转换，即把一个点从视图坐标系转换到它的父视图的坐标系中：CGPoint convertedPoint = [fahterView convertPoint:samplePoint fromView:childView]; 如果要反向转换，可以使用：转换回来，使用convertRect：toView：；前提是这些视图必须在同一个 UIWindow 中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CGAffineTransform 可以用于进行旋转，缩放，位移变换（其实也是一个变换矩阵，如下图）；一般都不使用 CGAffineTransformMake 方法来构建，通常使用 CGAffineTransformMakeScale（），CGAffineTransformMakeRotate（）或是CGAffineTransformMakeTranslation（）来分别构造缩放，旋转，位移矩阵；可以通过 UIKit 的 NSStringFromCGAffineTransform 方法打印处转换后的矩阵值；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/CGAffineTransform.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CGPoint，CGRect，CGSize，CGAffineTransform等几何元素并不是对象，如果要存储或者更加直观的打印这些几何元素，OC 也提供了对应的方法，如：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;转换为 strings&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/To_Strings.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;转换为字典&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/To_Dictionary.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;转换为值类型&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/To_Value.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;几何测试方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/iOS_Read_Note/Graph_Test.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;swift文档&quot;&gt;Swift文档&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;http://www.swift51.com/swift4.0/chapter2/10_Properties.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;结构体和枚举是值类型，这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制；值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝；在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类是引用类型；可以使用恒等运算符（&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;!==&lt;/code&gt;）来判断两个常量或变量是否引用同一个类实例；Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存储属性存储常量或变量作为实例的一部分（&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;），而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体；一个存储属性就是存储在特定类或结构体实例里的一个常量或变量；计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;延迟存储属性（&lt;code class=&quot;highlighter-rouge&quot;&gt;lazy&lt;/code&gt;），即第一次使用的时候才会计算其值；必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性（如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次）；全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符（全局变量是在函数、方法、闭包或任何类型之外定义的变量）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;属性观察器：willSet 在新的值被设置之前调用；didSet 在新的值被设置之后立即调用；父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型属性：即与类相关的属性（而非与特定实例相关）；使用关键字 static 来定义类型属性；在方法的func关键字之前加上关键字static，来指定类型方法（类还可以用关键字class来允许子类重写父类的方法实现）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一（在 Objective-C 中，类是唯一能定义方法的类型）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下标：下标可以定义在类、结构体和枚举中；一个类型可以定义多个下标，通过不同索引类型进行重载。下标不限于一维，你可以定义具有多个入参的下标满足自定义类型的需求；定义下标使用subscript关键字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上final修饰符即可；也可以将类标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;的，那么此时该类不可被继承&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定构造器：指定构造器是类中最主要的构造器；每一个类都必须拥有至少一个指定构造器，在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;便利构造器：类中比较次要的、辅助型的构造器（在&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;关键字之前放置&lt;code class=&quot;highlighter-rouge&quot;&gt;convenience&lt;/code&gt;关键字）。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例（应当只在必要的时候为类提供便利构造器）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 15 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/15/iOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/15/iOS%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Jira插件开发总结</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;最近接到个需求开发Jira插件，陆陆续续还是踩了很多坑，在此记录一下&lt;/p&gt;

&lt;p&gt;Jira是比较常用的项目管理工具，由Java编写；Jira插件其实就是一个Jar包，借助于官方提供的SDK，可以很方便的获取各种数据和进行各种操作；但是有一个比较麻烦的是不同版本的Jira SDK的可用API不同，网上资料也较少，需要多看文档和摸索&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-环境搭建&quot;&gt;一. 环境搭建&lt;/h2&gt;

&lt;p&gt;首先我们需要搭建一个能在本地测试的环境，不然频繁的导出Jar包到线上环境将极大降低效率；这里有一个坑是：Jira SDK对Java版本要求比较严格，当时笔者用的Jira SDK 8.0，Java版本是Java 11，但是始终跑不起来，出现问题如下图；查了比较久，最终将Java版本改到Java 8得以解决；&lt;a href=&quot;https://confluence.atlassian.com/adminjiraserver073/supported-platforms-861253018.html&quot;&gt;Jira与Java版本对应关系&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Java_Jira/Jira.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后可以按照&lt;a href=&quot;https://developer.atlassian.com/server/jira/platform/role-members-jql-function-tutorial/&quot;&gt;官方教程&lt;/a&gt;写一个Hello World的Demo，先跑起来，熟悉一下开发流程；再推荐一篇&lt;a href=&quot;https://www.cnblogs.com/DevilMayCry-Samsara/p/6052286.html&quot;&gt;中文博客&lt;/a&gt;也比较详细&lt;/p&gt;

&lt;p&gt;本地访问链接是：http://localhost:2990/jira&lt;/p&gt;

&lt;p&gt;其实本地的Jira插件测试环境实际上是跑起来的一个Tomcat；这里记录几个有用的命令:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;atlas-run&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;atlas-debug&lt;/code&gt;：启动Tomcat，加载插件&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;atlas-mvn package&lt;/code&gt;：热更新，即如果代码有改动，那么可以运行此命令而不必重启Tomcat&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;atlas-clean&lt;/code&gt;：清除缓存，如果运行失败且无他法时，可以尝试用此命令清除一下缓存&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-定制插件&quot;&gt;二. 定制插件&lt;/h2&gt;

&lt;p&gt;再编写插件之前，需要先了解一下相关概念，即Jira Function，参见&lt;a href=&quot;https://developer.atlassian.com/server/jira/platform/jql-function/&quot;&gt;官方文档&lt;/a&gt;；一般来说我们定制Jira插件都需要继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractJqlFunction&lt;/code&gt;这个类，比较重要的有如下几个方法（注意：不同的SDK版本方法参数等可能有差异）&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public MessageSet validate(ApplicationUser searcher, FunctionOperand operand, TerminalClause terminalClause)&lt;/code&gt;：该方法再构造函数之后调用，用于进行参数验证，用户访问权限验证等&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public List&amp;lt;QueryLiteral&amp;gt; getValues(QueryCreationContext queryCreationContext, FunctionOperand operand, TerminalClause terminalClause)&lt;/code&gt;：该方法用于返回待展示的Item列表，我们的主要工作也在这个方法中&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;public int getMinimumNumberOfExpectedArguments()&lt;/code&gt;：返回接收的最少参数个数&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面也说了，不同版本的Jira SDK的可用API差异较大，这里举一个根据传入参数查询Issue列表的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	final ApplicationUser applicationUser = queryCreationContext.getApplicationUser();
        final List&amp;lt;String&amp;gt; args = operand.getArgs();
        final List&amp;lt;QueryLiteral&amp;gt; queryLiterals = new LinkedList&amp;lt;&amp;gt;();
        JqlQueryParser parser = ComponentAccessor.getComponent(JqlQueryParser.class);
        try {
            Query query = parser.parseQuery(args.get(0));
	    // private final SearchService searchService;
            SearchResults searchResult = searchService.search(applicationUser, query, PagerFilter.getUnlimitedFilter());
            List&amp;lt;Issue&amp;gt; issues = searchResult.getIssues();
            for (Issue issue : issues) {
                queryLiterals.add(new QueryLiteral(operand, issue.getId()));
            }
        } catch (Exception e) {
            log.error(&quot;Error search: &quot;, e);
	 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-参考链接&quot;&gt;三. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/pemcconnell/jira-jql-membersInRole&quot;&gt;Jira插件Demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/matthewlmcclure/jira-rankof-jql-function&quot;&gt;Jira插件Demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/kevshine/jira-opensource-jql-functions&quot;&gt;Jira插件Demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/mailru/jira-plugins-groovy&quot;&gt;Jira插件Demo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.atlassian.com/software/jira/docs/api/8.0.0/allclasses-noframe.html&quot;&gt;Jira SDK API&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 14 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/14/Jira%E6%8F%92%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/14/Jira%E6%8F%92%E4%BB%B6/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Objective-C入门要点</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;近日开始入坑iOS，正所谓工欲善其事，必先利其器；iOS的两大基础利器莫过于OC和Swift这两门语言了；笔者先接触的是OC，时至今日也近一月，以此总结，记录OC的一些要点和难点&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-面向对象&quot;&gt;一. 面向对象&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;OC是C的一个扩展集，在C的基础上添加了面向对象和消息传递等机制；作为一门面向对象的语言，自然需要探讨面向对象三大特性在OC上的体现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;11-封装&quot;&gt;1.1 封装&lt;/h3&gt;

&lt;p&gt;笔者认为，封装更多的是体现在类或者说类的设计上面，有点带设计模式那个层次，如果真要从语法层面去讲解的话，更契合的还是类，方法，成员变量的访问修饰符&lt;/p&gt;

&lt;p&gt;OC中类没有访问修饰符，OC中也没有package的概念&lt;/p&gt;

&lt;p&gt;OC中方法也没有权限修饰符一说，在头文件中声明的方法都相当于是public的，如果要定义私有方法，则只需在.m文件中实现，但不需要在.h文件声明&lt;/p&gt;

&lt;p&gt;成员变量权限访问修饰方法主要有如下三种；除了以下三种外，还有一个是@package，它修饰属性的时候，只能在当前框架中才能呗访问，用的比较少&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;修饰符&lt;/th&gt;
      &lt;th&gt;类内部&lt;/th&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;任何地方&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;private&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;protected（默认）&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;public&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
      &lt;td&gt;YES&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;12-继承&quot;&gt;1.2 继承&lt;/h3&gt;

&lt;p&gt;OC只支持单继承，如果要实现多继承，可以采用如下三种方式：&lt;/p&gt;

&lt;h4 id=&quot;121-通过组合实现&quot;&gt;1.2.1 通过组合实现&lt;/h4&gt;

&lt;p&gt;组合实际上就是说如果一个类无法实现某个功能，那么就将该需求转接到另一个类实现，比较简单，就是将能实现该功能的类作为自己的一个成员变量&lt;/p&gt;

&lt;h4 id=&quot;122-通过协议实现&quot;&gt;1.2.2 通过协议实现&lt;/h4&gt;

&lt;p&gt;协议类似于Java中的接口，但是也有所不同，参见下面对协议的讲解；OC中只能继承一个类，但是可以实现多个协议&lt;/p&gt;

&lt;h4 id=&quot;123-通过category实现&quot;&gt;1.2.3 通过Category实现&lt;/h4&gt;

&lt;p&gt;Category可以实现在不继承类的基础上实现对类的扩展；这里使用Category实现多继承举例如下：Child已经继承了Father，想要再对Child扩展方法，可以使用Category扩展&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 文件：Child.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Father&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;showChild&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 文件：Child+Hello.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 文件：Child+Hello.m
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;Hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-多态&quot;&gt;1.3 多态&lt;/h3&gt;

&lt;p&gt;Java中多态的实现依赖于重写，重载和向上转型（动态链接）；但是OC中方法不能重载，可以重写，其余的和普通Java多态的概念和用法基本相同；另外，Java中多态还有一个重要的点就是接口，依赖于接口达到的运行时动态绑定，与之对应的，在OC中可以使用协议实现&lt;/p&gt;

&lt;p&gt;这里还需要注意的是，重新认识OC中的方法签名，OC的语法比较冗余，举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 函数原型如下，方法签名为：addNumber1:andNumber2:
- (NSInteger)addNumber1:(NSInteger)number1 andNumber2:(NSInteger)number2;

// 函数原型如下，方法签名为：add::
- (NSInteger)add:(NSInteger)number1 :(NSInteger)number2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-协议&quot;&gt;二. 协议&lt;/h2&gt;

&lt;p&gt;OC中的协议相当于Java中的接口，很多设计模式都依赖于协议；但是OC中的协议于Java中的接口也有一些细微的差别；&lt;/p&gt;

&lt;p&gt;一般而言，协议应该与对应的类声明在同一个头文件中，与Java中接口不同的是，协议的中的方法不是必须都实现的，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@optional&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@required&lt;/code&gt;来声明方法，但是使用@required修饰的协议方法也不是必须实现的，如果没有实现，编译会报警告；但是如果调用了一个没有实现的协议方法的话，运行时会崩溃&lt;/p&gt;

&lt;p&gt;协议中不能有默认方法实现，这点与Java中的接口相同，但是OC的协议中不能定义变量；协议可以被class，struct，enum实现&lt;/p&gt;

&lt;p&gt;协议的使用场景：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;需要由别的类实现的方法&lt;/li&gt;
    &lt;li&gt;声明未知类的接口&lt;/li&gt;
    &lt;li&gt;两个类之间的通信&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-define宏定义&quot;&gt;三. define：宏定义&lt;/h2&gt;

&lt;p&gt;OC中的宏定义是非常强大的，合理使用可以极大的简化和优雅代码&lt;/p&gt;

&lt;h3 id=&quot;31-defineconstenum定义常量&quot;&gt;3.1 define，const，enum定义常量&lt;/h3&gt;

&lt;p&gt;define宏：只是在预处理器里进行文本替换，没有类型，不做任何类型检查，编译器可以对相同的字符串进行优化。只保存一份到 .rodata 段。甚至有相同后缀的字符串也可以优化，你可以用GCC 编译测试，”Hello world” 与 “world” 两个字符串，只存储前面一个。取的时候只需要给前面和中间的地址，如果是整形、浮点型会有多份拷贝，但这些数写在指令中。占的只是代码段而已，大量用宏会导致二进制文件变大&lt;/p&gt;

&lt;p&gt;const常量：共享一块内存空间，就算项目中N处用到，也不会分配N块内存空间，可以根据const修饰的位置设定能否修改，在编译阶段会执行类型检查&lt;/p&gt;

&lt;p&gt;enum枚举：只能定义int类型&lt;/p&gt;

&lt;p&gt;推荐使用const常量&lt;/p&gt;

&lt;p&gt;部分摘自&lt;a href=&quot;https://www.jianshu.com/p/f83335e036b5&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-宏定义&quot;&gt;3.2 宏定义&lt;/h3&gt;

&lt;p&gt;使用宏定义可以将一些冗杂的语句简化，使得调用简明；常用宏可以参见&lt;a href=&quot;https://my.oschina.net/leejan97/blog/354904&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-property修饰符&quot;&gt;四. @property修饰符&lt;/h2&gt;

&lt;p&gt;本来@property是和@synthesize共用来实现自动生成set和get方法的，但是Xcode4.4之后，@property得到了增强，只使用@property即可生成set和get方法，同时还会自动生成一个带下划线的同名私有变量（需要注意的是，当我们自己写了对应的set和get方法时，该带下划线的同名变量将不可用，解决办法参见&lt;a href=&quot;https://www.jianshu.com/p/baef6d5a41d3&quot;&gt;博客&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;但是@property的使用难点在于理解其修饰符，关于@property修饰符的使用涉及到内存管理，也是比较复杂的一部分，这里暂时搁置，找机会和内存管理一起讲解&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-xcode与模拟器快捷键&quot;&gt;五. Xcode与模拟器快捷键&lt;/h2&gt;

&lt;p&gt;说实话，刚从Android Studio转到Xcode实际上是很不习惯的，很明显的一个就是IDE写代码不顺手，AS各种快捷键与插件写起代码来简直上天～&lt;/p&gt;

&lt;p&gt;但既已入坑，还是自己去适应呗&lt;/p&gt;

&lt;p&gt;Xcode常用快捷键：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd + shift + o      快速打开文件
cmd + 1              切换成 Project Navigator (cmd + 2~7 也可以做相应切换，不过不常用）
cmd + ctrl + 上     在 .h 和 .m 文件之间切换
cmd + enter          切换成 standard editor
cmd + opt + enter    切换成 assistant editor
cmd + shift + y      切换 Console View 的显示或隐藏
cmd + 0              隐藏左边的导航 (Navigator) 区
cmd + opt + 0        隐藏右边的工具 (Utility) 区
ctrl  + 6            列出当前文件中所有的方法，可以输入关键词来过滤。这个相当赞，可以快速定位到想编辑的方法。
                     我直接把这个快键盘改成了 ctrl+o，这样按起来更顺手。
cmd + ctrl + 左 / 右   到上 / 下一次编辑的位置，在 2 个编辑位置跳转的时候很方便。
cmd + opt + j        跳转到文件过滤区
cmd + shift + f      在工程中查找
cmd + r              运行，如果选上直接 kill 掉上次进程的话，每次直接一按就可以重新运行了
cmd + b              编译工程
cmd + shift + k      清空编译好的文件
cmd + .              结束本次调试
ESC                  调出代码补全
cmd + 单击           查看该方法的实现
opt + 单击           查看该方法的文档
cmd + t              新建一个 tab 栏
cmd + shift + [      在 tab 栏之间切换
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;模拟器常用快捷键：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHIFT+CMD+H	回到桌面
CMD+Q		退出模拟器
CMD+S		模拟器截屏(所截图片都在桌面上)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-内存管理&quot;&gt;六. 内存管理&lt;/h2&gt;

&lt;p&gt;内存管理是一个比较难的点，东西也很多，并非三言两语就能阐述清楚，后面有机会再另起新篇&lt;/p&gt;

&lt;p&gt;————-分割线——————&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Draft：暂存&lt;/strong&gt;
@property修饰符，常见的几组如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;atomic, nonatomic：是否线程安全；默认为atomic，线程安全，但是会影响性能，一般使用nonatomic&lt;/li&gt;
    &lt;li&gt;retain, copy, assign：默认为assign，该修饰符对属性只是简单的赋值，不更改引用计数，常用于基本数据类型，如：int，short等；retain一般用于修饰指针，会持有对象，增加引用计数&lt;/li&gt;
    &lt;li&gt;readonly, readwrite&lt;/li&gt;
    &lt;li&gt;strong, getter=method, setter=method, unsafe_unretained&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;weak和assign的区别：weak和assign的区别主要是体现在两者修饰OC对象时的差异。上面也介绍过，assign通常用来修饰基本数据类型，如int、float、BOOL等，weak用来修饰OC对象，如UIButton、UIView等；weak不能修饰基本数据类型&lt;/p&gt;

&lt;p&gt;相关博客推荐：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;https://hk.saowen.com/a/1bdf81decab39874080a44833b2fc47eb8a59355e9ae2b997565552d63991f4d&lt;/li&gt;
    &lt;li&gt;https://hk.saowen.com/a/7b29e511436f99243478a22570615137266de714cbcda782e798ab04a4611d5e  及其后文链接&lt;/li&gt;
    &lt;li&gt;https://hk.saowen.com/a/e7b69dbe7dfea4e5a00ebd4ef4a73a61403c8351d319eb901a05388d38513dbf  及其后文链接&lt;/li&gt;
    &lt;li&gt;https://stackoverflow.com/questions/2255861/property-retain-assign-copy-nonatomic-in-objective-c&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 23 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/23/Objective-C%E5%85%A5%E9%97%A8%E8%A6%81%E7%82%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/23/Objective-C%E5%85%A5%E9%97%A8%E8%A6%81%E7%82%B9/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>大三上总结</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;大三上总结&lt;/p&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;h2 id=&quot;技术&quot;&gt;技术&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;看书：
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;«深入理解计算机系统»&lt;/li&gt;
        &lt;li&gt;«现代操作系统»&lt;/li&gt;
        &lt;li&gt;«Java并发编程实战»&lt;/li&gt;
        &lt;li&gt;«深入理解Java虚拟机»回滚&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博客，总结：https://husteryp.github.io/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;iOS：Swift，OC&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;思考&quot;&gt;思考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;思想转变
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;技术方向 –&amp;gt; 生活&lt;/li&gt;
        &lt;li&gt;年轻真好~&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;外院：如何去弥补这个非班科的差距；决定方向后可以去实习&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 01 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/01/01/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/01/%E5%A4%A7%E4%B8%89%E4%B8%8A%E6%80%BB%E7%BB%93/</guid>
        
        <category>Hust</category>
        
        
      </item>
    
      <item>
        <title>ListView[一]</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;本文将从&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的基本使用入手, 介绍常见的&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;性能优化问题&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;采用适配器模式, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的优化主要体现在&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;上; 本文也主要从&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter&lt;/code&gt;入手, 分析常见的优化问题&lt;/p&gt;

&lt;p&gt;文章代码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;kotlin&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-最差版本&quot;&gt;一. 最差版本&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的性能问题主要是其通常用于展示大量数据造成的; 我们手指上下滑动的时候伴随着&lt;code class=&quot;highlighter-rouge&quot;&gt;Adapter.getView()&lt;/code&gt;方法的不断调用, &lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的主要作用是去解析&lt;code class=&quot;highlighter-rouge&quot;&gt;XML&lt;/code&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图, 但是这一过程是一个耗时操作, 如果每次滑动都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;的话, 势必会造成界面的卡顿, 如下即是这种情况: 每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 然后再&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;再进行设置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 最差版本
class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view = mInflater.inflate(R.layout.item_main, parent, false)
        view.setOnClickListener{
            Toast.makeText(context,data[position],Toast.LENGTH_SHORT).show()
        }
        view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-优化一&quot;&gt;二. 优化一&lt;/h2&gt;

&lt;p&gt;为了避免每次滑动的时候都要&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;官方提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;的缓存机制, 即将滑动出屏幕外面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;缓存下来, 因为通常情况下&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;要展示的数据类型都是相同的, 所以可以复用同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;界面, 只是展示数据不同; 我们注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;getView()&lt;/code&gt;的参数中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;, 这个便是被缓存下来的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;, 所以我们第一次优化可以如下: 主要就是判断&lt;code class=&quot;highlighter-rouge&quot;&gt;convertView&lt;/code&gt;是否为空, 如果为空, 说明没有缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;, 此时就需要去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 否则, 直接更改展示数据即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
            return view
        }
        convertView.apply {
            findViewById&amp;lt;TextView&amp;gt;(R.id.item_text).text = data[position]
        }
        return convertView
    }

    // 其他方法按照常规写, 故此省略
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-优化二&quot;&gt;三. 优化二&lt;/h2&gt;

&lt;p&gt;到这里, 其实最耗时的部分已经被优化了, 那么我们是否还能够进行优化呢? 我们注意到每次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getView&lt;/code&gt;的时候, 虽然避免了每次都去&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;, 但是我们仍然每次都调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 那么这部分我们是否也可以避免掉呢, 当然是可以的, 此时我们的&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;就派上用场啦~&lt;/p&gt;

&lt;p&gt;这里我们使用了一个内部类, 将每次&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById&lt;/code&gt;找到的&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;保存下来, 因为我们前面说过了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;展示的时候, 通常数据类型都是相同的, 即界面相同, 只是每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示的数据不同而已, 因此也就没有必要每次都去执行一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;findViewById()&lt;/code&gt;, 这也是&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;所做的主要的优化&lt;/p&gt;

&lt;p&gt;另外, 还需要提一下的是这里保存&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;, 其实我们还可以用这个&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存许多我们需要的值, 而不用局限与&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewHolder&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(val context: Context) : BaseAdapter() {

    var data = ArrayList&amp;lt;String&amp;gt;()
    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        var holder: MyViewHolder
        if (convertView == null) {
            val view = mInflater.inflate(R.layout.item_main, parent, false)
            holder = MyViewHolder(view)
            holder.textView.text = data[position]
            view.tag = holder
            return view
        }
        holder = convertView.tag as MyViewHolder
        holder.textView.text = data[position]
        return convertView
    }
    
    // 其他方法按照常规写, 故此省略
    ...

    class MyViewHolder(val view: View){
        val textView: TextView by lazy {
            view.findViewById&amp;lt;TextView&amp;gt;(R.id.item_text)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-优化三&quot;&gt;四. 优化三&lt;/h2&gt;

&lt;p&gt;将异步操作放在子线程中执行; 其实这个也不算&lt;code class=&quot;highlighter-rouge&quot;&gt;ListView&lt;/code&gt;自身特殊的优化, 而是由&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;自身特性所决定的&lt;/p&gt;

&lt;p&gt;如下; 当加载大图时, 使用异步的&lt;code class=&quot;highlighter-rouge&quot;&gt;AsyncTask&lt;/code&gt;去网络下载好后再展示到界面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyAdapter(private val context: Context) : BaseAdapter() {

    private val mInflater by lazy {
        context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
    }

    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
        val view: View = convertView ?: mInflater.inflate(R.layout.item_main, parent, false)
        val holder: ViewHolder = view.tag as ViewHolder? ?: ViewHolder(view)
        ImageLoader(holder).execute(ImageUrl.url[position])
        return view
    }

    // 其他方法按照常规写, 故此省略
    ...

    class ImageLoader(private var holder: ViewHolder) : AsyncTask&amp;lt;String, Void, Bitmap&amp;gt;() {

        private val cache: LruCache&amp;lt;String, Bitmap&amp;gt; by lazy {
            val maxMemory = Runtime.getRuntime().maxMemory()
            val cacheSize = maxMemory / 8
            object: LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize.toInt()) {
                override fun sizeOf(key: String?, value: Bitmap?): Int {
                    return value?.allocationByteCount ?: 0
                }
            }
        }

        override fun doInBackground(vararg params: String?): Bitmap? {
            val urlStr = params[0]
            var bitmap = cache.get(urlStr)
            if (bitmap != null)
                return bitmap
            val url = URL(urlStr)
            var connection: HttpURLConnection? = null
            try {
                connection = url.openConnection() as HttpURLConnection
                connection.connectTimeout = 5000
                connection.readTimeout = 5000
                bitmap = BitmapFactory.decodeStream(connection.inputStream)
                cache.put(urlStr, bitmap)
            } catch (e: Exception) {
                Log.d(&quot;@HusterYP&quot;,&quot;error&quot;, e)
            } finally {
                connection?.disconnect()
            }
            return bitmap
        }

        override fun onPostExecute(result: Bitmap?) {
            holder.imageView.setImageBitmap(result)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码其实还有问题; 只是解决了异步加载, 但是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;视图的缓存复用, 当滑动的时候会出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Item&lt;/code&gt;展示图片不断改变的现象; 关于此问题的解决可以参见&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/45586553&quot;&gt;博客&lt;/a&gt; (&lt;strong&gt;注:&lt;/strong&gt; 上述代码图片&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;也来自该博客)&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/ListView-%E4%B8%80/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>ListView</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;ListView笔记&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;问题: 展示大量数据, 处理内存开销和性能&lt;/p&gt;

&lt;p&gt;复用: 重新填写内容而已&lt;/p&gt;

&lt;p&gt;stable ID&lt;/p&gt;

&lt;p&gt;ListView相关内容:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView相关.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;getView():&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;错误的使用方式: 如下; 每次都会创建一个新的View视图(会去解析XML, 这是非常耗时的); 特别是当用户滑动的时候, 这种写法将产生大量的View视图&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Slow_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;正确的使用方式: 如下; 复用convertView; 但是下面这种写法也存在待优化的地方, 因为它每次都需要去findViewById(), 这点其实还可以改进&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Right_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最快的方式: 如下; 使用ViewHolder, 节省findViewById的时间; 还可以通过setTag()和getTag()来存储更多的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/ListView/ListView_Fast_Way.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;数据集更新的方式:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;notifyDataSetChanged()&lt;/li&gt;
    &lt;li&gt;notifiyDataSetInvalidated(): 表示数据集无效了&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;getViewType()和getViewTypeCount()&lt;/p&gt;

&lt;p&gt;可以通过设置Item的属性, enable或者disable, enable时Item可以被点击和选择, disable时不可被点击和选择; disable属性可以用于比如单纯的展示header展示等&lt;/p&gt;

&lt;p&gt;HeaderView和FooterView:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;listView.addHeaderView()&lt;/li&gt;
    &lt;li&gt;listView.addFooterView()&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;List Selector: 高亮选中Item&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;可以在xml中指定属性&lt;code class=&quot;highlighter-rouge&quot;&gt;android:drawSelectorOnTop = &quot;true&quot;&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;创建一个XML的selector选择器&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;自定义ListView的背景的时候会出现问题貌似; 好像会出现在滑动的时候出现全是黑色的情况; 解决办法:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;xml中指定: &lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;#00000000&quot;&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;android:cacheColorHint = &quot;@color/myBackgroundColor&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;在ScrollView中嵌套ListView&lt;/p&gt;

&lt;p&gt;ListView中的Filter是什么?&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;场景: 当我们要展示的条目很多时, 我们可以设置选项让用户选择查看哪些分类的选项, 而不是全部展示&lt;/li&gt;
    &lt;li&gt;将Adapter实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;接口即可(当Adapter继承的是BaseAdapter时, SimpleAdapter默认实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Filterable&lt;/code&gt;)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;对ListView设置Item的点击监听:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;listView.setOnItemClickListener(new OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view,
        int position, long id) {
        Toast.makeText(getApplicationContext(),
            &quot;Click ListItem Number &quot; + position, Toast.LENGTH_LONG)
            .show();
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;获取LayoutInflator可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以设置ListView没有数据时的占位View, 指定id为&lt;code class=&quot;highlighter-rouge&quot;&gt;@android:id/empty&lt;/code&gt;的View即可&lt;/p&gt;

&lt;h2 id=&quot;scrollview嵌套listview&quot;&gt;ScrollView嵌套ListView&lt;/h2&gt;

&lt;p&gt;问题: 只能显示一个Item(ListView不能全部展示)&lt;/p&gt;

&lt;h2 id=&quot;listview的item是scrollview&quot;&gt;ListView的Item是ScrollView&lt;/h2&gt;

&lt;p&gt;ListView性能优化官方文档: https://developer.android.com/training/improving-layouts/smooth-scrolling
性能优化官方推荐博客: https://android-developers.googleblog.com/2009/01/why-is-my-list-black-android.html&lt;/p&gt;

&lt;p&gt;ListView和大多数Android组件一样有透明背景, 也就意味这你可以看到Window的背景色; 但是当使用自定义ListView背景或者改变Window背景的话, 会出现问题;&lt;/p&gt;

&lt;p&gt;当ListView滑动时会依照不同的滑动方向来填充ListView; 比如从上往下填充或者从下往上填充;&lt;/p&gt;

&lt;p&gt;优化: 除了Demo中写的几个常见的优化外; ListView的性能优化其实就是使getView()方法更快而已&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;异步加载: 对于耗时资源在getView中去异步加载; 但是有一个问题是当快速滑动时, 此时需要去处理滑动时不加载的情况&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;ListView  height设置wrap_content 导致getView()重复调用问题&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/12/08/ListView/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/08/ListView/</guid>
        
        <category>Draft</category>
        
        
      </item>
    
  </channel>
</rss>
