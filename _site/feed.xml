<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>袁平</title>
    <description>Hello-World</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 11 Sep 2018 11:07:23 +0800</pubDate>
    <lastBuildDate>Tue, 11 Sep 2018 11:07:23 +0800</lastBuildDate>
    <generator>Jekyll v3.8.3</generator>
    
      <item>
        <title>Linux开机启动流程</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux开机启动流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中实验基于&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;版本（&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.x&lt;/code&gt;版本都可以，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS7.x&lt;/code&gt;版本会有所区别）&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-启动流程&quot;&gt;一. 启动流程&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;开关电源（&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;）在开机之后将&lt;code class=&quot;highlighter-rouge&quot;&gt;AC&lt;/code&gt;信号转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;DC&lt;/code&gt;信号，然后&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;会进行电压的检测，如果正常，&lt;code class=&quot;highlighter-rouge&quot;&gt;SMPS&lt;/code&gt;将会发送&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt; 信号给主板定时器，主板定时器接收到&lt;code class=&quot;highlighter-rouge&quot;&gt;POWER GOOD&lt;/code&gt;信号之后，将会停止发送&lt;code class=&quot;highlighter-rouge&quot;&gt;reset&lt;/code&gt;指令给&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;，这意味着电脑可以正常启动&lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;的设置中有一些值是固定的，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;才知道从哪里开始读取指令，在&lt;code class=&quot;highlighter-rouge&quot;&gt;X86&lt;/code&gt;计算机中，第一条指令是&lt;code class=&quot;highlighter-rouge&quot;&gt; FFFF:0000h &lt;/code&gt;，指向&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;的最后一个字节，该指令因为只有一个字节，所以只是简单的包含一个跳转指令，该跳转指令指向的是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;所在的地址（&lt;code class=&quot;highlighter-rouge&quot;&gt;EPROM&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ROM&lt;/code&gt;中）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;就是基本输入输出系统，其功能主要有两个：&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;POST：&lt;code class=&quot;highlighter-rouge&quot;&gt;Power On Self Test&lt;/code&gt;；硬件自检；即在&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中有一个硬件设备的列表，为了检测某一个硬件设备是否可用，就发送一个电脉冲给每一个设备，如果该脉冲被设备返回，说明设备可用，否则，不可用；如果有新的硬件接入，那么会使用同样的检测过程，同时会更新&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中的列表，用于下次启动过程&lt;/li&gt;
    &lt;li&gt;选择第一个启动设备：&lt;code class=&quot;highlighter-rouge&quot;&gt; BIOS&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;里面的记录的启动顺序以及上一步硬件自检过程中，设备的可用装态，确定最终的可启动设备顺序，具体的过程是&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;将磁盘的第一扇区（磁盘最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节）载入内存，放在 &lt;code class=&quot;highlighter-rouge&quot;&gt;0X0000:0X7C00&lt;/code&gt;处，然后检查这个扇区的最后两个字节是不是&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;，如果是则认为这是一个有效的启动扇区，如果不是就会尝试下一个启动介 质，如果找到可以启动的程序就会从这一介质启动，如果所有的启动介质都判断过后仍然没有找到可启动的程序那么&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;会给出错误提示&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;： 我们平时所说的更改&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;设置，实际上是错的，我们更改的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;CMOS&lt;/code&gt;中存储的设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;中信息不能被用户改变，需要厂商提供闪存程序&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;MBR&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;BIOS&lt;/code&gt;确定好第一个启动设备之后，去该设备磁盘的第一个扇区读取最开始的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节到内存（通过硬件的&lt;code class=&quot;highlighter-rouge&quot;&gt;INT 13&lt;/code&gt;中断功能来读取的），该&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节就是&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;，即主引导记录；这&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节中有&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节才是正真的主引导加载代码（&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，即可以安装引导加载程序的地方），还有&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;字节用于存放磁盘分区表信息，以及最后两个字节用于校验（&lt;code class=&quot;highlighter-rouge&quot;&gt;55AA&lt;/code&gt;)是否为有效的启动扇区；每个分区需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节用于存储分区的开始，结束位置，分区类型等（由于每个分区信息需要&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;个字节，所以对于采用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;型分区结构的硬盘(其磁盘卷标类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;MS-DOS&lt;/code&gt;)，最多只能识别&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个主要分区。所以对于一个采用此种分区结构的硬盘来说，想要得到&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个以上的主要分区是不可能的。这里就需要引出了扩展分区。扩展分区也是主分区（&lt;code class=&quot;highlighter-rouge&quot;&gt;Primary partition&lt;/code&gt;）的一种，但它与主分区的不同在于理论上可以划分为无数个逻辑分区，每一个逻辑分区都有一个和&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;结构类似的扩展引导记录(&lt;code class=&quot;highlighter-rouge&quot;&gt;EBR&lt;/code&gt;) ）（&lt;code class=&quot;highlighter-rouge&quot;&gt; MBR&lt;/code&gt;分区方案无法支持超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;容量的磁盘。因为这一方案用&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;个字节存储分区的总扇区数，最大能表示&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;次方的扇区个数，按每扇区&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节计算，每个分区最大不能超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，如果磁盘容量超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2TB&lt;/code&gt;，那分区的起始位置 就无法表示了）&lt;/li&gt;
  &lt;li&gt;继续之前，我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;的信息，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS6.4&lt;/code&gt;为例（后文不再声明），使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;dd if=/dev/sda of=mbr bs=512 count=1&lt;/code&gt;，将第一个扇区的&lt;code class=&quot;highlighter-rouge&quot;&gt;512&lt;/code&gt;字节内容转存到&lt;code class=&quot;highlighter-rouge&quot;&gt;mbr&lt;/code&gt;文件中，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;bs&lt;/code&gt;表示大小；然后可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;file mbr&lt;/code&gt;来查看分区信息等，输出如下；其中&lt;code class=&quot;highlighter-rouge&quot;&gt;partition x&lt;/code&gt;表示第&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;个分区的信息，上面说了，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;时最多只能有四个分区，而且这四个分区中最多只能有一个活动分区，也就是下面被标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;active&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;partition 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; x86 boot sector; partition 1: ID=0x83, active, starthead 32, startsector 2048, 19451904 sectors; partition 2: ID=0x5, starthead 254, startsector 19455998, 2093058 sectors, code offset 0x63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage1&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;中的前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节存储着引导加载程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;，这里以&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;为例；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;有两个阶段（实际上应该是三个阶段，后面会解释），实际上这&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中存储的只是&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;的第一阶段，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节的空间实在有限，做不了太多事情；&lt;code class=&quot;highlighter-rouge&quot;&gt;Grub&lt;/code&gt;第一阶段的作用主要是加载第二阶段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;GRUB&lt;/code&gt;实际上分为三个阶段：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1 -- stage1.5 -- stage2&lt;/code&gt;）&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;是存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;前&lt;code class=&quot;highlighter-rouge&quot;&gt;446&lt;/code&gt;字节中的引导加载程序；&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1.5&lt;/code&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;：扇区编号从0开始，但是真正的磁盘分区一般是从第63个扇区开始的，也就是说从1-63扇区是空闲的（第0个扇区存储&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR&lt;/code&gt;），这段空间叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GAP&lt;/code&gt;），因为&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;）存储于磁盘上，但是读取文件系统需要驱动，&lt;code class=&quot;highlighter-rouge&quot;&gt;MBR GA&lt;/code&gt;P中主要存储的就是读取文件系统的&lt;code class=&quot;highlighter-rouge&quot;&gt;driver&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;读取该部分内容之后，就可以去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;grub&lt;/code&gt;配置文件，即&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的内容&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Grub–Stage2&lt;/strong&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;stage1&lt;/code&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;stage2&lt;/code&gt;的配置文件，主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/grub/grub.conf&lt;/code&gt;，这里我们先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;grub.conf&lt;/code&gt;的内容，如下&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;：这个必须和下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;对应，在配置文件中有几个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;，启动的时候就会有几个菜单可以选择；&lt;code class=&quot;highlighter-rouge&quot;&gt;default=0&lt;/code&gt;表示使用第一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;选项来启动，&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;表示在读秒时间结束前都没有按键，则使用默认选项启动&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout=5&lt;/code&gt;：读秒时间，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;秒钟内没有按键，则使用默认选项启动；当然可以自行调整时间&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;splashimage=(hd0,0)/grub/splash.xpm.gz&lt;/code&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS&lt;/code&gt;启动的时候，后台不是黑白而是彩色变化的，就是这个文件提供的后台图示&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hidemenu&lt;/code&gt;：是否显示提示菜单，默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;hide&lt;/code&gt;的，但是笔者这里将这个选项注释掉了，在选择开机启动项的时候还会显示提示菜单&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;：这部分指定的是菜单选项，开机时有多少个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;就会有多少个菜单选项；每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;title&lt;/code&gt;下的内容，一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;kernel&lt;/code&gt;文件及设置，另一个是指定&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;位置&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/grub_conf.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Kernel&lt;/strong&gt;加载：&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loade&lt;/code&gt;根据用户的选项，去加载相应的磁盘映像到内存，内核是一个压缩文件，解压缩后，内核会再一次进行测试与驱动周边设备；之后，内核需要去加载各个模块，&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;内核可以动态加载内核模块，这些内核模块放置在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;目录下，由于模块放置到磁盘根目录下，所以内核要去读取这些模块的话，需要挂载到根目录，这样才能读取内核模块加载驱动程序的功能，但是内核根本不认识&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘，所以需要加载&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;磁盘的驱动程序，否则根本无法挂载根目录，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;SATA&lt;/code&gt;的驱动程序是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/lib/modules/&lt;/code&gt;内，这就出现了两难的问题，所以为了去挂载根目录，就出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;这个东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;initrd&lt;/strong&gt;：虚拟文件系统，一般位于&lt;code class=&quot;highlighter-rouge&quot;&gt;/boot/initrd&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Boot Loader&lt;/code&gt;在将内核加载到内存的同时，也会将&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;加载到内存中，并仿真成为一个根目录；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;的作用就是去加载必要的驱动，以便内核可以访问真正的根文件系统（如：磁盘控制器驱动，文件系统驱动（&lt;code class=&quot;highlighter-rouge&quot;&gt;ext3&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ext4&lt;/code&gt;等）），然后去挂载真正的根文件系统，进行根切换操作，用真正的根文件系统进行启动；&lt;code class=&quot;highlighter-rouge&quot;&gt;initrd&lt;/code&gt;完成上述任务之后，会清除掉自己在内存中的痕迹，让出空间&lt;/li&gt;
  &lt;li&gt;内核及其必要模块加载完毕之后，会主动执行第一个程序，即&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;，这也是第一个启动的进程；&lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt;的主要功能是根据其配置文件（&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;）去准备软件的执行环境（系统服务等）；这里我们看一下其配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/inittab&lt;/code&gt;的内容；如下；前面的注释是对该配置文件的描述，在笔者的该系统中，&lt;code class=&quot;highlighter-rouge&quot;&gt;inittab&lt;/code&gt;中只有一项配置，即运行级别（&lt;code class=&quot;highlighter-rouge&quot;&gt;runlevel&lt;/code&gt;）的设置，所谓的&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;会根据&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;的设置来启动不同的服务，让&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;的运行环境不同；至于&lt;code class=&quot;highlighter-rouge&quot;&gt;run level&lt;/code&gt;，分为七个等级：如下；&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0 -- halt&lt;/code&gt;：系统直接关机&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 -- single user mode&lt;/code&gt;：单用户维护模式，用在系统出问题时的维护&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2 -- Multi-user， without NFS&lt;/code&gt;：类似下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;，只是没有&lt;code class=&quot;highlighter-rouge&quot;&gt;NFS&lt;/code&gt;服务&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3 -- Full multi-user mode&lt;/code&gt;：完整含有网络功能的纯文本模式&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4 -- unused&lt;/code&gt;：系统保留功能&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;5 -- X11&lt;/code&gt;：与&lt;code class=&quot;highlighter-rouge&quot;&gt;level 3&lt;/code&gt;类似，但是加载使用&lt;code class=&quot;highlighter-rouge&quot;&gt;X Window&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6 -- reboot&lt;/code&gt;：重新启动&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里笔者将运行级别设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;，所以是以纯文本形式启动，即纯命令行模式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Linux_Boot/inittab.png&quot; alt=&quot;grub.conf&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;到这里系统就启动起来啦 ~ ，这也是系统启动的大致流程 ~&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-参考链接&quot;&gt;二. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;鸟哥私房菜基础学习篇第三版&lt;/li&gt;
  &lt;li&gt;https://www.slashroot.in/linux-booting-process-step-step-tutorial-understanding-linux-boot-sequence&lt;/li&gt;
  &lt;li&gt;https://www.linuxnix.com/linux-booting-process-explained/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 11 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/11/Linux%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
        
        <category>Linux</category>
        
        <category>操作系统</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之ConcurrentHashMap</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识; 本文将主要讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentHashMap&lt;/code&gt;的实现原理和处理细节&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;sizeCtl, 线程自旋&lt;/p&gt;

&lt;p&gt;U.compareAndSwapInt: 双重check&lt;/p&gt;

&lt;p&gt;在java7的ConcurrentHashMap实现上，使用了所谓分段锁的方法，而所谓分段锁就是将记录分段存储，不同段的访问互相不影响，某个线程想要访问某一个段的时候就需要对该段上锁，而其他线程不能访问在有其他线程加锁的段&lt;/p&gt;

&lt;p&gt;ConcurrentHashMap是基于CAS来实现线程安全的，CAS是一种轻量级的锁，它不会阻塞线程，而是会等待直到获得变量，然后进行业务操作，这和锁需要阻塞线程来实现线程安全来比较，是一种很大的改良，&lt;/p&gt;

&lt;p&gt;https://docs.oracle.com/javase/9/docs/api/index.html?overview-summary.html&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/08/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BConcurrentHashMap/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/08/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BConcurrentHashMap/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之Queue</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;的实现类, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;是一个双端队列, 内部使用数组实现, 既可以作为栈使用, 也可以作为队列使用(当作为栈使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;快; 当作为队列使用时, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;快); 既然是双端队列, 那么自然支持首尾插入删除等操作; &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;不是线程安全的, 不允许插入&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;内部使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Object[] elements&lt;/code&gt;来容纳元素, 默认初始容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, 需要注意的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量大小需要为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数幂次方, 这是为了使用位运算去代替普通的乘除运算来提高效率; 下面将从两个方面讲解其有关知识点: 即基本方法和扩容规则&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-基本方法&quot;&gt;二. 基本方法&lt;/h2&gt;

&lt;h3 id=&quot;21-构造函数&quot;&gt;2.1 构造函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;提供了三个构造函数, 这里只挑其中一个比较难的讲解; 如下, 该构造函数允许提供自定义初始容量, 但是并不是说, 我们传进去多少容量, 最初就会分配多少容量, 因为传进去的值还经过了&lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的处理; &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;函数的作用是, 找出不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;numElements&lt;/code&gt;的最小的&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的整数, 因为上面已经说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的容量需要都是&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂; 这点和&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的扩容规则比较相像, 具体分析可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;中对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;扩容规则一节的讲解; 另外, 值得一提的是, &lt;code class=&quot;highlighter-rouge&quot;&gt;calculateSize()&lt;/code&gt;的时候还进行了边界值的判断, 一个是初始容量最小为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 最大不得超过&lt;code class=&quot;highlighter-rouge&quot;&gt;2^30&lt;/code&gt;, 如下代码;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void allocateElements(int numElements) {
        elements = new Object[calculateSize(numElements)];
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static int calculateSize(int numElements) {
        int initialCapacity = MIN_INITIAL_CAPACITY;  // 初始最小容量为8
        // Find the best power of two to hold elements.
        // Tests &quot;&amp;lt;=&quot; because arrays aren't kept full.
        if (numElements &amp;gt;= initialCapacity) {
            initialCapacity = numElements;
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  1);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  2);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  4);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt;  8);
            initialCapacity |= (initialCapacity &amp;gt;&amp;gt;&amp;gt; 16);
            initialCapacity++;

            if (initialCapacity &amp;lt; 0)   // Too many elements, must back off
                initialCapacity &amp;gt;&amp;gt;&amp;gt;= 1;// Good luck allocating 2 ^ 30 elements // 最大容量为2^30
        }
        return initialCapacity;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-元素增删&quot;&gt;2.2 元素增删&lt;/h3&gt;

&lt;p&gt;双端队列的难点在于数据元素增删的时候, 如何通过首尾指针的关系判断当前队列是满还是空, 以及插入和删除元素后首尾指针的变化情况; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中的处理是, &lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针指向队列首元素, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向队列尾元素的后一个位置, 那么比如在队列头部插入元素时,  通过判断&lt;code class=&quot;highlighter-rouge&quot;&gt;(head - 1) &amp;amp; (elements.length - 1) == tail&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的时候队列就满了, 这样, 虽然双端队列在队列满和空的情况下, 都是&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;, 但是仍然能够分辨&lt;/p&gt;

&lt;p&gt;下面我们通过具体的元素添加来看, 如下, 为在队列头添加元素, 这里需要注意的一点是先添加元素, 再判断队列是否已满, 这是因为上面我们说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;tail&lt;/code&gt;指针指向的是队尾元素的下一个位置, 一定是空位置, 否则在上一次添加元素的时候就会引起扩容了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addFirst(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[head = (head - 1) &amp;amp; (elements.length - 1)] = e;
        if (head == tail)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里讲一下&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;的运算规则, 比如, 当我们的数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;, 本次插入之前&lt;code class=&quot;highlighter-rouge&quot;&gt;head = 0&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tail = 7&lt;/code&gt;的时候, 执行该插入操作, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (head - 1) &amp;amp; (elements.length - 1)&lt;/code&gt;元素, 即 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1 &amp;amp; 7&lt;/code&gt;, 转换为二进制就是(&lt;code class=&quot;highlighter-rouge&quot;&gt;1111 &amp;amp; 0111 = 0111&lt;/code&gt;), 最终运算结果为&lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;, 所以可以判断队列满了, 需要扩容 ~&lt;/p&gt;

&lt;p&gt;其实这里使用位运算也是利用了数组容量为&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;的整数次幂的特点&lt;/p&gt;

&lt;p&gt;同理, 在队列尾插入元素也是一样的, 如下; 就不再分析啦~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void addLast(E e) {
        if (e == null)
            throw new NullPointerException();
        elements[tail] = e;
        if ( (tail = (tail + 1) &amp;amp; (elements.length - 1)) == head)
            doubleCapacity();
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于删除元素来说, 这里举一个例子, 如下; 主要看&lt;code class=&quot;highlighter-rouge&quot;&gt;head&lt;/code&gt;指针的变化规则, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;head = (h + 1) &amp;amp; (elements.length - 1);&lt;/code&gt;, 其实就是和插入元素相反的过程而已&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public E pollFirst() {
        int h = head;
        E result = (E) elements[h];
        // Element is null if deque empty
        if (result == null)
            return null;
        elements[h] = null;     
        head = (h + 1) &amp;amp; (elements.length - 1);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-扩容规则&quot;&gt;三. 扩容规则&lt;/h2&gt;

&lt;p&gt;什么时候会扩容呢, 我们注意到, 上面我们讲解插入元素指针变化规则的时候, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;head == tail&lt;/code&gt;也就是队列满了的时候, 会调用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;
函数, 其实该函数就是用于扩容的&lt;/p&gt;

&lt;p&gt;那么根据上面的分析, 什么时候会发生扩容呢, 其实就是当队列满的时候; 扩容的规则又是怎样的呢, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;doubleCapacity()&lt;/code&gt;的函数名我们猜测, 就是将数组容量加倍而已; 如下, 思路也比较简单, 就是创建一个扩容的新数组进行旧元素的复制罢了, 比较简单, 不再赘述&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void doubleCapacity() {
        assert head == tail;
        int p = head;
        int n = elements.length;
        int r = n - p; // number of elements to the right of p
        int newCapacity = n &amp;lt;&amp;lt; 1; // 左移一位, 相当于容量加倍
        if (newCapacity &amp;lt; 0)
            throw new IllegalStateException(&quot;Sorry, deque too big&quot;); // 这是因为左移溢出之后会变成负值, 说明队列太大啦~
        Object[] a = new Object[newCapacity];
        System.arraycopy(elements, p, a, 0, r);
        System.arraycopy(elements, 0, a, r, p);
        elements = a;
        head = 0;
        tail = n;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四-总结&quot;&gt;四. 总结&lt;/h2&gt;

&lt;p&gt;到这里, &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;的源码就分析完啦~; 最后笔者还想补充解释一点的是, 最开始我们提过, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为栈来使用的时候, 比&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;要快, 关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;, 我们在&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;Java集合框架概述&lt;/a&gt;中粗略的提过, &lt;code class=&quot;highlighter-rouge&quot;&gt;Stack&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Java 2&lt;/code&gt;以前的几个遗留&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 其内部也是使用数组实现的, 但是由于其加了锁, 支持多线程访问, 所以会比&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;要慢; 当&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayDeque&lt;/code&gt;作为队列使用的时候,
比&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;要快是因为在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;内部是使用链表节点实现的, 不具备数组的索引定位, 当然也就是慢啦~&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BQueue/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Fresco源码解析</title>
        <description>&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;初始化Fresco: Fresco.initialize(this); 最好在Application中初始化, 多次初始化是无意义的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心类为: SimpleDraweeView; 在layout中使用该类, 然后在代码中, 剩下的Fresco自动完成&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/logo.png&quot;);
SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view);
draweeView.setImageURI(uri);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Fresco会自动完成:
    &lt;blockquote&gt;
      &lt;ol&gt;
        &lt;li&gt;显示占位图直到加载完成；&lt;/li&gt;
        &lt;li&gt;下载图片；&lt;/li&gt;
        &lt;li&gt;缓存图片；&lt;/li&gt;
        &lt;li&gt;图片不再显示时，从内存中移除；&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;关键概念&quot;&gt;关键概念&lt;/h2&gt;

&lt;h3 id=&quot;一-drawees&quot;&gt;一. Drawees&lt;/h3&gt;

&lt;p&gt;分为三个主要部分, 有点像MVC模式&lt;/p&gt;

&lt;h4 id=&quot;11-draweeview&quot;&gt;1.1 DraweeView&lt;/h4&gt;

&lt;p&gt;一般情况下使用SimpleDraweeView即可&lt;/p&gt;

&lt;h4 id=&quot;12-draweehierarchy&quot;&gt;1.2 DraweeHierarchy&lt;/h4&gt;

&lt;p&gt;用于组织和维护最终绘制和呈现的 Drawable 对象, 可通过它来自定义图片显示效果&lt;/p&gt;

&lt;h4 id=&quot;13-draweecontroller&quot;&gt;1.3 DraweeController&lt;/h4&gt;

&lt;p&gt;负责和 image loader 交互（ Fresco 中默认为 image pipeline, 当然你也可以指定别的), 对所要显示的图片做更多的控制&lt;/p&gt;

&lt;p&gt;如果你还需要对Uri加载到的图片做一些额外的处理，那么你会需要这个类&lt;/p&gt;

&lt;h4 id=&quot;14-draweecontrollerbuilder&quot;&gt;1.4 DraweeControllerBuilder&lt;/h4&gt;

&lt;p&gt;由 DraweeControllerBuilder 采用 Builder 模式创建，创建之后，不可修改&lt;/p&gt;

&lt;h4 id=&quot;15-listeners&quot;&gt;1.5 Listeners&lt;/h4&gt;

&lt;p&gt;使用 ControllerListener 的一个场景就是设置一个 Listener监听图片的下载。&lt;/p&gt;

&lt;h3 id=&quot;二-image-pipeline&quot;&gt;二. Image Pipeline&lt;/h3&gt;

&lt;p&gt;负责图片的获取和管理&lt;/p&gt;

&lt;p&gt;压缩后的文件缓存在本地存储中，Bitmap数据缓存在内存中。Image pipeline 会首先从内存中搜寻图片，然后是磁盘缓存，再然后是网络或其他来源&lt;/p&gt;

&lt;p&gt;在5.0系统以下，Image Pipeline 使用 pinned purgeables 将Bitmap数据避开Java堆内存，存在ashmem中。这要求图片不使用时，要显式地释放内存。&lt;/p&gt;

&lt;p&gt;SimpleDraweeView自动处理了这个释放过程，所以没有特殊情况，尽量使用SimpleDraweeView，在特殊的场合，如果有需要，也可以直接控制Image Pipeline&lt;/p&gt;

&lt;p&gt;Image pipeline 默认有3个线程池:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;3个线程用于网络下载&lt;/li&gt;
    &lt;li&gt;2个线程用于磁盘操作: 本地文件的读取，磁盘缓存操作。&lt;/li&gt;
    &lt;li&gt;2个线程用于CPU相关的操作: 解码，转换，以及后处理等后台操作。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;uri格式&quot;&gt;URI格式&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/supported-uris.html&quot;&gt;URI支持格式&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;drawee的各种效果配置fresco支持的各种图片层级&quot;&gt;Drawee的各种效果配置(Fresco支持的各种图片层级)&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/drawee-branches.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;设置要加载的图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;占位图(Placeholder)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置加载失败占位图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击重新加载图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示进度条&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;背景&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置叠加图(Overlay)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置按压状态下的叠加图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缓存策略&quot;&gt;缓存策略&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/caching.html&quot;&gt;参见文档&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.fresco-cn.org/docs/getting-started.html&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 06 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/06/Fresco/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/06/Fresco/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>大二下总结</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;将一切交给时光, 相信一切都是最好的结局&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;大二下学期可能是我大学生活中最刺激的一个阶段, 大概就是整整一个学期, 从周一到周末, 每天满课的那种; 更刺激的是一天考了三门(早中晚, 没毛病~)&lt;/p&gt;

&lt;p&gt;上课期间, 学的主要是算法和&lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;基础这部分; 暑假期间, 主要是做项目&lt;/p&gt;

&lt;p&gt;总体感受: 稍显疲惫 ~&lt;/p&gt;

&lt;h2 id=&quot;二-项目&quot;&gt;二. 项目&lt;/h2&gt;

&lt;p&gt;项目部分主要是暑假接触到的两个项目, 一个与&lt;code class=&quot;highlighter-rouge&quot;&gt;OpenGL&lt;/code&gt;有关, 另一个是工具类&lt;code class=&quot;highlighter-rouge&quot;&gt;App&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;21特点&quot;&gt;2.1特点&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;产品迭代快, 周期短&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;框架复用, 模块化明显: 广告, 打点, 使用逻辑等(后者复用前者的大部分, 除了使用逻辑改变了, 其余基本相同)(同一个框架填不同内容)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;核心功能简单直接, 迭代快, 但注定消亡的也快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;纯&lt;code class=&quot;highlighter-rouge&quot;&gt;Kotlin&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22一点体会&quot;&gt;2.2一点体会&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;公司业务紧跟市场&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;负载量大: 大概就是想摸鱼都没有水的那种 ~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对一个产品细节上感受: &lt;code class=&quot;highlighter-rouge&quot;&gt;The Best !&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个产品的总体流程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三-规划&quot;&gt;三. 规划&lt;/h2&gt;

&lt;h3 id=&quot;31不足&quot;&gt;3.1不足&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;知识点零碎, 构不成框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新事物的把握不足&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不够深入和全面&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;32安排&quot;&gt;3.2安排&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;总结成文&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;具体安排新事物的学习时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;各方面的联系, 框架~&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;思考和内化&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/01/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/01/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/</guid>
        
        <category>Hust</category>
        
        
      </item>
    
      <item>
        <title>图片缓存之Picasso源码分析</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;图片缓存系列之&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;在开始之前, 我想先贴两张比较具有概括性的流程图&lt;/p&gt;

&lt;p&gt;下面这张是对&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;核心交互类的概括, 来自&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso.png&quot; alt=&quot;Picasso&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面这张是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;下载一张图片的时候的执行流程图, 来自&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/post/Picasso/picasso执行流程图.png&quot; alt=&quot;picasso流程图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 笔者在看&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码的时候, 发现其执行流程和上图有些不符, 主要是没有最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;Downloader&lt;/code&gt;, 下载过程完全交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去做, 应该是不同版本造成的; (本文对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;源码版本为&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso:2.71828&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中比较重要的类在上面第一张图片已经列出, 主要是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;; 下面分别总述一下其作用:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;: 该类是我们使用的起点, 是图片下载, 图片转换, 图片缓存的&lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;; 其提供的静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;, 用于接收用户配置, 一般而言, 我们都使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的一个全局实例(单例);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;: 顾名思义, 就是一个调度中转站, 用于分发请求(下载请求, 暂停请求, 恢复请求等), 传递数据(数据成功返回时进行分发绑定), 错误处理分发等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;: 这是一个抽象类, 提供了数据处理的公共抽象; &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;默认实现的有&lt;code class=&quot;highlighter-rouge&quot;&gt;AssetRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ResourceDrawableRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContentStreamRequestHandler&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ContactsPhotoRequestHandler&lt;/code&gt;; 分别对应于不同的处理场景和模式, 其中最重要和最常见的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;了; 当然, 也可以自定义实现该类, 用于处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;所没有涵盖的特殊情况(需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso.Builder.addRequestHandler(RequestHandler)&lt;/code&gt;注册)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面, 笔者将主要分析网络请求这一部分, 包括: 一条&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;被处理的完整流程,  暂停,恢复和取消请求机制, 缓存机制; 当然, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;还处理了很多其他情况, 如程序监控部分, 图片处理部分等, 但这些不是最主要的, 本文不再赘述&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-url处理流程&quot;&gt;二. URL处理流程&lt;/h2&gt;

&lt;p&gt;开始之前, 需要先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的典型使用, 如下; 各部分的作用都已经标注清楚了, 下面将对每一个过程进行讲解&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     PicassoProvider.get() // 单例, 用于得到一个全局唯一Picasso实例
        .load(url) // 加载url
        .placeholder(R.drawable.placeholder) // 设置图片加载过程中的占位图片
        .error(R.drawable.error) // 设置出错后的占位图片
        .fit() // 图片处理部分, 表示将图片适应ImageView大小
        .tag(context) // 设置tag, 用于暂停, 恢复, 取消请求时使用
        .into(view); // 加载成功后设置到哪个View中
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoProvider.get()&lt;/code&gt;是实现的一个单例模式, 如下; 该模式比较常见, 不多讲&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Picasso get() {
    if (instance == null) {
      synchronized (PicassoProvider.class) {
        if (instance == null) {
          Context autoContext = PicassoContentProvider.context;
          if (autoContext == null) {
            throw new NullPointerException(&quot;context == null&quot;);
          }
          instance = new Picasso.Builder(autoContext).build();
        }
      }
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上面我们可以看出, &lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的实例是通过其静态内部类&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;进行&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;的, 这也是一种典型的设计模式–&lt;code class=&quot;highlighter-rouge&quot;&gt;Builder&lt;/code&gt;模式; 该模式对于有很多参数要设置时是很方便的, 这里没有进行额外的参数设置, 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部的默认参数(比如: 默认缓存大小, 使用自带&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;等进行请求处理等)&lt;/p&gt;

&lt;p&gt;之后的过程是将&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;加载进去, 然后将该&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt;实例, 返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestCreator&lt;/code&gt;实例, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;into&lt;/code&gt;的时候, 进行异步请求图片; 当然, 在之前, 还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;placeholder()&lt;/code&gt;的过程, 该过程上面说了就是设置一个请求过程中的占位图片, 其内部做的也很简单, 只是将&lt;code class=&quot;highlighter-rouge&quot;&gt;ID&lt;/code&gt;保留下来, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;中进行统一的逻辑处理&lt;/p&gt;

&lt;p&gt;接下来, 主要的处理逻辑都指向了&lt;code class=&quot;highlighter-rouge&quot;&gt;into()&lt;/code&gt;函数, 下面我们来详细看其逻辑; 如下, 先设置占位图片, 然后将请求封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;实例提交到线程池中处理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void into(@NonNull ImageView target, @Nullable Callback callback) {
    ...
    if (!data.hasImage()) {
      picasso.cancelRequest(target);
      if (setPlaceholder) {
        setPlaceholder(target, getPlaceholderDrawable()); // 设置占位图片
      }
      return;
    }
    ...
    Action action = new ImageViewAction(picasso, wrapper, request, callback);
    picasso.enqueueAndSubmit(action); // 提交请求
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.enqueueAndSubmit()&lt;/code&gt;又只是单纯的去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;submit()&lt;/code&gt;中将任务分配给&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void submit(Action action) {
    dispatcher.dispatchSubmit(action);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行调度实际上是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行消息传递的, 该&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;DispatcherHandler&lt;/code&gt;, 我们直接去看其&lt;code class=&quot;highlighter-rouge&quot;&gt;handleMessage()&lt;/code&gt;就好;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchSubmit(Action action) {
    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void handleMessage(final Message msg) {
    case REQUEST_SUBMIT: {
          Action action = (Action) msg.obj;
          dispatcher.performSubmit(action);
          break;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performSubmit()&lt;/code&gt;中进行处理, 将请求再次封装为一个&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 之后提交给线程池进行异步加载, 即下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;service.submit()&lt;/code&gt;, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;实际上是&lt;code class=&quot;highlighter-rouge&quot;&gt;PicassoExecutorService&lt;/code&gt;, 继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;ThreadPoolExecutor&lt;/code&gt;, 默认开了&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;个线程, 当然, 这部分与网络请求相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;内部也进行了判断, 比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;Wifi&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;2G&lt;/code&gt;环境下采用不同的请求策略, 感兴趣的话可以自己跟着走一遍, 这里的主要目的是看一个网络请求的完整处理过程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  void performSubmit(Action action, boolean dismissFailed) {
        ...
        hunter = forRequest(action.getPicasso(), this, cache, stats, action);
        hunter.future = service.submit(hunter);
        ...
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们上面说了, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 线程池执行的时候, 就是去执行其&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;方法, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中, 有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;, 其作用是将请求得到的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bitmap&lt;/code&gt;封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;返回, 这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;是一个阻塞耗时方法, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;异步运行, 所以也没有问题; 而在&lt;code class=&quot;highlighter-rouge&quot;&gt;hunt()&lt;/code&gt;中, 又是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&lt;/code&gt;的一个实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;NetworkRequestHandler&lt;/code&gt;去处理的, 处理过程也是常规的图片下载过程, 如下;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    result = hunt();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void load(@NonNull Picasso picasso, @NonNull final Request request, @NonNull
  final Callback callback) {
    ...
    ResponseBody body = response.body();
    ...
    Bitmap bitmap = decodeStream(body.source(), request);
    callback.onSuccess(new Result(bitmap, loadedFrom));
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在图片接受完成之后, 再一步步函数返回, 封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;Result&lt;/code&gt;, 回传至&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;中; 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行通知图片接受成功还是失败; 最终会在&lt;code class=&quot;highlighter-rouge&quot;&gt;deliver()&lt;/code&gt;中调用主线程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;通知进行处理;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void run() {
    ...
    if (result.getBitmap() == null &amp;amp;&amp;amp; result.getDrawable() == null) {
        dispatcher.dispatchFailed(this);
    } else {
        dispatcher.dispatchComplete(this);
    }
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void deliver(BitmapHunter hunter) {
    ...
    mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_COMPLETE, hunter));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;的处理逻辑在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;类中, 很明显, 到这里之后就是将图片设置到&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final Handler HANDLER = new Handler(Looper.getMainLooper()) {
    @Override public void handleMessage(Message msg) {
      switch (msg.what) {
        case HUNTER_COMPLETE: {
          BitmapHunter hunter = (BitmapHunter) msg.obj;
          hunter.picasso.complete(hunter);
          break;
        }
        ...
      }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至此, 从网络请求图片的一个完整过程就讲完了, 当然, 中间还涉及很多代码细节和处理, 最好自己跟着流程再一遍 ~&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-暂停-恢复-取消请求处理&quot;&gt;三. 暂停, 恢复, 取消请求处理&lt;/h2&gt;

&lt;p&gt;暂停请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;; 恢复请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 取消请求使用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;; 一般来说, 这些的使用场景是, 考虑当我们从网络加载图片填充到&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;的时候, 如果我们在用户不断滑动过程中不暂停请求的话, 那么就会造成加载的延迟和卡顿(因为在不断滑动过程中会产生许多网络请求); 一般比较通用的解决方法是给&lt;code class=&quot;highlighter-rouge&quot;&gt;GridView&lt;/code&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;ScrollListener&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;GridScrollListener&lt;/code&gt;), 监听滑动过程, 在滑动过程中暂停请求, 停止滑动时恢复请求即可&lt;/p&gt;

&lt;p&gt;那么暂停, 恢复, 取消请求的实现机制又是如何的呢, 下面我们将一一分析&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;31-暂停请求&quot;&gt;3.1 暂停请求&lt;/h3&gt;

&lt;p&gt;我们直接看&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.pauseTag();&lt;/code&gt;做了什么, 如下; 其直接交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;进行请求分发, 这也符合我们上面总述的时候讲的&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;的功能; 之后&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;仍然通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;进行事件分发, 如下; 而其对&lt;code class=&quot;highlighter-rouge&quot;&gt;TAG_PAUSE&lt;/code&gt;事件的处理则是直接转交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.performPauseTag(tag);&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void pauseTag(@NonNull Object tag) {
    checkNotNull(tag, &quot;tag == null&quot;);
    dispatcher.dispatchPauseTag(tag);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void dispatchPauseTag(Object tag) {
    handler.sendMessage(handler.obtainMessage(TAG_PAUSE, tag));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;performPauseTag()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;保存到&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedActions&lt;/code&gt;中, 这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performPauseTag(Object tag) {
    // Trying to pause a tag that is already paused.
    if (!pausedTags.add(tag)) { // 如果已经添加, 则直接返回
      return;
    }

    // Go through all active hunters and detach/pause the requests
    // that have the paused tag. // 否则, 遍历BitmapHunter, 将对应tag保存下来
    for (Iterator&amp;lt;BitmapHunter&amp;gt; it = hunterMap.values().iterator(); it.hasNext();) {
        ...
        pausedActions.put(single.getTarget(), single);
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么我们什么时候会用到该&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;呢, 就是在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;分发请求的时候, 这里先去判断在&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中是否有对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;记录, 如果有的话, 就不进行请求分发, 那么自然也就不会去下载图片了 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performSubmit(Action action, boolean dismissFailed) {
    if (pausedTags.contains(action.getTag())) {
      pausedActions.put(action.getTarget(), action);
      ...
      return;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32--恢复请求&quot;&gt;3.2  恢复请求&lt;/h3&gt;

&lt;p&gt;恢复请求使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeTag();&lt;/code&gt;; 恢复请求的过程和暂停请求的过程差不多, 前面都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Dispatcher&lt;/code&gt;直接进行请求分发, 然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;去发送消息, 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;进行处理; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performResumeTag()&lt;/code&gt;中, 一个是将&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;pausedTags&lt;/code&gt;中移除, 另一个是将原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;(封装了请求等信息)通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;传递, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;mainThreadHandler&lt;/code&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;REQUEST_BATCH_RESUME&lt;/code&gt;的处理, 则是对每一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;去调用&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.resumeAction()&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performResumeTag(Object tag) {
    // Trying to resume a tag that is not paused.
    if (!pausedTags.remove(tag)) {
      return;
    }

    List&amp;lt;Action&amp;gt; batch = null;
    for (Iterator&amp;lt;Action&amp;gt; i = pausedActions.values().iterator(); i.hasNext();) {
      Action action = i.next();
      if (action.getTag().equals(tag)) {
        if (batch == null) {
          batch = new ArrayList&amp;lt;&amp;gt;();
        }
        batch.add(action);
        i.remove();
      }
    }

    if (batch != null) {
      mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;resumeAction()&lt;/code&gt;中, 其实就是将请求交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;enqueueAndSubmit()&lt;/code&gt;, 而该过程在上面我们分析一个&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;的完整请求过程的时候, 已经看到过该函数了; 接下来的过程就不赘述了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void resumeAction(Action action) {
    ...
    enqueueAndSubmit(action);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-取消请求&quot;&gt;3.3 取消请求&lt;/h3&gt;

&lt;p&gt;取消请求用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;picasso.cancelRequest();&lt;/code&gt;, 该函数一共有三个重载函数, 但是最终都是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;cancelExistingRequest()&lt;/code&gt;处理, 接下来的过程和上面的过程差不多, &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatcher.dispatchCancel()&lt;/code&gt;分发消息, 然后交给&lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt;传递消息, 最终调用&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;处理请求; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;performCancel()&lt;/code&gt;中, 其实就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;移除就好了, 前面我们说过, &lt;code class=&quot;highlighter-rouge&quot;&gt;BitmapHunter&lt;/code&gt;是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Runnable&lt;/code&gt;, 所以将其移除之后, 自然就取消请求啦 ~&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performCancel(Action action) {
    String key = action.getKey();
    BitmapHunter hunter = hunterMap.get(key);
    if (hunter != null) {
      hunter.detach(action);
      if (hunter.cancel()) {
        hunterMap.remove(key);
        ...
      }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;34-小结&quot;&gt;3.4 小结&lt;/h3&gt;

&lt;p&gt;到这里, 暂停, 恢复, 取消请求的过程我们已经有了比较详细的了解, 当然, 对于一个图片加载库来说, 这些接口也都是必备的&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-缓存&quot;&gt;四. 缓存&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的缓存也分为内存缓存和磁盘缓存, 内存缓存基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;可以自行配置缓存大小等, 磁盘缓存依赖与&lt;code class=&quot;highlighter-rouge&quot;&gt;Http&lt;/code&gt;缓存, 不可配置&lt;/p&gt;

&lt;p&gt;至于内存缓存部分, 逻辑很常规, 在&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;中已经比较详细的讲过&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;的源码了, 可以参照该博客; 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认使用的内存缓存最大容量是可用内存的&lt;code class=&quot;highlighter-rouge&quot;&gt;15%&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;磁盘缓存, 实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是交给了&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;去实现, 而没有明确的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;去缓存; 使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;OkHttp&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;okhttp3.Cache&lt;/code&gt;, 该类中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;用于磁盘缓存; &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的缓存策略可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/&quot;&gt;图片三级缓存之内存缓存和磁盘缓存&lt;/a&gt;, 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;OKHttp&lt;/code&gt;的缓存策略会单独抽取一篇博客出来;
这里只是简单提一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;中默认的磁盘缓存策略, 即使用存储容量的&lt;code class=&quot;highlighter-rouge&quot;&gt;2%&lt;/code&gt;, 但是不多于&lt;code class=&quot;highlighter-rouge&quot;&gt;50M&lt;/code&gt;不少于&lt;code class=&quot;highlighter-rouge&quot;&gt;5M&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;五-总结&quot;&gt;五. 总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Pciasso&lt;/code&gt;的主要源码就分析到这里, 最后还想贴一下&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;的总体特性&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;轻量级的图片加载库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自带监控功能, 可以检测&lt;code class=&quot;highlighter-rouge&quot;&gt;cache hit/内存大小&lt;/code&gt;等等数据&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片预加载&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程并发数依网络状态变化而变化, 优先级调度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持图片变换, 图片压缩, 自适应&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;易扩展&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Picasso&lt;/code&gt;是一个优秀的图片加载库, 其也具备了一个图片加载库应该具有的模块:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;请求分发模块。负责封装请求,对请求进行优先级排序,并按照类型进行分发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存模块。通常包括一个二级的缓存，内存缓存、磁盘缓存。并预置多种缓存策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下载模块。负责下载网络图片。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监控模块。负责监控缓存命中率、内存占用、加载图片平均耗时等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图片处理模块。负责对图片进行压缩、变换等处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地资源加载模块。负责加载本地资源，如assert、drawable、sdcard等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示模块。负责将图片输出显示。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;六-参考链接&quot;&gt;六. 参考链接&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://skykai521.github.io/2016/02/25/Picasso%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/&quot;&gt;Picasso源代码分析&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chdjj/article/details/49964901&quot;&gt;Picasso学习笔记&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.trinea.cn/android/android-image-cache-compare/&quot;&gt;Android 三大图片缓存原理、特性对比&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 01 Sep 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/01/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B9%8BPicasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>图片三级缓存之内存缓存和磁盘缓存</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要分析&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中图片三级缓存中的前两级缓存, 即内存缓存(&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;)和磁盘缓存(&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;), 分析其源码实现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-lrucache&quot;&gt;一. LruCache&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;常用作内存缓存, 也就是第一级缓存&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;内部使用了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实例, 所以在继续往下看之前, 建议先了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的特性, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;, 该文章有讲解如何将&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;用作内存缓存以及&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的一些基本分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 其依据是&lt;strong&gt;如果数据最近被访问过, 那么其将来被访问的几率也更大&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;逻辑其实比较简单, 大致逻辑就是: 设定最大阈值(&lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;), 当我们缓存一个新值的时候, 去判断是否超过该阈值, 如果超过了, 则移除最久未使用的缓存(这是利用的&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的特性, 可以参考上面的链接); 这是&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;的一个大致流程与思路, 接下来我们会详细讲解一些较为细节的地方&lt;/p&gt;

&lt;p&gt;先来看其构造函数: &lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;只有一个构造函数, 需要传递一个最大的缓存阈值; 同时需要注意的是, 这里构造&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的时候, 将&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;标志位设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;了, 使得&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;通过访问顺序来构造双向链表, 这在我们讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;源码的时候重点分析过, 这里不再赘述 !&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public LruCache(int maxSize) {
        if (maxSize &amp;lt;= 0) {
            throw new IllegalArgumentException(&quot;maxSize &amp;lt;= 0&quot;);
        }
        this.maxSize = maxSize;
        this.map = new LinkedHashMap&amp;lt;K, V&amp;gt;(0, 0.75f, true);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然, &lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;还允许重新设置该阈值, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;trimToSize()&lt;/code&gt;函数实现, 如下; 实现思路也很简单, 就是通过遍历当前缓存值, 然后不断删除最久未使用的缓存, 直到缓存量在阈值之下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     public void trimToSize(int maxSize) {
        while (true) {
            K key;
            V value;
            synchronized (this) {
                ...
                if (size &amp;lt;= maxSize || map.isEmpty()) {
                    break;
                }

                Map.Entry&amp;lt;K, V&amp;gt; toEvict = map.entrySet().iterator().next();
                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);
                size -= safeSizeOf(key, value);
                evictionCount++;
            }

            entryRemoved(true, key, value, null);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在我们平时使用的时候, 需要重点关注的有两个方法, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeOf()&lt;/code&gt;, 另一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;entryRemoved()&lt;/code&gt;; 这两个方法通常都会根据实际需要重写; 两个方法也很简单, 下面分别讲解&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sizeOf()&lt;/code&gt;: 返回一个缓存条目的大小, 注意应该和&lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;在一个量级(以便正确比较); 其默认返回&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 单纯的表示缓存的条目数量, 代码很简单(只是&lt;code class=&quot;highlighter-rouge&quot;&gt;return 1&lt;/code&gt;而已), 这里就不贴啦 ~&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;entryRemoved()&lt;/code&gt;: 该方法有点意思, 默认是一个空方法, 没有做任何处理; 在发生&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;缓存冲突的时候(&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;重复, 冲突)和删除缓存条目的时候会调用(通过传入参数&lt;code class=&quot;highlighter-rouge&quot;&gt;evicted&lt;/code&gt;标志, &lt;code class=&quot;highlighter-rouge&quot;&gt;evicted == true&lt;/code&gt;表示为&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;是被删除的, &lt;code class=&quot;highlighter-rouge&quot;&gt;evicted == false&lt;/code&gt;表示&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;冲突被挤出来的)&lt;/p&gt;

&lt;p&gt;一般我们重写该方法是为了做一些旧数据的回收清理等特殊工作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-disklrucache&quot;&gt;二. DiskLruCache&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;常用作磁盘缓存, 也就是第二级缓存; 虽然其没有纳入&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;的官方&lt;code class=&quot;highlighter-rouge&quot;&gt;API&lt;/code&gt;, 但是受到了&lt;code class=&quot;highlighter-rouge&quot;&gt;Google&lt;/code&gt;的官方推荐; 源代码可以从&lt;a href=&quot;https://github.com/JakeWharton/DiskLruCache&quot;&gt;Github&lt;/a&gt;下载&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的基本思路是, 将文件缓存到磁盘上, 设定最大的缓存阈值, 超过该值的时候, 会在后台去清除旧缓存&lt;/p&gt;

&lt;p&gt;需要注意的是, 这里旧文件的清除是在后台线程完成的(实际上是开了一个线程池去做该工作), 有时候缓存的文件总量会暂时超过最大阈值, 所以对缓存容量比较敏感的程序应该设置保守的缓存阈值&lt;/p&gt;

&lt;p&gt;先来看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的构造函数; 其只有一个构造函数, 如下; 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;directory&lt;/code&gt;表示缓存目录; &lt;code class=&quot;highlighter-rouge&quot;&gt;appVersion&lt;/code&gt;表示应用版本号, 当该值改变时, &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;会清除所有缓存, 默认需要从网上拉取新数据; &lt;code class=&quot;highlighter-rouge&quot;&gt;valueCount&lt;/code&gt;表示的是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;可以对应多少个文件, 通常都传入&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;即可, 该值通常用于表示将一个大文件分成多个小文件存放, 存放的规则是, &lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;后面加上自增的索引(如&lt;code class=&quot;highlighter-rouge&quot;&gt;key1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;key2&lt;/code&gt;等)(当然, 这些都是内部处理细节, 具体使用的时候可以不用管); &lt;code class=&quot;highlighter-rouge&quot;&gt;maxSize&lt;/code&gt;表示的是缓存阈值(&lt;code class=&quot;highlighter-rouge&quot;&gt;byte&lt;/code&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) {
    this.directory = directory;
    this.appVersion = appVersion;
    this.journalFile = new File(directory, JOURNAL_FILE);
    this.journalFileTmp = new File(directory, JOURNAL_FILE_TEMP);
    this.journalFileBackup = new File(directory, JOURNAL_FILE_BACKUP);
    this.valueCount = valueCount;
    this.maxSize = maxSize;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;的文件缓存依赖于日志文件, 即存储在同一文件夹下的名为&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;的文件, 在该文件中, 存储了每个文件缓存的信息;  在开始之前, 需要先了解一下该文件的格式, 因为后面会去读取该日志文件, 做判断; 关于该文件格式, 可以参考&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/28863651&quot;&gt;Android DiskLruCache完全解析，硬盘缓存的最佳方案&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          libcore.io.DiskLruCache
          1
          100
          2
     
          CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
          DIRTY 335c4c6028171cfddfbaae1a9c313c52
          CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
          REMOVE 335c4c6028171cfddfbaae1a9c313c52
          DIRTY 1ab96a171faeeee38496d8b330771a7a
          CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
          READ 335c4c6028171cfddfbaae1a9c313c52
          READ 3400330d1dfc7f3f7f4b8d4d803dfcf6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;中, 有三个重要的内部类, 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;, 用于文件写入; 一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;, 表示一个文件信息节点; 还有一个是&lt;code class=&quot;highlighter-rouge&quot;&gt;Snapshot&lt;/code&gt;, 表示文件节点的快照, 其实就是为了防止数据更改, 对&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;信息做了一层封装&lt;/p&gt;

&lt;p&gt;其中, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;成员变量, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;中有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;成员变量, 这是为了考虑在多线程中使用的时候, 通过判断携带的是不是同一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Editor&lt;/code&gt;来判断是否是在同一个线程中操作同一个文件; 因为&lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;不允许多个线程去操作同一个文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class Editor {
    private final Entry entry;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final class Entry {
    ...
    private Editor currentEditor;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外, 这里还需要关注的一点是, &lt;code class=&quot;highlighter-rouge&quot;&gt;DiskLruCache&lt;/code&gt;是如何判断哪些文件是旧文件; 这里我们发现了一个熟悉的身影, 即&lt;code class=&quot;highlighter-rouge&quot;&gt;
private final LinkedHashMap&amp;lt;String, Entry&amp;gt; lruEntries = new LinkedHashMap&amp;lt;String, Entry&amp;gt;(0, 0.75f, true);&lt;/code&gt;, 前面我们知道了&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的访问特性来实现旧文件的判断和移除, 这里其实也是一样, 只不过这里存储的是&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;; 这也是前面日志文件&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;的作用&lt;/p&gt;

&lt;p&gt;在初始化的时候, 会先去&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;日志文件读取键值信息, 在&lt;code class=&quot;highlighter-rouge&quot;&gt;readJournal()&lt;/code&gt;中不断的去读取&lt;code class=&quot;highlighter-rouge&quot;&gt;journal&lt;/code&gt;文件, 然后调用&lt;code class=&quot;highlighter-rouge&quot;&gt;readJournalLine()&lt;/code&gt;构建信息, 存储在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;中; 然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;值或者判断旧文件去移除的时候, 就直接去查询&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;中的值就好了; 至于判断旧文件的原理, 和&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;一样, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void readJournal() throws IOException {
    ...
    while (true) {
        try {
          readJournalLine(reader.readLine());
          lineCount++;
        } catch (EOFException endOfJournal) {
          break;
        }
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void readJournalLine(String line) throws IOException {
    ...
    Entry entry = lruEntries.get(key);
    if (entry == null) {
      entry = new Entry(key);
      lruEntries.put(key, entry);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-总结&quot;&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;到这里, 我们对内存缓存和磁盘缓存所需要使用到的两个类有了较为详细的了解, 之后该动手自己实践啦 !&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/31/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%B9%8BLruCache%E5%92%8CDiskLurCache/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之LinkedHashMap</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识; 本文将主要讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的实现原理和处理细节&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 所以需要先对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;有一个基本的认识, 可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 除了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;元素遍历无序, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;元素遍历有序以外, 具有&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的大多数特点; 另外, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;内部还有一个双向链表, 用于记录元素顺序(这也是保证其遍历有序的原因), 具体有两种顺序,  一个是插入顺序, 一个访问顺序; 同时, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;还可以用来实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法(&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 即最近最少使用算法); 本文将主要分析&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的两个大方面: 一个是遍历有序, 另一个是用于&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的特性&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-遍历有序&quot;&gt;二. 遍历有序&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;遍历有序, 主要是因为其在&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的基础上, 增加了一个双向链表, 按照元素的插入顺序或者访问顺序, 将数据重新组织成一个双向链表; 根据标志位&lt;code class=&quot;highlighter-rouge&quot;&gt;final boolean accessOrder;&lt;/code&gt;来决定是按照插入顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;insertion-order&lt;/code&gt;, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder = false&lt;/code&gt;)还是访问顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;access-order&lt;/code&gt;, 此时需要&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder = true&lt;/code&gt;)来组织&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;改写了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的节点, 如下; 在其中增加了&lt;code class=&quot;highlighter-rouge&quot;&gt;before&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;after&lt;/code&gt;域用于帮助组织双向链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Node&amp;lt;K,V&amp;gt; {
        Entry&amp;lt;K,V&amp;gt; before, after;
        Entry(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
            super(hash, key, value, next);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;值的指定只能在创建&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的时候, 也就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;并没有提供明确的&lt;code class=&quot;highlighter-rouge&quot;&gt;set()&lt;/code&gt;方法来改变该值(一旦在构造函数中指定, 就无法改变); &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;提供了如下构造函数可以用于指定&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;的值, 其余构造函数中, &lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;都默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, 即默认以&lt;code class=&quot;highlighter-rouge&quot;&gt;insertion-order&lt;/code&gt;的顺序组织双向链表&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public LinkedHashMap(int initialCapacity,
                         float loadFactor,
                         boolean accessOrder) {
        super(initialCapacity, loadFactor);
        this.accessOrder = accessOrder;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;重写了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;newNode()&lt;/code&gt;函数, &lt;code class=&quot;highlighter-rouge&quot;&gt;newNode()&lt;/code&gt;在进行元素插入的时候会被&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap.putVal()&lt;/code&gt;调用, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;用自己的&lt;code class=&quot;highlighter-rouge&quot;&gt;Entry&lt;/code&gt;节点替换&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;节点的同时, 进行双向链表的构建, 使得程序改动最小&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Node&amp;lt;K,V&amp;gt; newNode(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; e) {
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; p =
            new LinkedHashMap.Entry&amp;lt;K,V&amp;gt;(hash, key, value, e);
        linkNodeLast(p); // 将节点插入到双向链表的末尾
        return p;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于&lt;code class=&quot;highlighter-rouge&quot;&gt;linkNodeLast()&lt;/code&gt;函数, 即将节点插入到双向链表的末尾, 该方法比较简单, 这里就不再贴源码啦 !&lt;/p&gt;

&lt;p&gt;那么当我们指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;的时候, 即以元素访问顺序来组织双向链表的时候, 其实就只是在获取元素的时候, 将被访问的元素移动到链表末尾; 如下; 那么链表表头的元素就是最近没有被访问的元素, 这也是我们实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的依据(稍后会细讲)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public V get(Object key) {
        Node&amp;lt;K,V&amp;gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder) // 如果指定为按照元素访问顺序组织元素
            afterNodeAccess(e); // 将元素移动到链表末尾
        return e.value;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void afterNodeAccess(Node&amp;lt;K,V&amp;gt; e) { // move node to last
        // 省略具体细节
        ...
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里, 我们对&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;遍历有序的原因有了较为详细的了解; 接下来要讲的是&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的一个应用, 即用于实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法的特性&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-lru算法&quot;&gt;三. LRU算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;LRU算法&lt;/strong&gt;即&lt;code class=&quot;highlighter-rouge&quot;&gt;Least Recently Used&lt;/code&gt;, 其依据是&lt;strong&gt;如果数据最近被访问过, 那么其将来被访问的几率也更大&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Android&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;LruCache&lt;/code&gt;(内存缓存)内部就是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实现的&lt;/p&gt;

&lt;p&gt;前面我们讲了, 当&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即按照元素访问顺序组织数据的时候, 会在&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;方法中将被访问的元素移动到链表的末尾, 那么链表首部的元素就是最久没有访问的, 所以, 当要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;的时候, 必须将&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder&lt;/code&gt;置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外, 还需要我们自己去定义&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;的实现规则, 即自己定义什么时候应该移除最久没有使用的元素; 此时我们需要去重写&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;函数, &lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;是在我们插入一个元素完毕之后, 回调&lt;code class=&quot;highlighter-rouge&quot;&gt;afterNodeInsertion()&lt;/code&gt;中调用的, 如下; 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;默认返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, 所以需要我们自己去定义规则&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    void afterNodeInsertion(boolean evict) { // possibly remove eldest
        LinkedHashMap.Entry&amp;lt;K,V&amp;gt; first;
        if (evict &amp;amp;&amp;amp; (first = head) != null &amp;amp;&amp;amp; removeEldestEntry(first)) { // 插入元素之后, 判断是否需要移除最久没有访问的元素
            K key = first.key;
            removeNode(hash(key), key, null, false, true); // 移除链表首部的元素
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于自定义规则, 比如: 约定最多在内存中缓存多少个元素, 超过该阈值之后, &lt;code class=&quot;highlighter-rouge&quot;&gt;removeEldestEntry()&lt;/code&gt;返回&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;, 即将旧元素移除; 或者, 规定缓存占用多少内存, 当达到该阈值之后, 即进行旧元素移除; 当然, 这些都是后话, 具体的&lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;算法, 可以根据实际需求来定&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-总结&quot;&gt;四. 总结&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, 总体上比较简单, 主要掌握上文说的两个主要特点即可, 不再赘述 !&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之Set</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;的实现类, 即常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-概述&quot;&gt;一. 概述&lt;/h2&gt;

&lt;p&gt;需要注意的是, 本文要讲的&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;的几个实现类内部都是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;实现的, 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;实际上就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;, 依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;键值的唯一性实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;中元素的不可重复; 所以在学习&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;部分的时候, 只需要了解对应&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;的特点和实现就可以了; 因此, 本文也不会详细讲解各&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;实现类的代码细节, 而只是对每个实现类的特点进行一个总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-hashset&quot;&gt;二. HashSet&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;内部是基于&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;实现的, 所以在讲解&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;之前, 需要先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的实现, 可以参照&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;, 该篇文章中详细介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的实现原理和特点, 推荐对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;有了一个大致的了解之后再开始往下读 ~&lt;/p&gt;

&lt;p&gt;总体而言, &lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;的代码比较简单, 其实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;元素不重复性其实是利用&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;键值的唯一性; 当我们存放一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;的时候, 其实是将该&lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;当做&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中的键值的,  而实现的各种常规操作, 比如: &lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;等, 其实都是间接调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;中的相应操作&lt;/p&gt;

&lt;p&gt;所以, 这里不会去细讲&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;代码, 了解&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;之后, 其实是很简单的&lt;/p&gt;

&lt;p&gt;这里只是贴一下&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;的特点:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;没有重复元素, 允许&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不保证&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;的遍历顺序, 不保证元素的存储数据(具体原因可以见上面博客对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的分析)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;size()&lt;/code&gt;方法提供常量时间&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非同步, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedSet(new HashSet(...));&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历的时候, 多线程抛出异常&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;(遍历过程中修改数据, 但是可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;自己提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;方法, 该方法不会造成异常)(原因参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/&quot;&gt;Java集合框架之List&lt;/a&gt;中分析)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-treeset&quot;&gt;三. TreeSet&lt;/h2&gt;

&lt;p&gt;简要总结特点如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;是一个有序的集合类, 默认为自然顺序, 也可根据提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;需要&lt;code class=&quot;highlighter-rouge&quot;&gt;logN&lt;/code&gt;时间(是因为&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeMap&lt;/code&gt;是基于红黑树实现的)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非同步, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedSortedSet(new TreeSet(...));&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;抛异常: &lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-linkedhashset&quot;&gt;四. LinkedHashSet&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;, 建议参照&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的源码分析: &lt;a href=&quot;https://husteryp.github.io/2018/08/28/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BLinkedHashMap/&quot;&gt;Java集合框架之LinkedHashMap&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;总结特点如下:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;访问有序(&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;特点), 按照元素插入顺序访问(注意, 虽然&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;基于&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;实现, 而前面的文章分析了&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;有两种访问顺序, 但是&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;在构造&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashMap&lt;/code&gt;的时候使用的默认访问顺序, 即插入顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;accessOrder = false&lt;/code&gt;), 所以&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedHashSet&lt;/code&gt;的访问顺序只有一种, 即元素的插入顺序, 而且需要注意的是, 重复插入元素时是不会改变访问顺序的)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非同步: 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedSet(new LinkedHashSet(...));&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;contains()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;提供常量时间(具体可以参见&lt;a href=&quot;https://husteryp.github.io/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BHashMap/&quot;&gt;Java集合框架之HashMap&lt;/a&gt;中对&lt;code class=&quot;highlighter-rouge&quot;&gt;HashMap&lt;/code&gt;的分析)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BSet/</guid>
        
        <category>Java</category>
        
        
      </item>
    
      <item>
        <title>Java集合框架之List</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://husteryp.github.io/2018/08/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0/&quot;&gt;前面&lt;/a&gt;我们对Java集合框架有了一个基本的认识, 这里我们从几大接口入手, 逐步讲解其实现类; 下面要讲解的是&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;的实现类, 即常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文章源码基于&lt;code class=&quot;highlighter-rouge&quot;&gt;JDK8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;一-arraylist&quot;&gt;一. ArrayList&lt;/h2&gt;

&lt;h3 id=&quot;11-特点概述&quot;&gt;1.1 特点概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;这里先将结论给出, 稍后会挑重难点详细讲解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动态数组: &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;是一个动态数组, 所谓的动态数组, 就是使用时不必担心扩容问题(会自动扩容, 其实现原理其实也是通过创建一个更大的数组来进行数据拷贝, 关于扩容规则稍后会细讲);&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持随机访问: 既然是基于数组实现的, 那么其当然也就具备了数组的随机访问特点, &lt;code class=&quot;highlighter-rouge&quot;&gt;Java&lt;/code&gt;中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RandomAccess&lt;/code&gt;接口来标识&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;是否支持随机访问(该接口实际上没有方法, 只是为了在使用某些算法时, 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof RandomAccess&lt;/code&gt;去判断作用对象是否支持随机访问, 如果支持的话, 就可以使用某些特定算法)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;支持序列化: 实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程不安全: 多线程使用时可能会出现问题&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;12-动态数组&quot;&gt;1.2 动态数组&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;的默认初始容量为&lt;strong&gt;10&lt;/strong&gt;, 其提供了三个构造函数, 分别是: &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList(int initialCapacity)&lt;/code&gt;(支持指定初始容量); &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList()&lt;/code&gt;(无参构造函数); &lt;code class=&quot;highlighter-rouge&quot;&gt;public ArrayList(Collection&amp;lt;? extends E&amp;gt; c)&lt;/code&gt;(支持从已有数据集创建)&lt;/p&gt;

&lt;p&gt;我们最常见的用法是: &lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&amp;lt;T&amp;gt; arr = new ArrayList();&lt;/code&gt;; 因此我们先来看其无参构造函数, 如下;  其中&lt;code class=&quot;highlighter-rouge&quot;&gt;elementData&lt;/code&gt;就是用于存储数据的数组; &lt;code class=&quot;highlighter-rouge&quot;&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt;是一个初始长度为&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;的数组, 这样设计的原因也是为了节约空间(因为没必要一开始就占用内存空间, 合理的做法应该是在具体需要使用的时候再去分配)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果是使用无参构造函数进行创建的话, 那么在第一次使用&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;进行数据添加的时候会进行第一次扩容, 也就是扩展到默认初始容量(10); 见下面代码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // 此时size为0
        elementData[size++] = e;
        return true;
    }

    private static int calculateCapacity(Object[] elementData, int minCapacity) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // 这里相等进入
            return Math.max(DEFAULT_CAPACITY, minCapacity); // 返回默认初始容量
        }
        return minCapacity;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那如果并非是第一次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;add()&lt;/code&gt;操作呢, 其扩容规则又如何; 这里的代码也比较简单, 在下面的&lt;code class=&quot;highlighter-rouge&quot;&gt;grow()&lt;/code&gt;函数中; 逻辑比较简单, 扩容规则是, 增加当前数组长度的&lt;strong&gt;50%&lt;/strong&gt;; 那么是不是每次执行&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;操作的时候都会进行扩容呢, 肯定不是的, 只有当&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;会造成溢出时才会进行扩容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private void grow(int minCapacity) {
        int oldCapacity = elementData.length; // 注意这里用来判断的是数组的长度, 而不是当前数据个数
        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1); // 扩容50%
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13-随机访问&quot;&gt;1.3 随机访问&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;由于内部使用数组实现, 所以能够支持快速的索引定位, 但是数组的连续空间在带来增加和索引查找便利的同时, 也使得删除元素变得相对耗时, 所以在实际使用的时候, 需要根据需求特点来合理选择&lt;/p&gt;

&lt;h3 id=&quot;14-iterator遍历&quot;&gt;1.4 Iterator遍历&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;支持普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历, 也自己实现了一个特殊的&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;遍历&lt;/p&gt;

&lt;h4 id=&quot;14-1-iterator遍历的效率&quot;&gt;1.4-1 Iterator遍历的效率&lt;/h4&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历, &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环遍历和&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;遍历的效率分析, 可以参见文末&lt;strong&gt;参考链接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里只是单纯的讲一下结论:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环遍历的效率比另外两种高, 因为其支持随机访问; &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;循环适合访问顺序存储结构, 可以根据下标快速获取指定元素(即支持随机访问)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;适合访问链式存储结构(如在&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;中其访问效率就比&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;高), 因为迭代器是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Pre()&lt;/code&gt;来定位的, 但它也可以访问顺序存储结构的集合(&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;的使用效率其实和&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;差不多)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;最大的一个好处是, 可以随时修改或者删除集合内部的元素, 并且是在不需要知道元素和集合的类型的情况下进行的(当需要对不同的容器实现同样的遍历方式时, 迭代器是最好的选择)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;14-2-iterator和listiterator&quot;&gt;1.4-2 Iterator和ListIterator&lt;/h4&gt;

&lt;p&gt;二者最大的区别就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;支持双向的遍历, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;只是常规的从头到尾的遍历&lt;/p&gt;

&lt;h3 id=&quot;15-线程不安全&quot;&gt;1.5 线程不安全&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;不是一个线程安全的集合, 如果要在多线程的情况下使用, 可以考虑用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedList(List l)&lt;/code&gt;函数返回一个线程安全的&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;类, 也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;concurrent&lt;/code&gt;并发包下的&lt;code class=&quot;highlighter-rouge&quot;&gt;CopyOnWriteArrayList&lt;/code&gt;类或者遗留的&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;遍历的过程中, 如果用户&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;了元素的话, 会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;异常, 其实这也是一种保护机制, 具体代码如下; 至于&lt;code class=&quot;highlighter-rouge&quot;&gt;modCount&lt;/code&gt;是每次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法都会自增的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        public E next() {
            checkForComodification();
            ...
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }

        int expectedModCount = ArrayList.this.modCount;  // 这个值在初始化Iterator时就确定了
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;二-linkedlist&quot;&gt;二. LinkedList&lt;/h2&gt;

&lt;h3 id=&quot;21-特点概述&quot;&gt;2.1 特点概述&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;老规矩, 先给出总的结论!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;特殊数据结构: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;可以被用作特殊的数据结构, 如: 双向链表, 堆栈, 队列或者双端队列等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;序列化: 实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;Serializable&lt;/code&gt;接口&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程不安全: &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;不支持线程同步, 当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;去遍历的时候, 在多线程时, 可能会出现问题(抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;ConcurrentModificationException&lt;/code&gt;异常)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;22-特殊数据结构&quot;&gt;2.2 特殊数据结构&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;内部是以&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;为节点连接起来的一个链表, 从&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;节点的组织方式(如下), 其实也可以看出, 其有两个指针, 一个指向前驱, 一个指向后继, 那么很自然的, 其就支持双向的遍历, 同时, &lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;对外提供了丰富的接口, 让我们可以根据自己的需要, 去选择将其视为哪种数据结构来使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private static class Node&amp;lt;E&amp;gt; {
        E item;
        Node&amp;lt;E&amp;gt; next;
        Node&amp;lt;E&amp;gt; prev;

        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;一样, 我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;来方便的实现双向的遍历, 同时其还提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;addFirst()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;addLast()&lt;/code&gt;方法, 以及明确的&lt;code class=&quot;highlighter-rouge&quot;&gt;push()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pop()&lt;/code&gt;方法, 那么我们就可以根据自己的组织方式将其视为双向链表或者堆栈等来使用, 当然, 其还有许多其他有用接口, 具体使用时再去查看即可, 这里不做多讲&lt;/p&gt;

&lt;h3 id=&quot;23-线程不安全&quot;&gt;2.3 线程不安全&lt;/h3&gt;

&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;一样, 其也没有实现线程同步, 所以在多线程时, 也要慎用; 当然, 可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.synchronizedList(new LinkedList(...))&lt;/code&gt;来进行包装, 成为一个线程安全的&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;上面讲了&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ListIterator&lt;/code&gt;遍历的过程中, 如果对数据进行了修改, 那么会抛出异常, 对于&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;也有同样的问题, 原因也一样, 这里不再赘述&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;三-总结&quot;&gt;三. 总结&lt;/h2&gt;

&lt;p&gt;到这里, 与&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;有关的两个常用实现类&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayList&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;LinkedList&lt;/code&gt;就讲解完了, 重点在于掌握每种实现的特点, 在实际使用的时候再去具体选择, 总的来说, 这两种实现都比较简单, 涉及到的算法也不难; 需要回顾的话, 翻到前面去看每种实现的概述即可!&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;四-参考链接&quot;&gt;四. 参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/aoguren/p/4771589.html&quot;&gt;Iterator和for效率分析&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Aug 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/27/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B9%8BList/</guid>
        
        <category>Java</category>
        
        
      </item>
    
  </channel>
</rss>
